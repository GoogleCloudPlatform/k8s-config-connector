// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package runner

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// NOT USED
/*
const GENERATOR_SCRIPT_TEMPLATE = `#!/bin/bash
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd ${REPO_ROOT}/dev/tools/controllerbuilder

go run . generate-types \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION> \
    --resource <CRD_KIND>:<PROTO_RESOURCE>

go run . generate-mapper \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION>

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
const UPDATE_GENERATE_SCRIPT_PROMPT = `
Please update the apis/<SERVICE>/v1alpha1/generate.sh script for the <SERVICE> API to generate the CRD for the <CRD_KIND> resource.

The generate.sh script is located at apis/<SERVICE>/v1alpha1/generate.sh.

Add the parameter <TICK> --resource <CRD_KIND>:<PROTO_RESOURCE><TICK> to the <TICK>go run . generate-types --api-version <CRD_GROUP>/<CRD_VERSION>  <TICK> command.

At the end of the script, ensure the following lines are present:

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
func generateCRDFromScripts(opts *RunnerOptions, branch Branch) {
	close := setLoggingWriter(opts, branch)
	defer close()
	workDir := opts.branchRepoDir

	var out strings.Builder
	checkoutBranch(branch, workDir, &out)

	// Create the apis/<service>/<version> directory
	serviceDir := filepath.Join(workDir, "apis", branch.Group, "v1alpha1")
	if err := os.MkdirAll(serviceDir, 0755); err != nil {
		log.Fatal(err)
	}

	// Create or update generate.sh
	scriptPath := filepath.Join(serviceDir, "generate.sh")
	// Check if generate.sh already exists.
	if _, err := os.Stat(scriptPath); errors.Is(err, os.ErrNotExist) {
		// File doesn't exist, use template approach
		log.Printf("Creating new generate.sh at %s", scriptPath)

		// Replace template markers with actual values and write to file
		writeTemplateToFile(branch, scriptPath, GENERATOR_SCRIPT_TEMPLATE)
	} else {
		// File exists, use codebot to update it
		log.Printf("Updating existing generate.sh at %s", scriptPath)

		// Delete then write the prompt file.
		promptPath := filepath.Join(workDir, "mockgcp", "crdgen_prompt.txt")
		writeTemplateToFile(branch, promptPath, UPDATE_GENERATE_SCRIPT_PROMPT)

		cfg := CommandConfig{
			Name:    "CODEBOT GENERATE",
			Cmd:     "codebot",
			Args:    []string{"--ui-type=prompt", "--prompt=mockgcp/crdgen_prompt.txt"},
			WorkDir: workDir,
		}
		if err := executeCommand(cfg, &out); err != nil {
			log.Fatal(err)
		}
	}

	// Stage the changed files
	scriptRelativePath := filepath.Join("apis", branch.Group, "v1alpha1", "generate.sh")
	gitAdd(workDir, &out, scriptRelativePath)

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("add/update crd generation script for %s", branch.Group))

	// Run the generator script
	cfg := CommandConfig{
		Name:    "Generator script",
		Cmd:     scriptPath,
		WorkDir: workDir,
	}
	if err := executeCommand(cfg, &out); err != nil {
		log.Fatal(err)
	}

	// Stage the changed files
	gitAdd(workDir, &out,
		fmt.Sprintf("apis/%s/v1alpha1/", branch.Group),
		fmt.Sprintf("pkg/controller/direct/%s/", branch.Group),
		"config/crds/resources/")

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("autogenerated types and CRDs using %s", scriptRelativePath))
}
*/

func generateTypes(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, nil, fmt.Errorf("missing required parameters")
	}

	// Generate types
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	apiDirPath := filepath.Join(opts.branchRepoDir, apiDirPathRelative)
	if _, err := os.Stat(apiDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate types",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-types",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
				"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 1,
		}
		results, err := executeCommand(opts, cfg)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to generate types: %w", err)
		}
		return []string{apiDirPathRelative}, &results, nil
	}

	log.Printf("SKIPPING generating apis, %s already exists", apiDirPathRelative)
	return nil, nil, nil
}

func generateMapper(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, nil, fmt.Errorf("missing required parameters")
	}

	// Generate mapper
	mapperDirPathRelative := filepath.Join("pkg", "controller", "direct", branch.Group, string(filepath.Separator))
	mapperDirPath := filepath.Join(opts.branchRepoDir, mapperDirPathRelative)
	if _, err := os.Stat(mapperDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate mapper",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-mapper",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 2,
		}
		results, err := executeCommand(opts, cfg)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to generate mapper: %w", err)
		}

		return []string{mapperDirPathRelative}, &results, nil
	}

	log.Printf("SKIPPING generating mappers, %s already exists", mapperDirPathRelative)
	return nil, nil, nil
}

func generateCRD(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	affectedPaths := []string{"config/crds/resources/", apiDirPathRelative}

	// Generate CRDs
	cfg := CommandConfig{
		Name:        "Generate CRDs",
		Cmd:         filepath.Join(opts.branchRepoDir, "dev", "tasks", "generate-crds"),
		WorkDir:     opts.branchRepoDir,
		MaxAttempts: 1,
	}

	results, err := executeCommand(opts, cfg)
	return affectedPaths, &results, err
}

func generateSpecStatus(opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	affectedPaths := []string{
		filepath.Join("apis", branch.Group, "v1alpha1",
			fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource))),
	}

	// Run controllerbuilder to generate spec and status
	log.Printf("Generating spec and status for %s", branch.Name)
	stdinInput := fmt.Sprintf("// +kcc:proto=%s.%s\n", branch.ProtoSvc, branch.Proto)

	cfg := CommandConfig{
		Name: "Spec/Status generation",
		Cmd:  "controllerbuilder",
		Args: []string{
			"prompt",
			"--src-dir", opts.branchRepoDir,
			"--proto-dir", filepath.Join(opts.branchRepoDir, ".build", "third_party", "googleapis"),
		},
		WorkDir:      opts.branchRepoDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	results, err := executeCommand(opts, cfg)
	//commitMsg := fmt.Sprintf("Generated spec and status for %s", branch.Kind)
	return affectedPaths, &results, err
}

func generateFuzzer(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	workDir := opts.branchRepoDir
	affectedPaths := []string{}

	// Generate fuzzer file
	fuzzerDir := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", branch.Group)
	if err := os.MkdirAll(fuzzerDir, 0755); err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to create fuzzer directory: %w", err)
	}

	fuzzerPath := filepath.Join(fuzzerDir, fmt.Sprintf("%s_fuzzer.go", strings.ToLower(branch.Resource)))
	stdinInput := fmt.Sprintf(`// +tool:fuzz-gen
// proto.message: %s
`, branch.ProtoMsg)

	cfg := CommandConfig{
		Name:         "Fuzzer generation",
		Cmd:          "controllerbuilder",
		Args:         []string{"prompt", "--src-dir", workDir, "--proto-dir", filepath.Join(workDir, ".build", "third_party", "googleapis")},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	output, err := executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to generate fuzzer: %w", err)
	}

	if err := os.WriteFile(fuzzerPath, []byte(output.Stdout), 0644); err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to write fuzzer file: %w", err)
	}

	affectedPaths = append(affectedPaths, fuzzerPath)

	// Update register.go to import the new package
	registerPath := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", "register", "register.go")
	importLine := fmt.Sprintf(`_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/%s"`, branch.Group)
	stdinInput = fmt.Sprintf("Add an unnamed (_) go import for %s to the imports in %s", importLine, registerPath)

	cfg = CommandConfig{
		Name:         "Import addition",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	_, err = executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to add import: %w", err)
	}

	affectedPaths = append(affectedPaths, registerPath)

	return affectedPaths, &output, nil
}

const SET_TYPE_SPEC_STATUS string = `I need to set the Spec and Status fields in the generated KRM type ${KIND} to match the proto ${PROTO_RESOURCE} definition.

Main Objectives:
1. Copy all the Fields from the ${PROTO_RESOURCE} struct in ${GENERATED_TYPES_FILE} to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
2. if ${PROTO_RESOURCE}ObservedState struct exists, copy all the Fields from the ${PROTO_RESOURCE}ObservedState to the ${KIND}ObservedState struct in ${RESOURCE_TYPES_FILES}.
3. if ${PROTO_RESOURCE}ObservedState struct does not exist, remove the ${KIND}ObservedState struct from ${RESOURCE_TYPES_FILES}.
4. Dont remove the existing ResourceID field from the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
5. Please do not modify the ${GENERATED_TYPES_FILE} file.
6. Please do not modify the ${IDENTITY_FILE} file.
7. Make sure to copy all the fields from the ${PROTO_RESOURCE} struct in ${GENERATED_TYPES_FILE} to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.


If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${IDENTITY_FILE} file.
Alternatively use EditFile tool to change the contents of the ${IDENTITY_FILE}.
Please do not modify the ${RESOURCE_TYPES_FILES} file.
Please ignore the compilation errors due to missing DeepCopy methods
Please update the ${RESOURCE_TYPES_FILES} file with the adjusted types.

Please ignore the compilation errors and dont verify or try to fix:
1. compilation error due to missing DeepCopy methods
2. Errors in the ${IDENTITY_FILE} file


Contents of ${GENERATED_TYPES_FILE}:
${GENERATED_TYPES_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

`

func setTypeSpecStatus(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	generatedTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, generatedTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read generated types file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(SET_TYPE_SPEC_STATUS, "${GENERATED_TYPES_FILE}", string(generatedTypesPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${GENERATED_TYPES_FILE_CONTENTS}", string(generatedTypesContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Set spec and status",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

const SET_TYPE_PARENT string = `I need to add a Parent struct in the generated ${KIND}Spec struct.

Given:
- Generated types file: ${GENERATED_TYPES_FILE}
- resource types files: ${RESOURCE_TYPES_FILES}
- Proto resource: ${PROTO_RESOURCE}
- Proto files: 
    ${PROTO_FILES}

Main Objectives:
1. Add the Parent field to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
- Parent <TICK>json:",inline"<TICK>
2. Add the Parent struct before the ${KIND}Spec struct in ${RESOURCE_TYPES_FILES}.
3. Please do not modify the ${GENERATED_TYPES_FILE} file.
4. Please do not remove any other fields from the ${KIND}Spec struct.

Please ignore the compilation errors and dont verify or try to fix:
1. compilation error due to missing DeepCopy methods
2. Errors in the ${IDENTITY_FILE} file

Rules for generating the Parent struct:
1.  example Parent structs are:
type Parent struct {
	// +required
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +required
	Location string <TICK>json:"location"<TICK>
}

type Parent struct {
	// +required
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
}

type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef"<TICK>
}

2. Inspect the ${PROTO_FILES} to determine the fields for the Parent struct. 
3. Look for the multiple "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> to determine the parent fields

4. For example, if the multiple "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> are:
    <TICK>
    pattern: "projects/{project}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "folders/{folder}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "organizations/{organization}/locations/{location}/quotaPreferences/{quota_preference}"
    <TICK>
  would result in the following Parent struct:

type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef"<TICK>
}

5. refv1beta1 package comes from "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"

6. Please make sure there is only one import block in the ${RESOURCE_TYPES_FILES} file and it appears at the beginning of the file.

If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${IDENTITY_FILE} file.
Alternatively use EditFile tool to change the contents of the ${IDENTITY_FILE}.
Please do not modify the ${RESOURCE_TYPES_FILES} file.
Please ignore the compilation errors due to missing DeepCopy methods
Please update the ${RESOURCE_TYPES_FILES} file with the adjusted types.

Contents of ${GENERATED_TYPES_FILE}:
${GENERATED_TYPES_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func setTypeParent(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	generatedTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, generatedTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read generated types file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(SET_TYPE_PARENT, "${GENERATED_TYPES_FILE}", string(generatedTypesPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${GENERATED_TYPES_FILE_CONTENTS}", string(generatedTypesContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Set parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

func regenerateTypes(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	// Regenerate types
	cfg := CommandConfig{
		Name: "Regenerate types",
		Cmd:  "go",
		Args: []string{
			"run", ".",
			"generate-types",
			"--service", branch.Package,
			"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
		},
		WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
		MaxAttempts: 1,
	}
	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath, generatedTypesPath}, &results, err
}

const ADJUST_IDENTITY_PARENT string = `I want you to update the ${PROTO_RESOURCE}Parent struct in the ${IDENTITY_FILE} file along with the String() method and the Parse${PROTO_RESOURCE}External method.

Step 1: Changing the ${PROTO_RESOURCE}Parent struct:
Inspect the Parent structs in the ${RESOURCE_TYPES_FILES} file to determine the fields for the ${PROTO_RESOURCE}Parent struct.
   For example, if the ${RESOURCE_TYPES_FILES} file has the following Parent structs:
type Parent struct {
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef,omitempty"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef,omitempty"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef,omitempty"<TICK>
}
   we need to generate the following ${PROTO_RESOURCE}Parent struct:
type ${PROTO_RESOURCE}Parent struct {
	ProjectID      string
	OrganizationID string
	FolderID       string
	Location       string
}

If the ${RESOURCE_TYPES_FILES} file has the following Parent struct:
type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +required
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef,omitempty"<TICK>
	// +required
	SomeGroup *refv1beta1.SomeGroup <TICK>json:"someGroupRef,omitempty"<TICK>
}
   we need to generate the following ${PROTO_RESOURCE}Parent struct:
type ${PROTO_RESOURCE}Parent struct {
	ProjectID      string
	Location       string
	SomeGroupID    string
}

Step 2: Changing the ${PROTO_RESOURCE}Parent's String() method:
Please update the ${PROTO_RESOURCE}Parent's String() method to return the correct string.
Please inspect the <TICK>message ${PROTO_RESOURCE}<TICK>'s pattern fields to determine the correct pattern.

Step 3: Changing the Parse${PROTO_RESOURCE}External method:
Please update the Parse${PROTO_RESOURCE}External method to parse the ${PROTO_RESOURCE}Parent from a string.

Step 4: Updating the New${PROTO_RESOURCE}Identity method:
Please update the New${PROTO_RESOURCE}Identity method to use the new ${PROTO_RESOURCE}Parent struct.

Step 5: Update the resource camelCase name in URLs:
Please update the resource camelCase name in URLs.
Refer to the <TICK>message ${PROTO_RESOURCE}<TICK>'s pattern fields to determine the correct camelCase name.

If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${IDENTITY_FILE} file.
Alternatively use EditFile tool to change the contents of the ${IDENTITY_FILE}.
If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the ${PROTO_RESOURCE}Parent struct stating that no changes were needed.
Please do not modify the ${RESOURCE_TYPES_FILES} file.
Please ignore the compilation errors due to missing DeepCopy methods

Make sure to use either CreateFile or EditFile tool.

Once the file is updated, please ReadFile the ${IDENTITY_FILE} file to verify all the changes have been made.

Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func adjustIdentityParent(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	identityContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, identityPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read identity file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(ADJUST_IDENTITY_PARENT, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE_CONTENTS}", string(identityContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{identityPath}, &results, err
}

const ADJUST_IDENTITY_PARENT_NEW_FUNCTION string = `I want you to update the New${PROTO_RESOURCE}Identity method in the ${IDENTITY_FILE} file.

Main Objectives:
1. Modify the New${PROTO_RESOURCE}Identity method in ${IDENTITY_FILE}.
2. Please do not modify the ${RESOURCE_TYPES_FILES} file.
4. Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

Rules for modifying the New${PROTO_RESOURCE}Identity method:
1. The New${PROTO_RESOURCE}Identity method should be updated to resolve the fields of the ${PROTO_RESOURCE}Parent.
2. The fields of the ${PROTO_RESOURCE}Parent are resolved from the Parent fields in the ${RESOURCE_TYPES_FILES} file.
3. An example resolution of the ${PROTO_RESOURCE}Parent fields is:
	// Get Parent
	projectRef, err := refsv1beta1.ResolveProject(ctx, reader, obj.GetNamespace(), obj.Spec.ProjectRef)
	if err != nil {
		return nil, err
	}
4. Make sure that all fields of the ${PROTO_RESOURCE}Parent are resolved.
5. Make sure all the fields of ${PROTO_RESOURCE}Parent are set in the return value.
6. Please do not modify the ${RESOURCE_TYPES_FILES} file.
7.  Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the New${PROTO_RESOURCE}Identity method stating that no changes were needed.

Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILES}:
${RESOURCE_TYPES_FILES_CONTENTS}

`

func adjustIdentityParentNewFunction(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", strings.ToLower(branch.Resource)))
	// Read all proto files in the directory
	protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

	protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read proto directory: %w", err)
	}
	var protoContents strings.Builder
	protoFileRelativePaths := []string{}
	for _, file := range protoFiles {
		if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
			filePathRelative := filepath.Join(protoDirRelative, file.Name())
			protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)
			content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
			if err != nil {
				return nil, nil, fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
			}
			protoContents.WriteString("------- " + filePathRelative + " -------\n")
			protoContents.Write(content)
			protoContents.WriteString("\n-------- end ------------------\n")
		}
	}

	identityContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, identityPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read identity file: %w", err)
	}

	resourceTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, resourceTypesPath))
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read resource types file: %w", err)
	}

	// Create prompt with file contents
	prompt := strings.ReplaceAll(ADJUST_IDENTITY_PARENT_NEW_FUNCTION, "${IDENTITY_FILE}", string(identityPath))
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES}", string(resourceTypesPath))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))

	prompt = strings.ReplaceAll(prompt, "${RESOURCE_TYPES_FILES_CONTENTS}", string(resourceTypesContent))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE_CONTENTS}", string(identityContent))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent new function",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{identityPath}, &results, err
}
