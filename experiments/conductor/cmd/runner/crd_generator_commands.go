// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package runner

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// NOT USED
/*
const GENERATOR_SCRIPT_TEMPLATE = `#!/bin/bash
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd ${REPO_ROOT}/dev/tools/controllerbuilder

go run . generate-types \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION> \
    --resource <CRD_KIND>:<PROTO_RESOURCE>

go run . generate-mapper \
    --service <PROTO_PACKAGE> \
    --api-version <CRD_GROUP>/<CRD_VERSION>

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
const UPDATE_GENERATE_SCRIPT_PROMPT = `
Please update the apis/<SERVICE>/v1alpha1/generate.sh script for the <SERVICE> API to generate the CRD for the <CRD_KIND> resource.

The generate.sh script is located at apis/<SERVICE>/v1alpha1/generate.sh.

Add the parameter <TICK> --resource <CRD_KIND>:<PROTO_RESOURCE><TICK> to the <TICK>go run . generate-types --api-version <CRD_GROUP>/<CRD_VERSION>  <TICK> command.

At the end of the script, ensure the following lines are present:

cd ${REPO_ROOT}
dev/tasks/generate-crds

go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/<SERVICE>/
`

// NOT USED
func generateCRDFromScripts(opts *RunnerOptions, branch Branch) {
	close := setLoggingWriter(opts, branch)
	defer close()
	workDir := opts.branchRepoDir

	var out strings.Builder
	checkoutBranch(branch, workDir, &out)

	// Create the apis/<service>/<version> directory
	serviceDir := filepath.Join(workDir, "apis", branch.Group, "v1alpha1")
	if err := os.MkdirAll(serviceDir, 0755); err != nil {
		log.Fatal(err)
	}

	// Create or update generate.sh
	scriptPath := filepath.Join(serviceDir, "generate.sh")
	// Check if generate.sh already exists.
	if _, err := os.Stat(scriptPath); errors.Is(err, os.ErrNotExist) {
		// File doesn't exist, use template approach
		log.Printf("Creating new generate.sh at %s", scriptPath)

		// Replace template markers with actual values and write to file
		writeTemplateToFile(branch, scriptPath, GENERATOR_SCRIPT_TEMPLATE)
	} else {
		// File exists, use codebot to update it
		log.Printf("Updating existing generate.sh at %s", scriptPath)

		// Delete then write the prompt file.
		promptPath := filepath.Join(workDir, "mockgcp", "crdgen_prompt.txt")
		writeTemplateToFile(branch, promptPath, UPDATE_GENERATE_SCRIPT_PROMPT)

		cfg := CommandConfig{
			Name:    "CODEBOT GENERATE",
			Cmd:     "codebot",
			Args:    []string{"--ui-type=prompt", "--prompt=mockgcp/crdgen_prompt.txt"},
			WorkDir: workDir,
		}
		if err := executeCommand(cfg, &out); err != nil {
			log.Fatal(err)
		}
	}

	// Stage the changed files
	scriptRelativePath := filepath.Join("apis", branch.Group, "v1alpha1", "generate.sh")
	gitAdd(workDir, &out, scriptRelativePath)

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("add/update crd generation script for %s", branch.Group))

	// Run the generator script
	cfg := CommandConfig{
		Name:    "Generator script",
		Cmd:     scriptPath,
		WorkDir: workDir,
	}
	if err := executeCommand(cfg, &out); err != nil {
		log.Fatal(err)
	}

	// Stage the changed files
	gitAdd(workDir, &out,
		fmt.Sprintf("apis/%s/v1alpha1/", branch.Group),
		fmt.Sprintf("pkg/controller/direct/%s/", branch.Group),
		"config/crds/resources/")

	// Commit the changes
	gitCommit(workDir, &out, fmt.Sprintf("autogenerated types and CRDs using %s", scriptRelativePath))
}
*/

func generateTypes(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, nil, fmt.Errorf("missing required parameters")
	}

	// Generate types
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	apiDirPath := filepath.Join(opts.branchRepoDir, apiDirPathRelative)
	affectedPaths := []string{apiDirPathRelative}
	if _, err := os.Stat(apiDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate types",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-types",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
				"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 1,
		}
		results, err := executeCommand(opts, cfg)
		return affectedPaths, &results, err
	}

	log.Printf("SKIPPING generating apis, %s already exists", apiDirPathRelative)
	return affectedPaths, nil, nil
}

func generateMapper(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	// Check parameters
	if branch.Kind == "" || branch.Proto == "" || branch.Group == "" {
		if branch.Kind == "" {
			log.Printf("SKIPPING %s, missing Kind", branch.Name)
		}
		if branch.Proto == "" {
			log.Printf("SKIPPING %s, missing Proto", branch.Name)
		}
		if branch.Group == "" {
			log.Printf("SKIPPING %s, missing Group", branch.Name)
		}
		return nil, nil, fmt.Errorf("missing required parameters")
	}

	// Generate mapper
	mapperDirPathRelative := filepath.Join("pkg", "controller", "direct", branch.Group, string(filepath.Separator))
	mapperDirPath := filepath.Join(opts.branchRepoDir, mapperDirPathRelative)
	affectedPaths := []string{mapperDirPathRelative}
	if _, err := os.Stat(mapperDirPath); errors.Is(err, os.ErrNotExist) || opts.force {
		cfg := CommandConfig{
			Name: "Generate mapper",
			Cmd:  "go",
			Args: []string{
				"run", ".",
				"generate-mapper",
				"--service", branch.Package,
				"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			},
			WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
			MaxAttempts: 2,
		}
		results, err := executeCommand(opts, cfg)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to generate mapper: %w", err)
		}

		return affectedPaths, &results, nil
	}

	log.Printf("SKIPPING generating mappers, %s already exists", mapperDirPathRelative)
	return affectedPaths, nil, nil
}

func generateCRD(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	apiDirPathRelative := filepath.Join("apis", branch.Group, "v1alpha1", string(filepath.Separator))
	affectedPaths := []string{"config/crds/resources/", apiDirPathRelative}

	// Generate CRDs
	cfg := CommandConfig{
		Name:        "Generate CRDs",
		Cmd:         filepath.Join(opts.branchRepoDir, "dev", "tasks", "generate-crds"),
		WorkDir:     opts.branchRepoDir,
		MaxAttempts: 1,
	}

	results, err := executeCommand(opts, cfg)
	return affectedPaths, &results, err
}

func generateSpecStatus(opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	affectedPaths := []string{
		filepath.Join("apis", branch.Group, "v1alpha1",
			fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource))),
	}

	// Run controllerbuilder to generate spec and status
	log.Printf("Generating spec and status for %s", branch.Name)
	stdinInput := fmt.Sprintf("// +kcc:proto=%s.%s\n", branch.ProtoSvc, branch.Proto)

	cfg := CommandConfig{
		Name: "Spec/Status generation",
		Cmd:  "controllerbuilder",
		Args: []string{
			"prompt",
			"--src-dir", opts.branchRepoDir,
			"--proto-dir", filepath.Join(opts.branchRepoDir, ".build", "third_party", "googleapis"),
		},
		WorkDir:      opts.branchRepoDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	results, err := executeCommand(opts, cfg)
	//commitMsg := fmt.Sprintf("Generated spec and status for %s", branch.Kind)
	return affectedPaths, &results, err
}

func generateFuzzer(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	workDir := opts.branchRepoDir
	affectedPaths := []string{}

	// Generate fuzzer file
	fuzzerDir := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", branch.Group)
	if err := os.MkdirAll(fuzzerDir, 0755); err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to create fuzzer directory: %w", err)
	}

	fuzzerPath := filepath.Join(fuzzerDir, fmt.Sprintf("%s_fuzzer.go", strings.ToLower(branch.Resource)))
	stdinInput := fmt.Sprintf(`// +tool:fuzz-gen
// proto.message: %s
`, branch.ProtoMsg)

	cfg := CommandConfig{
		Name:         "Fuzzer generation",
		Cmd:          "controllerbuilder",
		Args:         []string{"prompt", "--src-dir", workDir, "--proto-dir", filepath.Join(workDir, ".build", "third_party", "googleapis")},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	output, err := executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to generate fuzzer: %w", err)
	}

	if err := os.WriteFile(fuzzerPath, []byte(output.Stdout), 0644); err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to write fuzzer file: %w", err)
	}

	affectedPaths = append(affectedPaths, fuzzerPath)

	// Update register.go to import the new package
	registerPath := filepath.Join(opts.branchRepoDir, "pkg", "controller", "direct", "register", "register.go")
	importLine := fmt.Sprintf(`_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/%s"`, branch.Group)
	stdinInput = fmt.Sprintf("Add an unnamed (_) go import for %s to the imports in %s", importLine, registerPath)

	cfg = CommandConfig{
		Name:         "Import addition",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		WorkDir:      workDir,
		Stdin:        strings.NewReader(stdinInput),
		RetryBackoff: GenerativeCommandRetryBackoff,
	}
	_, err = executeCommand(opts, cfg)
	if err != nil {
		return affectedPaths, nil, fmt.Errorf("failed to add import: %w", err)
	}

	affectedPaths = append(affectedPaths, registerPath)

	return affectedPaths, &output, nil
}

const SET_TYPE_SPEC_STATUS string = `
Update the ${KIND}Spec fields:
1. Copy all the Fields from the ${PROTO_RESOURCE} struct in ${GENERATED_TYPES_FILE} to the ${KIND}Spec struct in ${RESOURCE_TYPES_FILE}.
2. Dont remove the existing ResourceID field from the ${KIND}Spec struct in ${RESOURCE_TYPES_FILE}.
Update the ${KIND}ObservedState fields:
1. If ${PROTO_RESOURCE}ObservedState struct exists, copy all the Fields from the ${PROTO_RESOURCE}ObservedState to the ${KIND}ObservedState struct in ${RESOURCE_TYPES_FILE}.
2. if ${PROTO_RESOURCE}ObservedState struct does not exist, remove the ${KIND}ObservedState struct from ${RESOURCE_TYPES_FILE}.

Dont modify any other files.

Use EditFile tool to change the contents of the ${RESOURCE_TYPES_FILE}.
If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the file.

Please ignore the compilation errors and dont verify or try to fix them.

Files referenced in this prompt:
${GENERATED_TYPES_FILE}
${RESOURCE_TYPES_FILE}
`

func setTypeSpecStatus(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, SET_TYPE_SPEC_STATUS)
	if err != nil {
		return nil, nil, err
	}

	// Run codebot with the prepared prompt
	cfg := CommandConfig{
		Name:         "Set spec and status",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

const SET_TYPE_PARENT string = `
We need to create a Parent struct in the ${RESOURCE_TYPES_FILE} file.
And include the Parent field in the ${KIND}Spec struct: Parent <TICK>json:",inline"<TICK>
1. Refer to the "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> to determine the parent fields
2. Use ReadFile tool to read the contents of the ${PROTO_FILES} files to find the <TICK>message ${PROTO_RESOURCE}<TICK>

If the "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> have 3 levels, use the first 2 levels in the Parent struct.
If there are multiple patterns, collect the parent fields from all the patterns.
For example:
    <TICK>
    pattern: "projects/{project}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "folders/{folder}/locations/{location}/quotaPreferences/{quota_preference}"
    pattern: "organizations/{organization}/locations/{location}/quotaPreferences/{quota_preference}"
    <TICK>
the Parent struct should be:
type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef"<TICK>
}
If the "pattern" fields in the <TICK>message ${PROTO_RESOURCE}<TICK> have 4 or more levels , pick the last level as the Parent field and ignore the rest.
For example:
    <TICK>
    pattern: "project/{project}/locations/{location}/someParentResource/{some_parent_resource}/someResource/{some_resource}"
    <TICK>
the Parent struct should be:
type Parent struct {
	// +required
	SomeParentResourceRef *SomeParentResourceRef <TICK>json:"someParentResourceRef"<TICK>
}
3. refv1beta1 package comes from "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
4. Please make sure there is only one import block in the ${RESOURCE_TYPES_FILE} file and it appears at the beginning of the file.

Hints:
1. If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${RESOURCE_TYPES_FILE} file.
2. Alternatively use EditFile tool to change the contents of the ${RESOURCE_TYPES_FILE} file.

Files referenced in this prompt:
${GENERATED_TYPES_FILE}
${RESOURCE_TYPES_FILE}
${PROTO_FILES}
`

func setTypeParent(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, SET_TYPE_PARENT)
	if err != nil {
		return nil, nil, err
	}
	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Set parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

func regenerateTypes(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", strings.ToLower(branch.Resource)))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	// Regenerate types
	cfg := CommandConfig{
		Name: "Regenerate types",
		Cmd:  "go",
		Args: []string{
			"run", ".",
			"generate-types",
			"--service", branch.Package,
			"--api-version", fmt.Sprintf("%s.cnrm.cloud.google.com/v1alpha1", branch.Group),
			"--resource", fmt.Sprintf("%s:%s", branch.Kind, branch.Proto),
		},
		WorkDir:     filepath.Join(opts.branchRepoDir, "dev", "tools", "controllerbuilder"),
		MaxAttempts: 1,
	}
	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath, generatedTypesPath}, &results, err
}

const ADJUST_IDENTITY_PARENT string = `I want you to update the ${PROTO_RESOURCE}Parent struct in the ${IDENTITY_FILE} file along with the String() method and the Parse${PROTO_RESOURCE}External method.
Step 1: Changing the ${PROTO_RESOURCE}Parent struct:
Inspect the Parent structs in the ${RESOURCE_TYPES_FILE} file to determine the fields for the ${PROTO_RESOURCE}Parent struct.
   For example, if the ${RESOURCE_TYPES_FILE} file has the following Parent structs:
type Parent struct {
	Location string <TICK>json:"location"<TICK>
	// +optional
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef,omitempty"<TICK>
	// +optional
	FolderRef *refv1beta1.FolderRef <TICK>json:"folderRef,omitempty"<TICK>
	// +optional
	OrganizationRef *refv1beta1.OrganizationRef <TICK>json:"organizationRef,omitempty"<TICK>
}
   we need to generate the following ${PROTO_RESOURCE}Parent struct:
type ${PROTO_RESOURCE}Parent struct {
	ProjectID      string
	OrganizationID string
	FolderID       string
	Location       string
}
If the ${RESOURCE_TYPES_FILE} file has the following Parent struct:
type Parent struct {
	// +required
	Location string <TICK>json:"location"<TICK>
	// +required
	ProjectRef *refv1beta1.ProjectRef <TICK>json:"projectRef,omitempty"<TICK>
	// +required
	SomeGroup *refv1beta1.SomeGroup <TICK>json:"someGroupRef,omitempty"<TICK>
}
   we need to generate the following ${PROTO_RESOURCE}Parent struct:
type ${PROTO_RESOURCE}Parent struct {
	ProjectID      string
	Location       string
	SomeGroupID    string
}

Step 2: Changing the ${PROTO_RESOURCE}Parent's String() method:
Please update the ${PROTO_RESOURCE}Parent's String() method to return the correct string.
Please inspect the <TICK>message ${PROTO_RESOURCE}<TICK>'s pattern fields to determine the correct pattern.

Step 3: Changing the Parse${PROTO_RESOURCE}External method:
Please update the Parse${PROTO_RESOURCE}External method to parse the ${PROTO_RESOURCE}Parent from a string.

Step 4: Updating the New${PROTO_RESOURCE}Identity method:
Please update the New${PROTO_RESOURCE}Identity method to use the new ${PROTO_RESOURCE}Parent struct.

Step 5: Update the resource camelCase name in URLs:
Please update the resource camelCase name in URLs.
Refer to the <TICK>message ${PROTO_RESOURCE}<TICK>'s pattern fields to determine the correct camelCase name.

If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${IDENTITY_FILE} file.
Alternatively use EditFile tool to change the contents of the ${IDENTITY_FILE}.
If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the ${PROTO_RESOURCE}Parent struct stating that no changes were needed.
Please do not modify the ${RESOURCE_TYPES_FILE} file.
Please ignore the compilation errors due to missing DeepCopy methods

Make sure to use either CreateFile or EditFile tool.

Once the file is updated, please ReadFile the ${IDENTITY_FILE} file to verify all the changes have been made.

Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILE}:
${RESOURCE_TYPES_FILE_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func adjustIdentityParent(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, ADJUST_IDENTITY_PARENT)
	if err != nil {
		return nil, nil, err
	}
	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{identityPath}, &results, err
}

const ADJUST_IDENTITY_PARENT_NEW_FUNCTION string = `I want you to update the New${PROTO_RESOURCE}Identity method in the ${IDENTITY_FILE} file.
if the ${PROTO_RESOURCE}Parent struct has a Name field, please remove it.
Main Objectives:
1. Modify the New${PROTO_RESOURCE}Identity method in ${IDENTITY_FILE}.
2. Please do not modify the ${RESOURCE_TYPES_FILE} file.
4. Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

Rules for modifying the New${PROTO_RESOURCE}Identity method:
1. The New${PROTO_RESOURCE}Identity method should be updated to resolve the fields of the ${PROTO_RESOURCE}Parent.
2. The fields of the ${PROTO_RESOURCE}Parent are resolved from the Parent fields in the ${RESOURCE_TYPES_FILE} file.
3. An example resolution of the ${PROTO_RESOURCE}Parent fields is:
	// Get Parent
	projectRef, err := refsv1beta1.ResolveProject(ctx, reader, obj.GetNamespace(), obj.Spec.ProjectRef)
	if err != nil {
		return nil, err
	}
4. Make sure that all fields of the ${PROTO_RESOURCE}Parent are resolved.
5. Make sure all the fields of ${PROTO_RESOURCE}Parent are set in the return value.
6. Please do not modify the ${RESOURCE_TYPES_FILE} file.
7.  Please update the ${IDENTITY_FILE} file with the modified method New${PROTO_RESOURCE}Identity.

If no changes are needed, please add a comment in the ${IDENTITY_FILE} file before the New${PROTO_RESOURCE}Identity method stating that no changes were needed.

Contents of ${IDENTITY_FILE}:
${IDENTITY_FILE_CONTENTS}

Contents of ${RESOURCE_TYPES_FILE}:
${RESOURCE_TYPES_FILE_CONTENTS}
`

func adjustIdentityParentNewFunction(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, ADJUST_IDENTITY_PARENT_NEW_FUNCTION)
	if err != nil {
		return nil, nil, err
	}
	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Adjust identity parent new function",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{identityPath}, &results, err
}

const REMOVE_NAME_FIELD string = `I want you to update the ${KIND}Spec struct in the ${RESOURCE_TYPES_FILE} file.

If the ${KIND}Spec struct does not have a <TICK>Name<TICK> field, dont do anything.
Do not remove the <TICK>ResourceID<TICK> field.

If the ${KIND}Spec struct has a <TICK>Name<TICK> field, we need to remove the Name field along with the comments from the ${KIND}Spec struct if:
2. The <TICK>name<TICK> field is not marked as <TICK>REQUIRED<TICK> in the <TICK>message ${PROTO_RESOURCE}<TICK> proto message.
3. The <TICK>name<TICK> field is marked as <TICK>IDENTIFIER<TICK> in the <TICK>message ${PROTO_RESOURCE}<TICK> proto message.

If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${RESOURCE_TYPES_FILE} file.
Alternatively use EditFile tool to change the contents of the ${RESOURCE_TYPES_FILE}.
Please do not modify the ${GENERATED_TYPES_FILE} file.
Please ignore the compilation errors due to missing DeepCopy methods

Make sure to use either CreateFile or EditFile tool.

Contents of ${RESOURCE_TYPES_FILE}:
${RESOURCE_TYPES_FILE_CONTENTS}

Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func removeNameField(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, REMOVE_NAME_FIELD)
	if err != nil {
		return nil, nil, err
	}
	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Remove Name Field",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

const MOVE_ETAG_FIELD string = `I want you to update the the ${RESOURCE_TYPES_FILE} file.
If the ${KIND}Spec struct does not have a <TICK>Etag<TICK> field, dont do anything.
Dont add an Etag field to the Status or the ObservedState struct if it does not exist in the ${KIND}Spec struct.

If the ${KIND}Spec struct has a <TICK>Etag<TICK> field, we need to move the Etag field along with the comments from the ${KIND}Spec struct to:
1. The ${PROTO_RESOURCE}ObservedState struct if it exists.
2. The ${KIND}Status struct if the ${PROTO_RESOURCE}ObservedState struct does not exist.

Make sure to move the comments along with the Etag field.

If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${RESOURCE_TYPES_FILE} file.
Alternatively use EditFile tool to change the contents of the ${RESOURCE_TYPES_FILE}.
Please do not modify the ${GENERATED_TYPES_FILE} file.
Please ignore the compilation errors due to missing DeepCopy methods

Make sure to use either CreateFile or EditFile tool.

Contents of ${RESOURCE_TYPES_FILE}:
${RESOURCE_TYPES_FILE_CONTENTS}
`

func moveEtagField(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, MOVE_ETAG_FIELD)
	if err != nil {
		return nil, nil, err
	}

	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Move Etag Field",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath}, &results, err
}

const ADD_REQUIRED_FIELD_TAGS string = `
I want you to update the ${RESOURCE_TYPES_FILE} and ${GENERATED_TYPES_FILE} files.

Start by looking at all the fields in ${RESOURCE_TYPES_FILE} and ${GENERATED_TYPES_FILE} files.
For the fields we need to add the <TICK>//+required<TICK> comment at the top of a field if:
1. The field has a comment <TICK>//Required<TICK>
2. The Proto field marked by <TICK>// +kcc:proto:field=<proto field path><TICK> is marked as <TICK>REQUIRED<TICK> in its proto message.

Make sure to not duplicate existing fields.
No need to duplicate the comments from the proto file or the comments from the field.

Only make changes if needed in the ${RESOURCE_TYPES_FILE} file and ${GENERATED_TYPES_FILE} file.
Please do not modify any other files.

Hints:
1. If you generate the whole file, use CreateFile tool with overwrite set to true to write back the contents of the ${RESOURCE_TYPES_FILE} file.
2. Alternatively use EditFile tool to change the contents of the ${RESOURCE_TYPES_FILE} file.
3. Use ReadFile tool to read contents of the ${RESOURCE_TYPES_FILE} and ${GENERATED_TYPES_FILE} files.

Files referenced in this prompt:
${GENERATED_TYPES_FILE}
${RESOURCE_TYPES_FILE}
${PROTO_FILES}


Contents of ${PROTO_FILES}:
${PROTO_FILES_CONTENTS}
`

func addRequiredFieldTags(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	resourceLower := strings.ToLower(branch.Resource)
	resourceTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	// Prepare prompt using the helper function
	prompt, err := prepareCodebotPrompt(opts, branch, ADD_REQUIRED_FIELD_TAGS)
	if err != nil {
		return nil, nil, err
	}
	// Run codebot to adjust types
	cfg := CommandConfig{
		Name:         "Add Required Field Tags",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{resourceTypesPath, generatedTypesPath}, &results, err
}

// runAPIChecks runs the API checks for a branch and updates the exceptions file if needed
func runAPIChecks(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	log.Printf("Running API checks for branch %s", branch.Name)

	// Define affected paths that might be modified
	affectedPaths := []string{
		filepath.Join("tests", "apichecks", "testdata", "exceptions"),
	}

	// Run the API checks command
	cfg := CommandConfig{
		Name: "API Checks",
		Cmd:  "go",
		Args: []string{
			"test", "-v", filepath.Join("tests", "apichecks", "crds_test.go"),
		},
		WorkDir:     opts.branchRepoDir,
		Env:         map[string]string{"WRITE_GOLDEN_OUTPUT": "1"},
		MaxAttempts: 1,
	}

	results, err := executeCommand(opts, cfg)
	return affectedPaths, &results, err
}

const FIX_API_CHECK_FAILURES string = `I need your help fixing API check failures for the ${KIND} resource.
The API checker has identified some issues that need to be fixed.

Here's the output from the API check test:

${TEST_OUTPUT}

Focus on the additions (lines starting with '+') in the output. These indicate issues that need to be fixed.
Ignore the lines starting with '-' as they are not relevant.

Please help me fix these issues by inspecting and modifying the affected files in the codebase.

Files that may need to be modified:
- apis/${GROUP}/v1alpha1/${RESOURCE_LOWER}_types.go - Contains the resource type definitions
- apis/${GROUP}/v1alpha1/types.generated.go - Contains the generated resource type definitions
- apis/${GROUP}/v1alpha1/${RESOURCE_LOWER}_identity.go - Contains the identity definition for the resource
- pkg/controller/direct/${GROUP}/mapper.generated.go - Contains the mapper for the resource

If the types file is modified, please re-generate the CRD running the script:
./dev/tasks/generate-crds

If the types.generated.go file is modified, please move the modified type to ${RESOURCE_LOWER}_types.go file.

Here are the contents of these files:

TYPES FILE:
${TYPES_FILE_CONTENTS}

IDENTITY FILE:
${IDENTITY_FILE_CONTENTS}

MAPPER FILE:
${MAPPER_FILE_CONTENTS}

GENERATED TYPES FILE:
${GENERATED_TYPES_FILE_CONTENTS}

Please make the necessary changes to fix all the API check issues. Focus on fixing the specific issues mentioned in the test output.
`

// fixAPICheckFailures attempts to fix API check issues based on the test output
func fixAPICheckFailures(ctx context.Context, opts *RunnerOptions, branch Branch, execResults *ExecResults) ([]string, *ExecResults, error) {
	log.Printf("Fixing API check failures for branch %s", branch.Name)

	// Get additions from the test output
	additions, removals := extractAdditionsAndRemovals(execResults.Stdout, execResults.Stderr)
	if removals == "" {
		log.Printf("No removals found in API check output")
	}

	// nothing to fix if no additions
	if additions == "" {
		log.Printf("No additions found in API check output")
		return nil, nil, nil
	}

	// Create paths to resource files
	resourceLower := strings.ToLower(branch.Resource)
	typesPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower))
	generatedTypesPath := filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go")
	identityPath := filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", resourceLower))
	mapperPath := filepath.Join("pkg", "controller", "direct", branch.Group, "mapper.generated.go")

	// Read file contents
	typesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, typesPath))
	if err != nil {
		log.Printf("Error reading types file: %v", err)
		typesContent = []byte("File not found")
	}

	identityContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, identityPath))
	if err != nil {
		log.Printf("Error reading identity file: %v", err)
		identityContent = []byte("File not found")
	}

	mapperContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, mapperPath))
	if err != nil {
		log.Printf("Error reading mapper file: %v", err)
		mapperContent = []byte("File not found")
	}

	generatedTypesContent, err := os.ReadFile(filepath.Join(opts.branchRepoDir, generatedTypesPath))
	if err != nil {
		log.Printf("Error reading generated types file: %v", err)
		generatedTypesContent = []byte("File not found")
	}

	// Create prompt with file contents and test output
	prompt := strings.ReplaceAll(FIX_API_CHECK_FAILURES, "${TEST_OUTPUT}", additions)
	prompt = strings.ReplaceAll(prompt, "${GROUP}", branch.Group)
	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_LOWER}", resourceLower)
	prompt = strings.ReplaceAll(prompt, "${TYPES_FILE_CONTENTS}", string(typesContent))
	prompt = strings.ReplaceAll(prompt, "${IDENTITY_FILE_CONTENTS}", string(identityContent))
	prompt = strings.ReplaceAll(prompt, "${MAPPER_FILE_CONTENTS}", string(mapperContent))
	prompt = strings.ReplaceAll(prompt, "${GENERATED_TYPES_FILE_CONTENTS}", string(generatedTypesContent))
	// Run codebot to fix the issues
	cfg := CommandConfig{
		Name:         "Fix API Check Failures",
		Cmd:          "codebot",
		Args:         []string{"--prompt=/dev/stdin"},
		Stdin:        strings.NewReader(prompt),
		WorkDir:      opts.branchRepoDir,
		RetryBackoff: GenerativeCommandRetryBackoff,
	}

	results, err := executeCommand(opts, cfg)
	return []string{typesPath, identityPath, mapperPath}, &results, err
}

// extractAdditionsAndRemovals extracts the lines starting with '+' or '-' from the API check output
// and returns them separately as two strings - one for additions and one for removals
func extractAdditionsAndRemovals(stdout, stderr string) (string, string) {
	output := stdout + "\n" + stderr
	lines := strings.Split(output, "\n")
	var additions strings.Builder
	var removals strings.Builder
	// Look for lines containing "missingrefs.txt" to locate the start of diff
	for _, line := range lines {
		// Look for lines starting with + after removing whitespace
		lineTrimmed := strings.TrimSpace(line)
		if strings.HasPrefix(lineTrimmed, "+") {
			log.Printf("additions: %s", lineTrimmed)
			additions.WriteString(lineTrimmed + "\n")
		}
		if strings.HasPrefix(lineTrimmed, "-") {
			log.Printf("removals: %s", lineTrimmed)
			removals.WriteString(lineTrimmed + "\n")
		}
	}

	return additions.String(), removals.String()
}

// prepareCodebotPrompt prepares a prompt for codebot by reading files and replacing placeholders
func prepareCodebotPrompt(opts *RunnerOptions, branch Branch, promptTemplate string) (string, error) {
	// Create a map to store file contents
	fileContents := make(map[string]string)

	resourceLower := strings.ToLower(branch.Resource)

	pathMap := map[string]string{
		"RESOURCE_TYPES_FILE":  filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_types.go", resourceLower)),
		"GENERATED_TYPES_FILE": filepath.Join("apis", branch.Group, "v1alpha1", "types.generated.go"),
		"IDENTITY_FILE":        filepath.Join("apis", branch.Group, "v1alpha1", fmt.Sprintf("%s_identity.go", resourceLower)),
		"MAPPER_FILE":          filepath.Join("pkg", "controller", "direct", branch.Group, "mapper.generated.go"),
	}
	// Read contents of specified files
	for placeholder, path := range pathMap {
		if path == "" {
			continue
		}

		content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, path))
		if err != nil {
			// For non-critical files, continue with empty content
			if strings.Contains(err.Error(), "no such file or directory") {
				fileContents[placeholder] = "File not found"
				continue
			}
			return "", fmt.Errorf("failed to read %s file: %w", placeholder, err)
		}
		fileContents[placeholder] = string(content)
	}

	// Read proto files if ProtoPath is provided
	var protoContents strings.Builder
	var protoFileRelativePaths []string

	if branch.ProtoPath != "" {
		protoDirRelative := filepath.Dir(filepath.Join(".build", "third_party", "googleapis", branch.ProtoPath))

		protoFiles, err := os.ReadDir(filepath.Join(opts.branchRepoDir, protoDirRelative))
		if err != nil {
			return "", fmt.Errorf("failed to read proto directory: %w", err)
		}

		for _, file := range protoFiles {
			if !file.IsDir() && strings.HasSuffix(file.Name(), ".proto") {
				filePathRelative := filepath.Join(protoDirRelative, file.Name())
				protoFileRelativePaths = append(protoFileRelativePaths, filePathRelative)

				content, err := os.ReadFile(filepath.Join(opts.branchRepoDir, filePathRelative))
				if err != nil {
					return "", fmt.Errorf("failed to read proto file %s: %w", filePathRelative, err)
				}
				protoContents.WriteString("-------------------------------------------\n")
				protoContents.WriteString("File name: " + filePathRelative + "\n")
				protoContents.WriteString("Contents: \n")
				protoContents.Write(content)
				protoContents.WriteString("\n-------------------------------------------\n")
			}
		}
	}

	// Replace file path placeholders
	prompt := promptTemplate
	for placeholder, path := range pathMap {
		pathPlaceholder := fmt.Sprintf("${%s}", placeholder)
		prompt = strings.ReplaceAll(prompt, pathPlaceholder, path)
	}

	// Replace file content placeholders
	for placeholder, content := range fileContents {
		contentPlaceholder := fmt.Sprintf("${%s_CONTENTS}", placeholder)
		prompt = strings.ReplaceAll(prompt, contentPlaceholder, content)
	}

	// Replace proto files placeholders
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES}", strings.Join(protoFileRelativePaths, "\n"))
	prompt = strings.ReplaceAll(prompt, "${PROTO_FILES_CONTENTS}", protoContents.String())

	// Replace other common placeholders
	prompt = strings.ReplaceAll(prompt, "${KIND}", branch.Kind)
	prompt = strings.ReplaceAll(prompt, "${GROUP}", branch.Group)
	prompt = strings.ReplaceAll(prompt, "${RESOURCE}", branch.Resource)
	prompt = strings.ReplaceAll(prompt, "${RESOURCE_LOWER}", strings.ToLower(branch.Resource))
	prompt = strings.ReplaceAll(prompt, "${PROTO_RESOURCE}", branch.Proto)
	prompt = strings.ReplaceAll(prompt, "${PROTO_MESSAGE}", branch.ProtoMsg)
	prompt = strings.ReplaceAll(prompt, "${PROTO_SERVICE}", branch.ProtoSvc)

	// Replace multiple newlines with single newline
	prompt = regexp.MustCompile(`\n{2,}`).ReplaceAllString(prompt, "\n")
	return prompt, nil
}
