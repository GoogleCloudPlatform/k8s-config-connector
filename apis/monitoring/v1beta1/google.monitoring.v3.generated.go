// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1beta1

// +kcc:proto=google.monitoring.v3.AlertPolicy.Documentation
type AlertPolicy_Documentation struct {
	// The body of the documentation, interpreted according to `mime_type`.
	//  The content may not exceed 8,192 Unicode characters and may not exceed
	//  more than 10,240 bytes when encoded in UTF-8 format, whichever is
	//  smaller. This text can be [templatized by using
	//  variables](https://cloud.google.com/monitoring/alerts/doc-variables).
	Content *string `json:"content,omitempty"`

	// The format of the `content` field. Presently, only the value
	//  `"text/markdown"` is supported. See
	//  [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
	MimeType *string `json:"mimeType,omitempty"`

	// Optional. The subject line of the notification. The subject line may not
	//  exceed 10,240 bytes. In notifications generated by this policy, the
	//  contents of the subject line after variable expansion will be truncated
	//  to 255 bytes or shorter at the latest UTF-8 character boundary. The
	//  255-byte limit is recommended by [this
	//  thread](https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit).
	//  It is both the limit imposed by some third-party ticketing products and
	//  it is common to define textual fields in databases as VARCHAR(255).
	//
	//  The contents of the subject line can be [templatized by using
	//  variables](https://cloud.google.com/monitoring/alerts/doc-variables).
	//  If this field is missing or empty, a default subject line will be
	//  generated.
	Subject *string `json:"subject,omitempty"`

	// Optional. Links to content such as playbooks, repositories, and other
	//  resources. This field can contain up to 3 entries.
	Links []AlertPolicy_Documentation_Link `json:"links,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Documentation.Link
type AlertPolicy_Documentation_Link struct {
	// A short display name for the link. The display name must not be empty
	//  or exceed 63 characters. Example: "playbook".
	DisplayName *string `json:"displayName,omitempty"`

	// The url of a webpage.
	//  A url can be templatized by using variables
	//  in the path or the query parameters. The total length of a URL should
	//  not exceed 2083 characters before and after variable expansion.
	//  Example: "https://my_domain.com/playbook?name=${resource.name}"
	Url *string `json:"url,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition
type AlertPolicy_Condition struct {
	// Required if the condition exists. The unique resource name for this
	//  condition. Its format is:
	//
	//      projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
	//
	//  `[CONDITION_ID]` is assigned by Cloud Monitoring when the
	//  condition is created as part of a new or updated alerting policy.
	//
	//  When calling the
	//  [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
	//  method, do not include the `name` field in the conditions of the
	//  requested alerting policy. Cloud Monitoring creates the
	//  condition identifiers and includes them in the new policy.
	//
	//  When calling the
	//  [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
	//  method to update a policy, including a condition `name` causes the
	//  existing condition to be updated. Conditions without names are added to
	//  the updated policy. Existing conditions are deleted if they are not
	//  updated.
	//
	//  Best practice is to preserve `[CONDITION_ID]` if you make only small
	//  changes, such as those to condition thresholds, durations, or trigger
	//  values.  Otherwise, treat the change as a new condition and let the
	//  existing condition be deleted.
	Name *string `json:"name,omitempty"`

	// A short name or phrase used to identify the condition in dashboards,
	//  notifications, and incidents. To avoid confusion, don't use the same
	//  display name for multiple conditions in the same policy.
	DisplayName *string `json:"displayName,omitempty"`

	// A condition that compares a time series against a threshold.
	ConditionThreshold *AlertPolicy_Condition_MetricThreshold `json:"conditionThreshold,omitempty"`

	// A condition that checks that a time series continues to
	//  receive new data points.
	ConditionAbsent *AlertPolicy_Condition_MetricAbsence `json:"conditionAbsent,omitempty"`

	// A condition that checks for log messages matching given constraints. If
	//  set, no other conditions can be present.
	ConditionMatchedLog *AlertPolicy_Condition_LogMatch `json:"conditionMatchedLog,omitempty"`

	// A condition that uses the Monitoring Query Language to define
	//  alerts.
	ConditionMonitoringQueryLanguage *AlertPolicy_Condition_MonitoringQueryLanguageCondition `json:"conditionMonitoringQueryLanguage,omitempty"`

	// A condition that uses the Prometheus query language to define alerts.
	ConditionPrometheusQueryLanguage *AlertPolicy_Condition_PrometheusQueryLanguageCondition `json:"conditionPrometheusQueryLanguage,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.Trigger
type AlertPolicy_Condition_Trigger struct {
	// The absolute number of time series that must fail
	//  the predicate for the condition to be triggered.
	Count *int32 `json:"count,omitempty"`

	// The percentage of time series that must fail the
	//  predicate for the condition to be triggered.
	Percent *float64 `json:"percent,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold
type AlertPolicy_Condition_MetricThreshold struct {
	// Required. A
	//  [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies which time series should be compared with the threshold.
	//
	//  The filter is similar to the one that is specified in the
	//  [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
	//  (that call is useful to verify the time series that will be retrieved /
	//  processed). The filter must specify the metric type and the resource
	//  type. Optionally, it can specify resource labels and metric labels.
	//  This field must not exceed 2048 Unicode characters in length.
	Filter *string `json:"filter,omitempty"`

	// Specifies the alignment of data points in individual time series as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources). Multiple aggregations
	//  are applied in the order specified.
	//
	//  This field is similar to the one in the [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
	//  It is advisable to use the `ListTimeSeries` method when debugging this
	//  field.
	Aggregations []Aggregation `json:"aggregations,omitempty"`

	// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies a time series that should be used as the denominator of a
	//  ratio that will be compared with the threshold. If a
	//  `denominator_filter` is specified, the time series specified by the
	//  `filter` field will be used as the numerator.
	//
	//  The filter must specify the metric type and optionally may contain
	//  restrictions on resource type, resource labels, and metric labels.
	//  This field may not exceed 2048 Unicode characters in length.
	DenominatorFilter *string `json:"denominatorFilter,omitempty"`

	// Specifies the alignment of data points in individual time series
	//  selected by `denominatorFilter` as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources).
	//
	//  When computing ratios, the `aggregations` and
	//  `denominator_aggregations` fields must use the same alignment period
	//  and produce time series that have the same periodicity and labels.
	DenominatorAggregations []Aggregation `json:"denominatorAggregations,omitempty"`

	// When this field is present, the `MetricThreshold` condition forecasts
	//  whether the time series is predicted to violate the threshold within
	//  the `forecast_horizon`. When this field is not set, the
	//  `MetricThreshold` tests the current value of the timeseries against the
	//  threshold.
	ForecastOptions *AlertPolicy_Condition_MetricThreshold_ForecastOptions `json:"forecastOptions,omitempty"`

	// The comparison to apply between the time series (indicated by `filter`
	//  and `aggregation`) and the threshold (indicated by `threshold_value`).
	//  The comparison is applied on each time series, with the time series
	//  on the left-hand side and the threshold on the right-hand side.
	//
	//  Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
	Comparison *string `json:"comparison,omitempty"`

	// A value against which to compare the time series.
	ThresholdValue *float64 `json:"thresholdValue,omitempty"`

	// The amount of time that a time series must violate the
	//  threshold to be considered failing. Currently, only values
	//  that are a multiple of a minute--e.g., 0, 60, 120, or 300
	//  seconds--are supported. If an invalid value is given, an
	//  error will be returned. When choosing a duration, it is useful to
	//  keep in mind the frequency of the underlying time series data
	//  (which may also be affected by any alignments specified in the
	//  `aggregations` field); a good duration is long enough so that a single
	//  outlier does not generate spurious alerts, but short enough that
	//  unhealthy states are detected and alerted on quickly.
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`,
	//  or by the ratio, if `denominator_filter` and `denominator_aggregations`
	//  are specified.
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`

	// A condition control that determines how metric-threshold conditions
	//  are evaluated when data stops arriving. To use this control, the value
	//  of the `duration` field must be greater than or equal to 60 seconds.
	EvaluationMissingData *string `json:"evaluationMissingData,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricThreshold.ForecastOptions
type AlertPolicy_Condition_MetricThreshold_ForecastOptions struct {
	// Required. The length of time into the future to forecast whether a
	//  time series will violate the threshold. If the predicted value is
	//  found to violate the threshold, and the violation is observed in all
	//  forecasts made for the configured `duration`, then the time series is
	//  considered to be failing.
	//  The forecast horizon can range from 1 hour to 60 hours.
	ForecastHorizon *string `json:"forecastHorizon,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MetricAbsence
type AlertPolicy_Condition_MetricAbsence struct {
	// Required. A
	//  [filter](https://cloud.google.com/monitoring/api/v3/filters) that
	//  identifies which time series should be compared with the threshold.
	//
	//  The filter is similar to the one that is specified in the
	//  [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
	//  (that call is useful to verify the time series that will be retrieved /
	//  processed). The filter must specify the metric type and the resource
	//  type. Optionally, it can specify resource labels and metric labels.
	//  This field must not exceed 2048 Unicode characters in length.
	Filter *string `json:"filter,omitempty"`

	// Specifies the alignment of data points in individual time series as
	//  well as how to combine the retrieved time series together (such as
	//  when aggregating multiple streams on each resource to a single
	//  stream for each resource or when aggregating streams across all
	//  members of a group of resources). Multiple aggregations
	//  are applied in the order specified.
	//
	//  This field is similar to the one in the [`ListTimeSeries`
	//  request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
	//  It is advisable to use the `ListTimeSeries` method when debugging this
	//  field.
	Aggregations []Aggregation `json:"aggregations,omitempty"`

	// The amount of time that a time series must fail to report new
	//  data to be considered failing. The minimum value of this field
	//  is 120 seconds. Larger values that are a multiple of a
	//  minute--for example, 240 or 300 seconds--are supported.
	//  If an invalid value is given, an
	//  error will be returned. The `Duration.nanos` field is
	//  ignored.
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`.
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.LogMatch
type AlertPolicy_Condition_LogMatch struct {
	// Required. A logs-based filter. See [Advanced Logs
	//  Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
	//  for how this filter should be constructed.
	Filter *string `json:"filter,omitempty"`

	// Optional. A map from a label key to an extractor expression, which is
	//  used to extract the value for this label key. Each entry in this map is
	//  a specification for how data should be extracted from log entries that
	//  match `filter`. Each combination of extracted values is treated as a
	//  separate rule for the purposes of triggering notifications. Label keys
	//  and corresponding values can be used in notifications generated by this
	//  condition.
	//
	//  Please see [the documentation on logs-based metric
	//  `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
	//  for syntax and examples.
	LabelExtractors map[string]string `json:"labelExtractors,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.MonitoringQueryLanguageCondition
type AlertPolicy_Condition_MonitoringQueryLanguageCondition struct {
	// [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
	//  query that outputs a boolean stream.
	Query *string `json:"query,omitempty"`

	// The amount of time that a time series must violate the
	//  threshold to be considered failing. Currently, only values
	//  that are a multiple of a minute--e.g., 0, 60, 120, or 300
	//  seconds--are supported. If an invalid value is given, an
	//  error will be returned. When choosing a duration, it is useful to
	//  keep in mind the frequency of the underlying time series data
	//  (which may also be affected by any alignments specified in the
	//  `aggregations` field); a good duration is long enough so that a single
	//  outlier does not generate spurious alerts, but short enough that
	//  unhealthy states are detected and alerted on quickly.
	Duration *string `json:"duration,omitempty"`

	// The number/percent of time series for which the comparison must hold
	//  in order for the condition to trigger. If unspecified, then the
	//  condition will trigger if the comparison is true for any of the
	//  time series that have been identified by `filter` and `aggregations`,
	//  or by the ratio, if `denominator_filter` and `denominator_aggregations`
	//  are specified.
	Trigger *AlertPolicy_Condition_Trigger `json:"trigger,omitempty"`

	// A condition control that determines how metric-threshold conditions
	//  are evaluated when data stops arriving.
	EvaluationMissingData *string `json:"evaluationMissingData,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.Condition.PrometheusQueryLanguageCondition
type AlertPolicy_Condition_PrometheusQueryLanguageCondition struct {
	// Required. The PromQL expression to evaluate. Every evaluation cycle
	//  this expression is evaluated at the current time, and all resultant
	//  time series become pending/firing alerts. This field must not be empty.
	Query *string `json:"query,omitempty"`

	// Optional. Alerts are considered firing once their PromQL expression was
	//  evaluated to be "true" for this long.
	//  Alerts whose PromQL expression was not evaluated to be "true" for
	//  long enough are considered pending.
	//  Must be a non-negative duration or missing.
	//  This field is optional. Its default value is zero.
	Duration *string `json:"duration,omitempty"`

	// Optional. How often this rule should be evaluated.
	//  Must be a positive multiple of 30 seconds or missing.
	//  This field is optional. Its default value is 30 seconds.
	//  If this PrometheusQueryLanguageCondition was generated from a
	//  Prometheus alerting rule, then this value should be taken from the
	//  enclosing rule group.
	EvaluationInterval *string `json:"evaluationInterval,omitempty"`

	// Optional. Labels to add to or overwrite in the PromQL query result.
	//  Label names [must be
	//  valid](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
	//  Label values can be [templatized by using
	//  variables](https://cloud.google.com/monitoring/alerts/doc-variables).
	//  The only available variable names are the names of the labels in the
	//  PromQL result, including "__name__" and "value". "labels" may be empty.
	Labels map[string]string `json:"labels,omitempty"`

	// Optional. The rule group name of this alert in the corresponding
	//  Prometheus configuration file.
	//
	//  Some external tools may require this field to be populated correctly
	//  in order to refer to the original Prometheus configuration file.
	//  The rule group name and the alert name are necessary to update the
	//  relevant AlertPolicies in case the definition of the rule group changes
	//  in the future.
	//
	//  This field is optional. If this field is not empty, then it must
	//  contain a valid UTF-8 string.
	//  This field may not exceed 2048 Unicode characters in length.
	RuleGroup *string `json:"ruleGroup,omitempty"`

	// Optional. The alerting rule name of this alert in the corresponding
	//  Prometheus configuration file.
	//
	//  Some external tools may require this field to be populated correctly
	//  in order to refer to the original Prometheus configuration file.
	//  The rule group name and the alert name are necessary to update the
	//  relevant AlertPolicies in case the definition of the rule group changes
	//  in the future.
	//
	//  This field is optional. If this field is not empty, then it must be a
	//  [valid Prometheus label
	//  name](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
	//  This field may not exceed 2048 Unicode characters in length.
	AlertRule *string `json:"alertRule,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.AlertStrategy
type AlertPolicy_AlertStrategy struct {
	// Required for alert policies with a `LogMatch` condition.
	//
	//  This limit is not implemented for alert policies that are not log-based.
	NotificationRateLimit *AlertPolicy_AlertStrategy_NotificationRateLimit `json:"notificationRateLimit,omitempty"`

	// If an alert policy that was active has no data for this long, any open
	//  incidents will close
	AutoClose *string `json:"autoClose,omitempty"`

	// Control how notifications will be sent out, on a per-channel basis.
	NotificationChannelStrategy []AlertPolicy_AlertStrategy_NotificationChannelStrategy `json:"notificationChannelStrategy,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationRateLimit
type AlertPolicy_AlertStrategy_NotificationRateLimit struct {
	// Not more than one notification per `period`.
	Period *string `json:"period,omitempty"`
}

// +kcc:proto=google.monitoring.v3.AlertPolicy.AlertStrategy.NotificationChannelStrategy
type AlertPolicy_AlertStrategy_NotificationChannelStrategy struct {
	// The full REST resource name for the notification channels that these
	//  settings apply to. Each of these correspond to the name field in one
	//  of the NotificationChannel objects referenced in the
	//  notification_channels field of this AlertPolicy.
	//  The format is:
	//
	//      projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
	NotificationChannelNames []string `json:"notificationChannelNames,omitempty"`

	// The frequency at which to send reminder notifications for open
	//  incidents.
	RenotifyInterval *string `json:"renotifyInterval,omitempty"`
}

// +kcc:proto=google.monitoring.v3.MutationRecord
type MutationRecord struct {
	// When the change occurred.
	MutateTime *string `json:"mutateTime,omitempty"`

	// The email address of the user making the change.
	MutatedBy *string `json:"mutatedBy,omitempty"`
}
