// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1alpha1


// +kcc:proto=google.cloud.baremetalsolution.v2.Network
type Network struct {

	// An identifier for the `Network`, generated by the backend.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.id
	ID *string `json:"id,omitempty"`

	// The type of this network.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.type
	Type *string `json:"type,omitempty"`

	// IP address configured.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.ip_address
	IPAddress *string `json:"ipAddress,omitempty"`

	// List of physical interfaces.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.mac_address
	MacAddress []string `json:"macAddress,omitempty"`

	// The Network state.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.state
	State *string `json:"state,omitempty"`

	// The vlan id of the Network.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.vlan_id
	VlanID *string `json:"vlanID,omitempty"`

	// The cidr of the Network.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.cidr
	Cidr *string `json:"cidr,omitempty"`

	// The vrf for the Network.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.vrf
	Vrf *VRF `json:"vrf,omitempty"`

	// Labels as key value pairs.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.labels
	Labels map[string]string `json:"labels,omitempty"`

	// IP range for reserved for services (e.g. NFS).
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.services_cidr
	ServicesCidr *string `json:"servicesCidr,omitempty"`

	// List of IP address reservations in this network.
	//  When updating this field, an error will be generated if a reservation
	//  conflicts with an IP address already allocated to a physical server.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.reservations
	Reservations []NetworkAddressReservation `json:"reservations,omitempty"`

	// Input only. List of mount points to attach the network to.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.mount_points
	MountPoints []NetworkMountPoint `json:"mountPoints,omitempty"`

	// Whether network uses standard frames or jumbo ones.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.jumbo_frames_enabled
	JumboFramesEnabled *bool `json:"jumboFramesEnabled,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.NetworkAddressReservation
type NetworkAddressReservation struct {
	// The first address of this reservation block.
	//  Must be specified as a single IPv4 address, e.g. 10.1.2.2.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkAddressReservation.start_address
	StartAddress *string `json:"startAddress,omitempty"`

	// The last address of this reservation block, inclusive. I.e., for cases when
	//  reservations are only single addresses, end_address and start_address will
	//  be the same.
	//  Must be specified as a single IPv4 address, e.g. 10.1.2.2.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkAddressReservation.end_address
	EndAddress *string `json:"endAddress,omitempty"`

	// A note about this reservation, intended for human consumption.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkAddressReservation.note
	Note *string `json:"note,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.NetworkMountPoint
type NetworkMountPoint struct {
	// Instance to attach network to.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkMountPoint.instance
	Instance *string `json:"instance,omitempty"`

	// Logical interface to detach from.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkMountPoint.logical_interface
	LogicalInterface *string `json:"logicalInterface,omitempty"`

	// Network should be a default gateway.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkMountPoint.default_gateway
	DefaultGateway *bool `json:"defaultGateway,omitempty"`

	// Ip address of the server.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.NetworkMountPoint.ip_address
	IPAddress *string `json:"ipAddress,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.VRF
type VRF struct {
	// The name of the VRF.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.name
	Name *string `json:"name,omitempty"`

	// The possible state of VRF.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.state
	State *string `json:"state,omitempty"`

	// The QOS policy applied to this VRF.
	//  The value is only meaningful when all the vlan attachments have the same
	//  QoS. This field should not be used for new integrations, use vlan
	//  attachment level qos instead. The field is left for backward-compatibility.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.qos_policy
	QosPolicy *VRF_QosPolicy `json:"qosPolicy,omitempty"`

	// The list of VLAN attachments for the VRF.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.vlan_attachments
	VlanAttachments []VRF_VlanAttachment `json:"vlanAttachments,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.VRF.QosPolicy
type VRF_QosPolicy struct {
	// The bandwidth permitted by the QOS policy, in gbps.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.QosPolicy.bandwidth_gbps
	BandwidthGbps *float64 `json:"bandwidthGbps,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.VRF.VlanAttachment
type VRF_VlanAttachment struct {
	// The peer vlan ID of the attachment.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.peer_vlan_id
	PeerVlanID *int64 `json:"peerVlanID,omitempty"`

	// The peer IP of the attachment.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.peer_ip
	PeerIP *string `json:"peerIP,omitempty"`

	// The router IP of the attachment.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.router_ip
	RouterIP *string `json:"routerIP,omitempty"`

	// Input only. Pairing key.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.pairing_key
	PairingKey *string `json:"pairingKey,omitempty"`

	// The QOS policy applied to this VLAN attachment.
	//  This value should be preferred to using qos at vrf level.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.qos_policy
	QosPolicy *VRF_QosPolicy `json:"qosPolicy,omitempty"`

	// Immutable. The identifier of the attachment within vrf.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.id
	ID *string `json:"id,omitempty"`

	// Optional. The name of the vlan attachment within vrf. This is of the form
	//  projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.VRF.VlanAttachment.interconnect_attachment
	InterconnectAttachment *string `json:"interconnectAttachment,omitempty"`
}

// +kcc:proto=google.cloud.baremetalsolution.v2.Network
type NetworkObservedState struct {
	// Output only. The resource name of this `Network`.
	//  Resource names are schemeless URIs that follow the conventions in
	//  https://cloud.google.com/apis/design/resource_names.
	//  Format:
	//  `projects/{project}/locations/{location}/networks/{network}`
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.name
	Name *string `json:"name,omitempty"`

	// Output only. Pod name.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.pod
	Pod *string `json:"pod,omitempty"`

	// Output only. Gateway ip address.
	// +kcc:proto:field=google.cloud.baremetalsolution.v2.Network.gateway_ip
	GatewayIP *string `json:"gatewayIP,omitempty"`
}
