diff --git a/apis/artifactregistry/v1beta1/doc.go b/apis/artifactregistry/v1beta1/doc.go
new file mode 100644
index 000000000..b9d834107
--- /dev/null
+++ b/apis/artifactregistry/v1beta1/doc.go
@@ -0,0 +1,38 @@
+//go:build ignore
+
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// NOTE: Boilerplate only.  Ignore this file.
+
+// Package v1beta1 contains API Schema definitions for the artifactregistry v1beta1 API group
+// +k8s:deepcopy-gen=package,register
+// +groupName=artifactregistry.cnrm.cloud.google.com
+package v1beta1
+
+import (
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/controller-runtime/pkg/scheme"
+)
+
+var (
+	// GroupVersion is group version used to register these objects
+	GroupVersion = schema.GroupVersion{Group: "artifactregistry.cnrm.cloud.google.com", Version: "v1beta1"}
+
+	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
+	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}
+
+	// AddToScheme adds the types in this group-version to the given scheme.
+	AddToScheme = SchemeBuilder.AddToScheme
+)
diff --git a/apis/artifactregistry/v1beta1/groupversion_info.go b/apis/artifactregistry/v1beta1/groupversion_info.go
new file mode 100644
index 000000000..b5ca76141
--- /dev/null
+++ b/apis/artifactregistry/v1beta1/groupversion_info.go
@@ -0,0 +1,35 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// +kubebuilder:object:generate=true
+// +groupName=artifactregistry.cnrm.cloud.google.com
+package v1beta1
+
+import (
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/controller-runtime/pkg/scheme"
+)
+
+var (
+	// GroupVersion is group version used to register these objects
+	GroupVersion = schema.GroupVersion{Group: "artifactregistry.cnrm.cloud.google.com", Version: "v1beta1"}
+
+	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
+	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}
+
+	// AddToScheme adds the types in this group-version to the given scheme.
+	AddToScheme = SchemeBuilder.AddToScheme
+)
+
+var ArtifactRegistryRepositoryGVK = GroupVersion.WithKind("ArtifactRegistryRepository")
diff --git a/apis/artifactregistry/v1beta1/repository_types.go b/apis/artifactregistry/v1beta1/repository_types.go
new file mode 100644
index 000000000..189b1bcd7
--- /dev/null
+++ b/apis/artifactregistry/v1beta1/repository_types.go
@@ -0,0 +1,312 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1beta1
+
+import (
+	refv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis/k8s/v1alpha1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// CleanupPolicies defines cleanup policies for package versions
+// +kcc:proto=google.devtools.artifactregistry.v1.CleanupPolicy
+type CleanupPolicies struct {
+	/* Policy action. Possible values: ["DELETE", "KEEP"]. */
+	// +optional
+	Action *string `json:"action,omitempty"`
+
+	/* Policy condition for matching versions. */
+	// +optional
+	Condition *CleanupPolicyCondition `json:"condition,omitempty"`
+
+	Id string `json:"id"`
+
+	/* Policy condition for retaining a minimum number of versions. May only be
+	specified with a Keep action. */
+	// +optional
+	MostRecentVersions *CleanupPolicyMostRecentVersions `json:"mostRecentVersions,omitempty"`
+}
+
+// CleanupPolicyCondition defines conditions for cleanup policies
+// +kcc:proto=google.devtools.artifactregistry.v1.CleanupPolicyCondition
+type CleanupPolicyCondition struct {
+	/* Match versions newer than a duration. */
+	// +optional
+	NewerThan *string `json:"newerThan,omitempty"`
+
+	/* Match versions older than a duration. */
+	// +optional
+	OlderThan *string `json:"olderThan,omitempty"`
+
+	/* Match versions by package prefix. Applied on any prefix match. */
+	// +optional
+	PackageNamePrefixes []string `json:"packageNamePrefixes,omitempty"`
+
+	/* Match versions by tag prefix. Applied on any prefix match. */
+	// +optional
+	TagPrefixes []string `json:"tagPrefixes,omitempty"`
+
+	/* Match versions by tag status. Default value: "ANY" Possible values: ["TAGGED", "UNTAGGED", "ANY"]. */
+	// +optional
+	TagState *string `json:"tagState,omitempty"`
+
+	/* Match versions by version name prefix. Applied on any prefix match. */
+	// +optional
+	VersionNamePrefixes []string `json:"versionNamePrefixes,omitempty"`
+}
+
+// CleanupPolicyMostRecentVersions defines policy for retaining recent versions
+// +kcc:proto=google.devtools.artifactregistry.v1.CleanupPolicyMostRecentVersions
+type CleanupPolicyMostRecentVersions struct {
+	/* Minimum number of versions to keep. */
+	// +optional
+	KeepCount *int64 `json:"keepCount,omitempty"`
+
+	/* Match versions by package prefix. Applied on any prefix match. */
+	// +optional
+	PackageNamePrefixes []string `json:"packageNamePrefixes,omitempty"`
+}
+
+// DockerConfig defines Docker repository configuration
+// +kcc:proto=google.devtools.artifactregistry.v1.DockerRepositoryConfig
+type DockerConfig struct {
+	/* The repository which enabled this flag prevents all tags from being modified, moved or deleted. This does not prevent tags from being created. */
+	// +optional
+	ImmutableTags *bool `json:"immutableTags,omitempty"`
+}
+
+// MavenConfig defines Maven repository configuration
+// +kcc:proto=google.devtools.artifactregistry.v1.MavenRepositoryConfig
+type MavenConfig struct {
+	/* Immutable. The repository with this flag will allow publishing the same
+	snapshot versions. */
+	// +optional
+	AllowSnapshotOverwrites *bool `json:"allowSnapshotOverwrites,omitempty"`
+
+	/* Immutable. Version policy defines the versions that the registry will accept. Default value: "VERSION_POLICY_UNSPECIFIED" Possible values: ["VERSION_POLICY_UNSPECIFIED", "RELEASE", "SNAPSHOT"]. */
+	// +optional
+	VersionPolicy *string `json:"versionPolicy,omitempty"`
+}
+
+// DockerRepository defines Docker remote repository settings
+// +kcc:proto=google.devtools.artifactregistry.v1.RemoteRepositoryConfig.DockerRepository
+type DockerRepository struct {
+	/* Immutable. Address of the remote repository. Default value: "DOCKER_HUB" Possible values: ["DOCKER_HUB"]. */
+	// +optional
+	PublicRepository *string `json:"publicRepository,omitempty"`
+}
+
+// MavenRepository defines Maven remote repository settings
+// +kcc:proto=google.devtools.artifactregistry.v1.RemoteRepositoryConfig.MavenRepository
+type MavenRepository struct {
+	/* Immutable. Address of the remote repository. Default value: "MAVEN_CENTRAL" Possible values: ["MAVEN_CENTRAL"]. */
+	// +optional
+	PublicRepository *string `json:"publicRepository,omitempty"`
+}
+
+// NpmRepository defines NPM remote repository settings
+// +kcc:proto=google.devtools.artifactregistry.v1.RemoteRepositoryConfig.NpmRepository
+type NpmRepository struct {
+	/* Immutable. Address of the remote repository. Default value: "NPMJS" Possible values: ["NPMJS"]. */
+	// +optional
+	PublicRepository *string `json:"publicRepository,omitempty"`
+}
+
+// PythonRepository defines Python remote repository settings
+// +kcc:proto=google.devtools.artifactregistry.v1.RemoteRepositoryConfig.PythonRepository
+type PythonRepository struct {
+	/* Immutable. Address of the remote repository. Default value: "PYPI" Possible values: ["PYPI"]. */
+	// +optional
+	PublicRepository *string `json:"publicRepository,omitempty"`
+}
+
+// RemoteRepositoryConfig defines configuration for remote repositories
+// +kcc:proto=google.devtools.artifactregistry.v1.RemoteRepositoryConfig
+type RemoteRepositoryConfig struct {
+	/* Immutable. The description of the remote source. */
+	// +optional
+	Description *string `json:"description,omitempty"`
+
+	/* Immutable. Specific settings for a Docker remote repository. */
+	// +optional
+	DockerRepository *DockerRepository `json:"dockerRepository,omitempty"`
+
+	/* Immutable. Specific settings for a Maven remote repository. */
+	// +optional
+	MavenRepository *MavenRepository `json:"mavenRepository,omitempty"`
+
+	/* Immutable. Specific settings for an Npm remote repository. */
+	// +optional
+	NpmRepository *NpmRepository `json:"npmRepository,omitempty"`
+
+	/* Immutable. Specific settings for a Python remote repository. */
+	// +optional
+	PythonRepository *PythonRepository `json:"pythonRepository,omitempty"`
+}
+
+// UpstreamPolicy defines upstream policies for virtual repositories
+// +kcc:proto=google.devtools.artifactregistry.v1.UpstreamPolicy
+type UpstreamPolicy struct {
+	/* The user-provided ID of the upstream policy. */
+	// +optional
+	Id *string `json:"id,omitempty"`
+
+	/* Entries with a greater priority value take precedence in the pull order. */
+	// +optional
+	Priority *int64 `json:"priority,omitempty"`
+
+	/* A reference to the repository resource, for example:
+	"projects/p1/locations/us-central1/repositories/repo1". */
+	// +optional
+	RepositoryRef *refv1beta1.ArtifactRegistryRepositoryRef `json:"repositoryRef,omitempty"`
+}
+
+// VirtualRepositoryConfig defines configuration for virtual repositories
+// +kcc:proto=google.devtools.artifactregistry.v1.VirtualRepositoryConfig
+type VirtualRepositoryConfig struct {
+	/* Policies that configure the upstream artifacts distributed by the Virtual
+	Repository. Upstream policies cannot be set on a standard repository. */
+	// +optional
+	UpstreamPolicies []UpstreamPolicy `json:"upstreamPolicies,omitempty"`
+}
+
+// ArtifactRegistryRepositorySpec defines the desired state of ArtifactRegistryRepository
+// +kcc:proto=google.devtools.artifactregistry.v1.Repository
+type ArtifactRegistryRepositorySpec struct {
+	/* Cleanup policies for this repository. Cleanup policies indicate when
+	certain package versions can be automatically deleted.
+	Map keys are policy IDs supplied by users during policy creation. They must
+	unique within a repository and be under 128 characters in length. */
+	// +optional
+	CleanupPolicies []CleanupPolicies `json:"cleanupPolicies,omitempty"`
+
+	/* If true, the cleanup pipeline is prevented from deleting versions in this
+	repository. */
+	// +optional
+	CleanupPolicyDryRun *bool `json:"cleanupPolicyDryRun,omitempty"`
+
+	/* The user-provided description of the repository. */
+	// +optional
+	Description *string `json:"description,omitempty"`
+
+	/* Docker repository config contains repository level configuration for the repositories of docker type. */
+	// +optional
+	DockerConfig *DockerConfig `json:"dockerConfig,omitempty"`
+
+	/* Immutable. The format of packages that are stored in the repository. Supported formats
+	can be found [here](https://cloud.google.com/artifact-registry/docs/supported-formats).
+	You can only create alpha formats if you are a member of the
+	[alpha user group](https://cloud.google.com/artifact-registry/docs/supported-formats#alpha-access). */
+	// +required
+	Format string `json:"format"`
+
+	/* The customer managed encryption key that's used to encrypt the
+	contents of the Repository. */
+	// +optional
+	KmsKeyRef *refv1beta1.KMSCryptoKeyRef `json:"kmsKeyRef,omitempty"`
+
+	/* Immutable. The name of the location this repository is located in. */
+	// +required
+	Location string `json:"location"`
+
+	/* MavenRepositoryConfig is maven related repository details.
+	Provides additional configuration details for repositories of the maven
+	format type. */
+	// +optional
+	MavenConfig *MavenConfig `json:"mavenConfig,omitempty"`
+
+	/* Immutable. The mode configures the repository to serve artifacts from different sources. Default value: "STANDARD_REPOSITORY" Possible values: ["STANDARD_REPOSITORY", "VIRTUAL_REPOSITORY", "REMOTE_REPOSITORY"]. */
+	// +optional
+	Mode *string `json:"mode,omitempty"`
+
+	/* Immutable. Configuration specific for a Remote Repository. */
+	// +optional
+	RemoteRepositoryConfig *RemoteRepositoryConfig `json:"remoteRepositoryConfig,omitempty"`
+
+	/* Immutable. Optional. The repositoryId of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default. */
+	// +optional
+	ResourceID *string `json:"resourceID,omitempty"`
+
+	/* Configuration specific for a Virtual Repository. */
+	// +optional
+	VirtualRepositoryConfig *VirtualRepositoryConfig `json:"virtualRepositoryConfig,omitempty"`
+}
+
+// ArtifactRegistryRepositoryStatus defines the config connector machine state of ArtifactRegistryRepository
+type ArtifactRegistryRepositoryStatus struct {
+	/* Conditions represent the latest available observations of the
+	   object's current state. */
+	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
+
+	// ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.
+	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`
+
+	// A unique specifier for the ArtifactRegistryRepository resource in GCP.
+	ExternalRef *string `json:"externalRef,omitempty"`
+
+	// ObservedState is the state of the resource as most recently observed in GCP.
+	ObservedState *ArtifactRegistryRepositoryObservedState `json:"observedState,omitempty"`
+}
+
+// ArtifactRegistryRepositoryObservedState is the state of the ArtifactRegistryRepository resource as most recently observed in GCP.
+// +kcc:proto=google.devtools.artifactregistry.v1.Repository
+type ArtifactRegistryRepositoryObservedState struct {
+	/* The time when the repository was created. */
+	// +optional
+	CreateTime *string `json:"createTime,omitempty"`
+
+	/* The name of the repository, for example:
+	"repo1". */
+	// +optional
+	Name *string `json:"name,omitempty"`
+
+	/* The time when the repository was last updated. */
+	// +optional
+	UpdateTime *string `json:"updateTime,omitempty"`
+}
+
+// +genclient
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+// +kubebuilder:resource:categories=gcp,shortName=gcpartifactregistryrepository;gcpartifactregistryrepositories
+// +kubebuilder:subresource:status
+// +kubebuilder:metadata:labels="cnrm.cloud.google.com/managed-by-kcc=true";"cnrm.cloud.google.com/system=true"
+// +kubebuilder:printcolumn:name="Age",JSONPath=".metadata.creationTimestamp",type="date"
+// +kubebuilder:printcolumn:name="Ready",JSONPath=".status.conditions[?(@.type=='Ready')].status",type="string",description="When 'True', the most recent reconcile of the resource succeeded"
+// +kubebuilder:printcolumn:name="Status",JSONPath=".status.conditions[?(@.type=='Ready')].reason",type="string",description="The reason for the value in 'Ready'"
+// +kubebuilder:printcolumn:name="Status Age",JSONPath=".status.conditions[?(@.type=='Ready')].lastTransitionTime",type="date",description="The last transition time for the value in 'Status'"
+
+// ArtifactRegistryRepository is the Schema for the artifactregistry API
+// +k8s:openapi-gen=true
+// +kubebuilder:storageversion
+type ArtifactRegistryRepository struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	Spec   ArtifactRegistryRepositorySpec   `json:"spec,omitempty"`
+	Status ArtifactRegistryRepositoryStatus `json:"status,omitempty"`
+}
+
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ArtifactRegistryRepositoryList contains a list of ArtifactRegistryRepository
+type ArtifactRegistryRepositoryList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []ArtifactRegistryRepository `json:"items"`
+}
+
+func init() {
+	SchemeBuilder.Register(&ArtifactRegistryRepository{}, &ArtifactRegistryRepositoryList{})
+}
diff --git a/apis/artifactregistry/v1beta1/zz_generated.deepcopy.go b/apis/artifactregistry/v1beta1/zz_generated.deepcopy.go
new file mode 100644
index 000000000..fbf020c55
--- /dev/null
+++ b/apis/artifactregistry/v1beta1/zz_generated.deepcopy.go
@@ -0,0 +1,533 @@
+//go:build !ignore_autogenerated
+
+// Copyright 2020 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by controller-gen. DO NOT EDIT.
+
+package v1beta1
+
+import (
+	refsv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/apis/k8s/v1alpha1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+)
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ArtifactRegistryRepository) DeepCopyInto(out *ArtifactRegistryRepository) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ArtifactRegistryRepository.
+func (in *ArtifactRegistryRepository) DeepCopy() *ArtifactRegistryRepository {
+	if in == nil {
+		return nil
+	}
+	out := new(ArtifactRegistryRepository)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ArtifactRegistryRepository) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ArtifactRegistryRepositoryList) DeepCopyInto(out *ArtifactRegistryRepositoryList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]ArtifactRegistryRepository, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ArtifactRegistryRepositoryList.
+func (in *ArtifactRegistryRepositoryList) DeepCopy() *ArtifactRegistryRepositoryList {
+	if in == nil {
+		return nil
+	}
+	out := new(ArtifactRegistryRepositoryList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ArtifactRegistryRepositoryList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ArtifactRegistryRepositoryObservedState) DeepCopyInto(out *ArtifactRegistryRepositoryObservedState) {
+	*out = *in
+	if in.CreateTime != nil {
+		in, out := &in.CreateTime, &out.CreateTime
+		*out = new(string)
+		**out = **in
+	}
+	if in.Name != nil {
+		in, out := &in.Name, &out.Name
+		*out = new(string)
+		**out = **in
+	}
+	if in.UpdateTime != nil {
+		in, out := &in.UpdateTime, &out.UpdateTime
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ArtifactRegistryRepositoryObservedState.
+func (in *ArtifactRegistryRepositoryObservedState) DeepCopy() *ArtifactRegistryRepositoryObservedState {
+	if in == nil {
+		return nil
+	}
+	out := new(ArtifactRegistryRepositoryObservedState)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ArtifactRegistryRepositorySpec) DeepCopyInto(out *ArtifactRegistryRepositorySpec) {
+	*out = *in
+	if in.CleanupPolicies != nil {
+		in, out := &in.CleanupPolicies, &out.CleanupPolicies
+		*out = make([]CleanupPolicies, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	if in.CleanupPolicyDryRun != nil {
+		in, out := &in.CleanupPolicyDryRun, &out.CleanupPolicyDryRun
+		*out = new(bool)
+		**out = **in
+	}
+	if in.Description != nil {
+		in, out := &in.Description, &out.Description
+		*out = new(string)
+		**out = **in
+	}
+	if in.DockerConfig != nil {
+		in, out := &in.DockerConfig, &out.DockerConfig
+		*out = new(DockerConfig)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.KmsKeyRef != nil {
+		in, out := &in.KmsKeyRef, &out.KmsKeyRef
+		*out = new(refsv1beta1.KMSCryptoKeyRef)
+		**out = **in
+	}
+	if in.MavenConfig != nil {
+		in, out := &in.MavenConfig, &out.MavenConfig
+		*out = new(MavenConfig)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.Mode != nil {
+		in, out := &in.Mode, &out.Mode
+		*out = new(string)
+		**out = **in
+	}
+	if in.RemoteRepositoryConfig != nil {
+		in, out := &in.RemoteRepositoryConfig, &out.RemoteRepositoryConfig
+		*out = new(RemoteRepositoryConfig)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.ResourceID != nil {
+		in, out := &in.ResourceID, &out.ResourceID
+		*out = new(string)
+		**out = **in
+	}
+	if in.VirtualRepositoryConfig != nil {
+		in, out := &in.VirtualRepositoryConfig, &out.VirtualRepositoryConfig
+		*out = new(VirtualRepositoryConfig)
+		(*in).DeepCopyInto(*out)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ArtifactRegistryRepositorySpec.
+func (in *ArtifactRegistryRepositorySpec) DeepCopy() *ArtifactRegistryRepositorySpec {
+	if in == nil {
+		return nil
+	}
+	out := new(ArtifactRegistryRepositorySpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ArtifactRegistryRepositoryStatus) DeepCopyInto(out *ArtifactRegistryRepositoryStatus) {
+	*out = *in
+	if in.Conditions != nil {
+		in, out := &in.Conditions, &out.Conditions
+		*out = make([]v1alpha1.Condition, len(*in))
+		copy(*out, *in)
+	}
+	if in.ObservedGeneration != nil {
+		in, out := &in.ObservedGeneration, &out.ObservedGeneration
+		*out = new(int64)
+		**out = **in
+	}
+	if in.ExternalRef != nil {
+		in, out := &in.ExternalRef, &out.ExternalRef
+		*out = new(string)
+		**out = **in
+	}
+	if in.ObservedState != nil {
+		in, out := &in.ObservedState, &out.ObservedState
+		*out = new(ArtifactRegistryRepositoryObservedState)
+		(*in).DeepCopyInto(*out)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ArtifactRegistryRepositoryStatus.
+func (in *ArtifactRegistryRepositoryStatus) DeepCopy() *ArtifactRegistryRepositoryStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(ArtifactRegistryRepositoryStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *CleanupPolicies) DeepCopyInto(out *CleanupPolicies) {
+	*out = *in
+	if in.Action != nil {
+		in, out := &in.Action, &out.Action
+		*out = new(string)
+		**out = **in
+	}
+	if in.Condition != nil {
+		in, out := &in.Condition, &out.Condition
+		*out = new(CleanupPolicyCondition)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.MostRecentVersions != nil {
+		in, out := &in.MostRecentVersions, &out.MostRecentVersions
+		*out = new(CleanupPolicyMostRecentVersions)
+		(*in).DeepCopyInto(*out)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CleanupPolicies.
+func (in *CleanupPolicies) DeepCopy() *CleanupPolicies {
+	if in == nil {
+		return nil
+	}
+	out := new(CleanupPolicies)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *CleanupPolicyCondition) DeepCopyInto(out *CleanupPolicyCondition) {
+	*out = *in
+	if in.NewerThan != nil {
+		in, out := &in.NewerThan, &out.NewerThan
+		*out = new(string)
+		**out = **in
+	}
+	if in.OlderThan != nil {
+		in, out := &in.OlderThan, &out.OlderThan
+		*out = new(string)
+		**out = **in
+	}
+	if in.PackageNamePrefixes != nil {
+		in, out := &in.PackageNamePrefixes, &out.PackageNamePrefixes
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+	if in.TagPrefixes != nil {
+		in, out := &in.TagPrefixes, &out.TagPrefixes
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+	if in.TagState != nil {
+		in, out := &in.TagState, &out.TagState
+		*out = new(string)
+		**out = **in
+	}
+	if in.VersionNamePrefixes != nil {
+		in, out := &in.VersionNamePrefixes, &out.VersionNamePrefixes
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CleanupPolicyCondition.
+func (in *CleanupPolicyCondition) DeepCopy() *CleanupPolicyCondition {
+	if in == nil {
+		return nil
+	}
+	out := new(CleanupPolicyCondition)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *CleanupPolicyMostRecentVersions) DeepCopyInto(out *CleanupPolicyMostRecentVersions) {
+	*out = *in
+	if in.KeepCount != nil {
+		in, out := &in.KeepCount, &out.KeepCount
+		*out = new(int64)
+		**out = **in
+	}
+	if in.PackageNamePrefixes != nil {
+		in, out := &in.PackageNamePrefixes, &out.PackageNamePrefixes
+		*out = make([]string, len(*in))
+		copy(*out, *in)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CleanupPolicyMostRecentVersions.
+func (in *CleanupPolicyMostRecentVersions) DeepCopy() *CleanupPolicyMostRecentVersions {
+	if in == nil {
+		return nil
+	}
+	out := new(CleanupPolicyMostRecentVersions)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *DockerConfig) DeepCopyInto(out *DockerConfig) {
+	*out = *in
+	if in.ImmutableTags != nil {
+		in, out := &in.ImmutableTags, &out.ImmutableTags
+		*out = new(bool)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerConfig.
+func (in *DockerConfig) DeepCopy() *DockerConfig {
+	if in == nil {
+		return nil
+	}
+	out := new(DockerConfig)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *DockerRepository) DeepCopyInto(out *DockerRepository) {
+	*out = *in
+	if in.PublicRepository != nil {
+		in, out := &in.PublicRepository, &out.PublicRepository
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepository.
+func (in *DockerRepository) DeepCopy() *DockerRepository {
+	if in == nil {
+		return nil
+	}
+	out := new(DockerRepository)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MavenConfig) DeepCopyInto(out *MavenConfig) {
+	*out = *in
+	if in.AllowSnapshotOverwrites != nil {
+		in, out := &in.AllowSnapshotOverwrites, &out.AllowSnapshotOverwrites
+		*out = new(bool)
+		**out = **in
+	}
+	if in.VersionPolicy != nil {
+		in, out := &in.VersionPolicy, &out.VersionPolicy
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenConfig.
+func (in *MavenConfig) DeepCopy() *MavenConfig {
+	if in == nil {
+		return nil
+	}
+	out := new(MavenConfig)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MavenRepository) DeepCopyInto(out *MavenRepository) {
+	*out = *in
+	if in.PublicRepository != nil {
+		in, out := &in.PublicRepository, &out.PublicRepository
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepository.
+func (in *MavenRepository) DeepCopy() *MavenRepository {
+	if in == nil {
+		return nil
+	}
+	out := new(MavenRepository)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *NpmRepository) DeepCopyInto(out *NpmRepository) {
+	*out = *in
+	if in.PublicRepository != nil {
+		in, out := &in.PublicRepository, &out.PublicRepository
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepository.
+func (in *NpmRepository) DeepCopy() *NpmRepository {
+	if in == nil {
+		return nil
+	}
+	out := new(NpmRepository)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *PythonRepository) DeepCopyInto(out *PythonRepository) {
+	*out = *in
+	if in.PublicRepository != nil {
+		in, out := &in.PublicRepository, &out.PublicRepository
+		*out = new(string)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PythonRepository.
+func (in *PythonRepository) DeepCopy() *PythonRepository {
+	if in == nil {
+		return nil
+	}
+	out := new(PythonRepository)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *RemoteRepositoryConfig) DeepCopyInto(out *RemoteRepositoryConfig) {
+	*out = *in
+	if in.Description != nil {
+		in, out := &in.Description, &out.Description
+		*out = new(string)
+		**out = **in
+	}
+	if in.DockerRepository != nil {
+		in, out := &in.DockerRepository, &out.DockerRepository
+		*out = new(DockerRepository)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.MavenRepository != nil {
+		in, out := &in.MavenRepository, &out.MavenRepository
+		*out = new(MavenRepository)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.NpmRepository != nil {
+		in, out := &in.NpmRepository, &out.NpmRepository
+		*out = new(NpmRepository)
+		(*in).DeepCopyInto(*out)
+	}
+	if in.PythonRepository != nil {
+		in, out := &in.PythonRepository, &out.PythonRepository
+		*out = new(PythonRepository)
+		(*in).DeepCopyInto(*out)
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRepositoryConfig.
+func (in *RemoteRepositoryConfig) DeepCopy() *RemoteRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := new(RemoteRepositoryConfig)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *UpstreamPolicy) DeepCopyInto(out *UpstreamPolicy) {
+	*out = *in
+	if in.Id != nil {
+		in, out := &in.Id, &out.Id
+		*out = new(string)
+		**out = **in
+	}
+	if in.Priority != nil {
+		in, out := &in.Priority, &out.Priority
+		*out = new(int64)
+		**out = **in
+	}
+	if in.RepositoryRef != nil {
+		in, out := &in.RepositoryRef, &out.RepositoryRef
+		*out = new(refsv1beta1.ArtifactRegistryRepositoryRef)
+		**out = **in
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UpstreamPolicy.
+func (in *UpstreamPolicy) DeepCopy() *UpstreamPolicy {
+	if in == nil {
+		return nil
+	}
+	out := new(UpstreamPolicy)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *VirtualRepositoryConfig) DeepCopyInto(out *VirtualRepositoryConfig) {
+	*out = *in
+	if in.UpstreamPolicies != nil {
+		in, out := &in.UpstreamPolicies, &out.UpstreamPolicies
+		*out = make([]UpstreamPolicy, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualRepositoryConfig.
+func (in *VirtualRepositoryConfig) DeepCopy() *VirtualRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := new(VirtualRepositoryConfig)
+	in.DeepCopyInto(out)
+	return out
+}
diff --git a/apis/refs/v1beta1/artifactregistryrefs.go b/apis/refs/v1beta1/artifactregistryrefs.go
new file mode 100644
index 000000000..4bc010d4f
--- /dev/null
+++ b/apis/refs/v1beta1/artifactregistryrefs.go
@@ -0,0 +1,108 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v1beta1
+
+import (
+	"context"
+	"fmt"
+	"strings"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+type ArtifactRegistryRepositoryRef struct {
+	// A reference to an externally managed ArtifactRegistryRepository.
+	// Should be in the format `projects/[project_id]/locations/[location]/repositories/[repository_id]`.
+	External string `json:"external,omitempty"`
+
+	// The `name` of an `ArtifactRegistryRepository` resource.
+	Name string `json:"name,omitempty"`
+
+	// The `namespace` of an `ArtifactRegistryRepository` resource.
+	Namespace string `json:"namespace,omitempty"`
+}
+
+// ResolveArtifactRegistryRepositoryRef will resolve an ArtifactRegistryRepositoryRef to an ArtifactRegistryRepository.
+func ResolveArtifactRegistryRepositoryRef(ctx context.Context, reader client.Reader, src client.Object, ref *ArtifactRegistryRepositoryRef) (*ArtifactRegistryRepositoryRef, error) {
+	if ref == nil {
+		return nil, nil
+	}
+
+	if ref.Name == "" && ref.External == "" {
+		return nil, fmt.Errorf("must specify either name or external on ArtifactRegistryRepositoryRef")
+	}
+	if ref.Name != "" && ref.External != "" {
+		return nil, fmt.Errorf("cannot specify both name and external on ArtifactRegistryRepositoryRef")
+	}
+
+	// External should be in the `projects/[project_id]/locations/[location]/repositories/[repository_id]` format
+	if ref.External != "" {
+		tokens := strings.Split(ref.External, "/")
+		if len(tokens) == 6 && tokens[0] == "projects" && tokens[2] == "locations" && tokens[4] == "repositories" {
+			ref = &ArtifactRegistryRepositoryRef{
+				External: fmt.Sprintf("projects/%s/locations/%s/repositories/%s", tokens[1], tokens[3], tokens[5]),
+			}
+			return ref, nil
+		}
+		return nil, fmt.Errorf("format of ArtifactRegistryRepositoryRef external=%q was not known (use projects/[project_id]/locations/[location]/repositories/[repository_id])", ref.External)
+	}
+
+	key := types.NamespacedName{
+		Namespace: ref.Namespace,
+		Name:      ref.Name,
+	}
+	if key.Namespace == "" {
+		key.Namespace = src.GetNamespace()
+	}
+
+	// Fetch object from k8s cluster to construct the external form
+	repo := &unstructured.Unstructured{}
+	repo.SetGroupVersionKind(schema.GroupVersionKind{
+		Group:   "artifactregistry.cnrm.cloud.google.com",
+		Version: "v1beta1",
+		Kind:    "ArtifactRegistryRepository",
+	})
+	if err := reader.Get(ctx, key, repo); err != nil {
+		if apierrors.IsNotFound(err) {
+			return nil, fmt.Errorf("referenced ArtifactRegistryRepository %v not found", key)
+		}
+		return nil, fmt.Errorf("error reading referenced ArtifactRegistryRepository %v: %w", key, err)
+	}
+
+	repoResourceID, err := GetResourceID(repo)
+	if err != nil {
+		return nil, err
+	}
+
+	projectID, err := ResolveProjectID(ctx, reader, repo)
+	if err != nil {
+		return nil, err
+	}
+
+	location, err := GetLocation(repo)
+	if err != nil {
+		return nil, err
+	}
+
+	ref = &ArtifactRegistryRepositoryRef{
+		External: fmt.Sprintf("projects/%s/locations/%s/repositories/%s", projectID, location, repoResourceID),
+	}
+
+	return ref, nil
+}
diff --git a/config/crds/resources/apiextensions.k8s.io_v1_customresourcedefinition_artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com.yaml b/config/crds/resources/apiextensions.k8s.io_v1_customresourcedefinition_artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com.yaml
index abbe74d9b..13d557dc0 100644
--- a/config/crds/resources/apiextensions.k8s.io_v1_customresourcedefinition_artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com.yaml
+++ b/config/crds/resources/apiextensions.k8s.io_v1_customresourcedefinition_artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com.yaml
@@ -6,9 +6,7 @@ metadata:
   creationTimestamp: null
   labels:
     cnrm.cloud.google.com/managed-by-kcc: "true"
-    cnrm.cloud.google.com/stability-level: stable
     cnrm.cloud.google.com/system: "true"
-    cnrm.cloud.google.com/tf2crd: "true"
   name: artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com
 spec:
   group: artifactregistry.cnrm.cloud.google.com
@@ -16,6 +14,7 @@ spec:
     categories:
     - gcp
     kind: ArtifactRegistryRepository
+    listKind: ArtifactRegistryRepositoryList
     plural: artifactregistryrepositories
     shortNames:
     - gcpartifactregistryrepository
@@ -43,28 +42,34 @@ spec:
     name: v1beta1
     schema:
       openAPIV3Schema:
+        description: ArtifactRegistryRepository is the Schema for the artifactregistry
+          API
         properties:
           apiVersion:
-            description: 'apiVersion defines the versioned schema of this representation
+            description: 'APIVersion defines the versioned schema of this representation
               of an object. Servers should convert recognized schemas to the latest
-              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources'
+              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
             type: string
           kind:
-            description: 'kind is a string value representing the REST resource this
+            description: 'Kind is a string value representing the REST resource this
               object represents. Servers may infer this from the endpoint the client
-              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds'
+              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
             type: string
           metadata:
             type: object
           spec:
+            description: ArtifactRegistryRepositorySpec defines the desired state
+              of ArtifactRegistryRepository
             properties:
               cleanupPolicies:
-                description: |-
-                  Cleanup policies for this repository. Cleanup policies indicate when
-                  certain package versions can be automatically deleted.
-                  Map keys are policy IDs supplied by users during policy creation. They must
-                  unique within a repository and be under 128 characters in length.
+                description: Cleanup policies for this repository. Cleanup policies
+                  indicate when certain package versions can be automatically deleted.
+                  Map keys are policy IDs supplied by users during policy creation.
+                  They must unique within a repository and be under 128 characters
+                  in length.
                 items:
+                  description: CleanupPolicies defines cleanup policies for package
+                    versions
                   properties:
                     action:
                       description: 'Policy action. Possible values: ["DELETE", "KEEP"].'
@@ -104,12 +109,12 @@ spec:
                     id:
                       type: string
                     mostRecentVersions:
-                      description: |-
-                        Policy condition for retaining a minimum number of versions. May only be
-                        specified with a Keep action.
+                      description: Policy condition for retaining a minimum number
+                        of versions. May only be specified with a Keep action.
                       properties:
                         keepCount:
                           description: Minimum number of versions to keep.
+                          format: int64
                           type: integer
                         packageNamePrefixes:
                           description: Match versions by package prefix. Applied on
@@ -123,9 +128,8 @@ spec:
                   type: object
                 type: array
               cleanupPolicyDryRun:
-                description: |-
-                  If true, the cleanup pipeline is prevented from deleting versions in this
-                  repository.
+                description: If true, the cleanup pipeline is prevented from deleting
+                  versions in this repository.
                 type: boolean
               description:
                 description: The user-provided description of the repository.
@@ -141,16 +145,14 @@ spec:
                     type: boolean
                 type: object
               format:
-                description: |-
-                  Immutable. The format of packages that are stored in the repository. Supported formats
-                  can be found [here](https://cloud.google.com/artifact-registry/docs/supported-formats).
-                  You can only create alpha formats if you are a member of the
-                  [alpha user group](https://cloud.google.com/artifact-registry/docs/supported-formats#alpha-access).
+                description: Immutable. The format of packages that are stored in
+                  the repository. Supported formats can be found [here](https://cloud.google.com/artifact-registry/docs/supported-formats).
+                  You can only create alpha formats if you are a member of the [alpha
+                  user group](https://cloud.google.com/artifact-registry/docs/supported-formats#alpha-access).
                 type: string
               kmsKeyRef:
-                description: |-
-                  The customer managed encryption key thatâ€™s used to encrypt the
-                  contents of the Repository.
+                description: The customer managed encryption key that's used to encrypt
+                  the contents of the Repository.
                 oneOf:
                 - not:
                     required:
@@ -167,14 +169,14 @@ spec:
                   - external
                 properties:
                   external:
-                    description: 'Allowed value: The `selfLink` field of a `KMSCryptoKey`
-                      resource.'
+                    description: A reference to an externally managed KMSCryptoKey.
+                      Should be in the format `projects/[kms_project_id]/locations/[region]/keyRings/[key_ring_id]/cryptoKeys/[key]`.
                     type: string
                   name:
-                    description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
+                    description: The `name` of a `KMSCryptoKey` resource.
                     type: string
                   namespace:
-                    description: 'Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/'
+                    description: The `namespace` of a `KMSCryptoKey` resource.
                     type: string
                 type: object
               location:
@@ -182,15 +184,13 @@ spec:
                   located in.
                 type: string
               mavenConfig:
-                description: |-
-                  MavenRepositoryConfig is maven related repository details.
-                  Provides additional configuration details for repositories of the maven
-                  format type.
+                description: MavenRepositoryConfig is maven related repository details.
+                  Provides additional configuration details for repositories of the
+                  maven format type.
                 properties:
                   allowSnapshotOverwrites:
-                    description: |-
-                      Immutable. The repository with this flag will allow publishing the same
-                      snapshot versions.
+                    description: Immutable. The repository with this flag will allow
+                      publishing the same snapshot versions.
                     type: boolean
                   versionPolicy:
                     description: 'Immutable. Version policy defines the versions that
@@ -253,10 +253,12 @@ spec:
                 description: Configuration specific for a Virtual Repository.
                 properties:
                   upstreamPolicies:
-                    description: |-
-                      Policies that configure the upstream artifacts distributed by the Virtual
-                      Repository. Upstream policies cannot be set on a standard repository.
+                    description: Policies that configure the upstream artifacts distributed
+                      by the Virtual Repository. Upstream policies cannot be set on
+                      a standard repository.
                     items:
+                      description: UpstreamPolicy defines upstream policies for virtual
+                        repositories
                       properties:
                         id:
                           description: The user-provided ID of the upstream policy.
@@ -264,11 +266,11 @@ spec:
                         priority:
                           description: Entries with a greater priority value take
                             precedence in the pull order.
+                          format: int64
                           type: integer
                         repositoryRef:
-                          description: |-
-                            A reference to the repository resource, for example:
-                            "projects/p1/locations/us-central1/repositories/repo1".
+                          description: 'A reference to the repository resource, for
+                            example: "projects/p1/locations/us-central1/repositories/repo1".'
                           oneOf:
                           - not:
                               required:
@@ -285,16 +287,16 @@ spec:
                             - external
                           properties:
                             external:
-                              description: 'Allowed value: string of the format `projects/{{project}}/locations/{{location}}/repositories/{{value}}`,
-                                where {{value}} is the `name` field of an `ArtifactRegistryRepository`
-                                resource.'
+                              description: A reference to an externally managed ArtifactRegistryRepository.
+                                Should be in the format `projects/[project_id]/locations/[location]/repositories/[repository_id]`.
                               type: string
                             name:
-                              description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'
+                              description: The `name` of an `ArtifactRegistryRepository`
+                                resource.
                               type: string
                             namespace:
-                              description: 'Namespace of the referent. More info:
-                                https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/'
+                              description: The `namespace` of an `ArtifactRegistryRepository`
+                                resource.
                               type: string
                           type: object
                       type: object
@@ -305,10 +307,12 @@ spec:
             - location
             type: object
           status:
+            description: ArtifactRegistryRepositoryStatus defines the config connector
+              machine state of ArtifactRegistryRepository
             properties:
               conditions:
-                description: Conditions represent the latest available observation
-                  of the resource's current state.
+                description: Conditions represent the latest available observations
+                  of the object's current state.
                 items:
                   properties:
                     lastTransitionTime:
@@ -332,13 +336,9 @@ spec:
                       type: string
                   type: object
                 type: array
-              createTime:
-                description: The time when the repository was created.
-                type: string
-              name:
-                description: |-
-                  The name of the repository, for example:
-                  "repo1".
+              externalRef:
+                description: A unique specifier for the ArtifactRegistryRepository
+                  resource in GCP.
                 type: string
               observedGeneration:
                 description: ObservedGeneration is the generation of the resource
@@ -346,21 +346,25 @@ spec:
                   If this is equal to metadata.generation, then that means that the
                   current reported status reflects the most recent desired state of
                   the resource.
+                format: int64
                 type: integer
-              updateTime:
-                description: The time when the repository was last updated.
-                type: string
+              observedState:
+                description: ObservedState is the state of the resource as most recently
+                  observed in GCP.
+                properties:
+                  createTime:
+                    description: The time when the repository was created.
+                    type: string
+                  name:
+                    description: 'The name of the repository, for example: "repo1".'
+                    type: string
+                  updateTime:
+                    description: The time when the repository was last updated.
+                    type: string
+                type: object
             type: object
-        required:
-        - spec
         type: object
     served: true
     storage: true
     subresources:
       status: {}
-status:
-  acceptedNames:
-    kind: ""
-    plural: ""
-  conditions: []
-  storedVersions: []
diff --git a/crds/artifactregistry_v1beta1_artifactregistryrepository.yaml b/crds/artifactregistry_v1beta1_artifactregistryrepository.yaml
index f42c6bb92..040f64a3e 100644
--- a/crds/artifactregistry_v1beta1_artifactregistryrepository.yaml
+++ b/crds/artifactregistry_v1beta1_artifactregistryrepository.yaml
@@ -22,7 +22,6 @@ metadata:
     cnrm.cloud.google.com/managed-by-kcc: "true"
     cnrm.cloud.google.com/stability-level: stable
     cnrm.cloud.google.com/system: "true"
-    cnrm.cloud.google.com/tf2crd: "true"
   name: artifactregistryrepositories.artifactregistry.cnrm.cloud.google.com
 spec:
   group: artifactregistry.cnrm.cloud.google.com
diff --git a/go.mod b/go.mod
index 9a3101d5b..548461961 100644
--- a/go.mod
+++ b/go.mod
@@ -110,11 +110,11 @@ require (
 	golang.org/x/oauth2 v0.30.0
 	golang.org/x/sync v0.16.0
 	golang.org/x/time v0.12.0
-	google.golang.org/api v0.246.0
+	google.golang.org/api v0.247.0
 	google.golang.org/genproto v0.0.0-20250603155806-513f23925822
-	google.golang.org/genproto/googleapis/api v0.0.0-20250804133106-a7a43d27e69b
+	google.golang.org/genproto/googleapis/api v0.0.0-20250818200422-3122310a409c
 	google.golang.org/genproto/googleapis/api/serviceusage v0.0.0-20250519155744-55703ea1f237
-	google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b
+	google.golang.org/genproto/googleapis/rpc v0.0.0-20250818200422-3122310a409c
 	google.golang.org/grpc v1.74.2
 	google.golang.org/protobuf v1.36.7
 	gopkg.in/dnaeon/go-vcr.v3 v3.2.0
@@ -135,6 +135,7 @@ require (
 require go.opentelemetry.io/auto/sdk v1.1.0 // indirect
 
 require (
+	cloud.google.com/go/artifactregistry v1.17.2 // indirect
 	cloud.google.com/go/osconfig v1.14.6 // indirect
 	github.com/envoyproxy/go-control-plane/envoy v1.32.4 // indirect
 	github.com/fxamacker/cbor/v2 v2.7.0 // indirect
@@ -157,10 +158,10 @@ require (
 	bitbucket.org/creachadair/stringset v0.0.8 // indirect
 	cel.dev/expr v0.24.0 // indirect
 	cloud.google.com/go v0.121.2 // indirect
-	cloud.google.com/go/auth v0.16.3 // indirect
+	cloud.google.com/go/auth v0.16.4 // indirect
 	cloud.google.com/go/auth/oauth2adapt v0.2.8 // indirect
 	cloud.google.com/go/bigtable v1.38.0
-	cloud.google.com/go/compute/metadata v0.7.0 // indirect
+	cloud.google.com/go/compute/metadata v0.8.0 // indirect
 	cloud.google.com/go/longrunning v0.6.7
 	dario.cat/mergo v1.0.0 // indirect
 	github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161 // indirect
@@ -281,14 +282,14 @@ require (
 	go.opentelemetry.io/otel/sdk/metric v1.36.0 // indirect
 	go.opentelemetry.io/otel/trace v1.36.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
-	golang.org/x/crypto v0.40.0 // indirect
+	golang.org/x/crypto v0.41.0 // indirect
 	golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 // indirect
-	golang.org/x/mod v0.25.0 // indirect
-	golang.org/x/net v0.42.0 // indirect
-	golang.org/x/sys v0.34.0 // indirect
-	golang.org/x/term v0.33.0 // indirect
-	golang.org/x/text v0.27.0 // indirect
-	golang.org/x/tools v0.34.0
+	golang.org/x/mod v0.26.0 // indirect
+	golang.org/x/net v0.43.0 // indirect
+	golang.org/x/sys v0.35.0 // indirect
+	golang.org/x/term v0.34.0 // indirect
+	golang.org/x/text v0.28.0 // indirect
+	golang.org/x/tools v0.35.0
 	golang.org/x/xerrors v0.0.0-20240903120638-7835f813f4da // indirect
 	gomodules.xyz/jsonpatch/v2 v2.4.0 // indirect
 	google.golang.org/appengine v1.6.8 // indirect
diff --git a/go.sum b/go.sum
index 0b123e2b5..a7071b878 100644
--- a/go.sum
+++ b/go.sum
@@ -19,10 +19,14 @@ cloud.google.com/go/apikeys v1.1.12 h1:ZTFWJ1ibGjiIrIhhtdWOm7AGJd+y9R17dVujlgU//
 cloud.google.com/go/apikeys v1.1.12/go.mod h1:3tqZUj8CmCJm0maQyLufgyO5Ghf3AZQ6hcSkIqsSIm4=
 cloud.google.com/go/apphub v0.2.4 h1:lhsd/6+16NUshw8c52T+DfMaAz04SX6ItMr8caGbtgY=
 cloud.google.com/go/apphub v0.2.4/go.mod h1:QJw0OWQIQv/NvBz2/RJGAD6iJTLamf3vqOEsvFMixHw=
+cloud.google.com/go/artifactregistry v1.17.2 h1:Gx5vsnIFEx+obM1VdtMF2AuTraYESRCrBxvc9+6jBZg=
+cloud.google.com/go/artifactregistry v1.17.2/go.mod h1:h4CIl9TJZskg9c9u1gC9vTsOTo1PrAnnxntprqS3AjM=
 cloud.google.com/go/asset v1.21.1 h1:i55wWC/EwVdHMyJgRfbLp/L6ez4nQuOpZwSxkuqN9ek=
 cloud.google.com/go/asset v1.21.1/go.mod h1:7AzY1GCC+s1O73yzLM1IpHFLHz3ws2OigmCpOQHwebk=
 cloud.google.com/go/auth v0.16.3 h1:kabzoQ9/bobUmnseYnBO6qQG7q4a/CffFRlJSxv2wCc=
 cloud.google.com/go/auth v0.16.3/go.mod h1:NucRGjaXfzP1ltpcQ7On/VTZ0H4kWB5Jy+Y9Dnm76fA=
+cloud.google.com/go/auth v0.16.4 h1:fXOAIQmkApVvcIn7Pc2+5J8QTMVbUGLscnSVNl11su8=
+cloud.google.com/go/auth v0.16.4/go.mod h1:j10ncYwjX/g3cdX7GpEzsdM+d+ZNsXAbb6qXA7p1Y5M=
 cloud.google.com/go/auth/oauth2adapt v0.2.8 h1:keo8NaayQZ6wimpNSmW5OPc283g65QNIiLpZnkHRbnc=
 cloud.google.com/go/auth/oauth2adapt v0.2.8/go.mod h1:XQ9y31RkqZCcwJWNSx2Xvric3RrU88hAYYbjDWYDL+c=
 cloud.google.com/go/backupdr v1.3.1 h1:AwJ0pja16mNvZcq8crxGSDCtvkWtdppNGAEADuzS5ys=
@@ -49,6 +53,8 @@ cloud.google.com/go/compute v1.38.0 h1:MilCLYQW2m7Dku8hRIIKo4r0oKastlD74sSu16riY
 cloud.google.com/go/compute v1.38.0/go.mod h1:oAFNIuXOmXbK/ssXm3z4nZB8ckPdjltJ7xhHCdbWFZM=
 cloud.google.com/go/compute/metadata v0.7.0 h1:PBWF+iiAerVNe8UCHxdOt6eHLVc3ydFeOCw78U8ytSU=
 cloud.google.com/go/compute/metadata v0.7.0/go.mod h1:j5MvL9PprKL39t166CoB1uVHfQMs4tFQZZcKwksXUjo=
+cloud.google.com/go/compute/metadata v0.8.0 h1:HxMRIbao8w17ZX6wBnjhcDkW6lTFpgcaobyVfZWqRLA=
+cloud.google.com/go/compute/metadata v0.8.0/go.mod h1:sYOGTp851OV9bOFJ9CH7elVvyzopvWQFNNghtDQ/Biw=
 cloud.google.com/go/datacatalog v1.26.0 h1:eFgygb3DTufTWWUB8ARk+dSuXz+aefNJXTlkWlQcWwE=
 cloud.google.com/go/datacatalog v1.26.0/go.mod h1:bLN2HLBAwB3kLTFT5ZKLHVPj/weNz6bR0c7nYp0LE14=
 cloud.google.com/go/dataflow v0.11.0 h1:AdhB4cAkMOC9NtrHJxpKOVvO/VqBLaIyk0tEEhbGjYM=
@@ -863,6 +869,8 @@ golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5y
 golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/crypto v0.40.0 h1:r4x+VvoG5Fm+eJcxMaY8CQM7Lb0l1lsmjGBQ6s8BfKM=
 golang.org/x/crypto v0.40.0/go.mod h1:Qr1vMER5WyS2dfPHAlsOj01wgLbsyWtFn/aY+5+ZdxY=
+golang.org/x/crypto v0.41.0 h1:WKYxWedPGCTVVl5+WHSSrOBT0O8lx32+zxmHxijgXp4=
+golang.org/x/crypto v0.41.0/go.mod h1:pO5AFd7FA68rFak7rOAGVuygIISepHftHnr8dr6+sUc=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/exp v0.0.0-20190312203227-4b39c73a6495/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
@@ -880,6 +888,8 @@ golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
 golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
 golang.org/x/mod v0.25.0 h1:n7a+ZbQKQA/Ysbyb0/6IbB1H/X41mKgbhfv7AfG/44w=
 golang.org/x/mod v0.25.0/go.mod h1:IXM97Txy2VM4PJ3gI61r1YEk/gAj6zAHN3AdZt6S9Ww=
+golang.org/x/mod v0.26.0 h1:EGMPT//Ezu+ylkCijjPc+f4Aih7sZvaAr+O3EHBxvZg=
+golang.org/x/mod v0.26.0/go.mod h1:/j6NAhSk8iQ723BGAUyoAcn7SlD7s15Dp9Nd/SfeaFQ=
 golang.org/x/net v0.0.0-20170114055629-f2499483f923/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180112015858-5ccada7d0a7b/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
@@ -910,6 +920,8 @@ golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qx
 golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
 golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=
 golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=
+golang.org/x/net v0.43.0 h1:lat02VYK2j4aLzMzecihNvTlJNQUq316m2Mr9rnM6YE=
+golang.org/x/net v0.43.0/go.mod h1:vhO1fvI4dGsIjh73sWfUVjj3N7CA9WkKJNQm2svM6Jg=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
 golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
@@ -967,10 +979,14 @@ golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.34.0 h1:H5Y5sJ2L2JRdyv7ROF1he/lPdvFsd0mJHFw2ThKHxLA=
 golang.org/x/sys v0.34.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
+golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
+golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
 golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
 golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 golang.org/x/term v0.33.0 h1:NuFncQrRcaRvVmgRkvM3j/F00gWIAlcmlB8ACEKmGIg=
 golang.org/x/term v0.33.0/go.mod h1:s18+ql9tYWp1IfpV9DmCtQDDSRBUjKaw9M1eAv5UeF0=
+golang.org/x/term v0.34.0 h1:O/2T7POpk0ZZ7MAzMeWFSg6S5IpWd/RXDlM9hgM3DR4=
+golang.org/x/term v0.34.0/go.mod h1:5jC53AEywhIVebHgPVeg0mj8OD3VO9OzclacVrqpaAw=
 golang.org/x/text v0.0.0-20160726164857-2910a502d2bf/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.1-0.20171227012246-e19ae1496984/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
@@ -983,6 +999,8 @@ golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
 golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
 golang.org/x/text v0.27.0 h1:4fGWRpyh641NLlecmyl4LOe6yDdfaYNrGb2zdfo4JV4=
 golang.org/x/text v0.27.0/go.mod h1:1D28KMCvyooCX9hBiosv5Tz/+YLxj0j7XhWjpSUF7CU=
+golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=
+golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
 golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
 golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
@@ -1007,6 +1025,8 @@ golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4f
 golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
 golang.org/x/tools v0.34.0 h1:qIpSLOxeCYGg9TrcJokLBG4KFA6d795g0xkBkiESGlo=
 golang.org/x/tools v0.34.0/go.mod h1:pAP9OwEaY1CAW3HOmg3hLZC5Z0CCmzjAF2UQMSqNARg=
+golang.org/x/tools v0.35.0 h1:mBffYraMEf7aa0sB+NuKnuCy8qI/9Bughn8dC2Gu5r0=
+golang.org/x/tools v0.35.0/go.mod h1:NKdj5HkL/73byiZSJjqJgKn3ep7KjFkBOkR/Hps3VPw=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -1024,6 +1044,8 @@ gonum.org/v1/netlib v0.0.0-20190331212654-76723241ea4e/go.mod h1:kS+toOQn6AQKjmK
 google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
 google.golang.org/api v0.246.0 h1:H0ODDs5PnMZVZAEtdLMn2Ul2eQi7QNjqM2DIFp8TlTM=
 google.golang.org/api v0.246.0/go.mod h1:dMVhVcylamkirHdzEBAIQWUCgqY885ivNeZYd7VAVr8=
+google.golang.org/api v0.247.0 h1:tSd/e0QrUlLsrwMKmkbQhYVa109qIintOls2Wh6bngc=
+google.golang.org/api v0.247.0/go.mod h1:r1qZOPmxXffXg6xS5uhx16Fa/UFY8QU/K4bfKrnvovM=
 google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
 google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
 google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
@@ -1041,10 +1063,14 @@ google.golang.org/genproto v0.0.0-20250603155806-513f23925822 h1:rHWScKit0gvAPuO
 google.golang.org/genproto v0.0.0-20250603155806-513f23925822/go.mod h1:HubltRL7rMh0LfnQPkMH4NPDFEWp0jw3vixw7jEM53s=
 google.golang.org/genproto/googleapis/api v0.0.0-20250804133106-a7a43d27e69b h1:ULiyYQ0FdsJhwwZUwbaXpZF5yUE3h+RA+gxvBu37ucc=
 google.golang.org/genproto/googleapis/api v0.0.0-20250804133106-a7a43d27e69b/go.mod h1:oDOGiMSXHL4sDTJvFvIB9nRQCGdLP1o/iVaqQK8zB+M=
+google.golang.org/genproto/googleapis/api v0.0.0-20250818200422-3122310a409c h1:AtEkQdl5b6zsybXcbz00j1LwNodDuH6hVifIaNqk7NQ=
+google.golang.org/genproto/googleapis/api v0.0.0-20250818200422-3122310a409c/go.mod h1:ea2MjsO70ssTfCjiwHgI0ZFqcw45Ksuk2ckf9G468GA=
 google.golang.org/genproto/googleapis/api/serviceusage v0.0.0-20250519155744-55703ea1f237 h1:s26x/Q4E4zQd7DKL8gpnEnRJmGqWvraezKu2q12CyBg=
 google.golang.org/genproto/googleapis/api/serviceusage v0.0.0-20250519155744-55703ea1f237/go.mod h1:qHyHwIge/12k5kr63VRq/UMolD/sVcMjAGL41LlV8JU=
 google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b h1:zPKJod4w6F1+nRGDI9ubnXYhU9NSWoFAijkHkUXeTK8=
 google.golang.org/genproto/googleapis/rpc v0.0.0-20250804133106-a7a43d27e69b/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20250818200422-3122310a409c h1:qXWI/sQtv5UKboZ/zUk7h+mrf/lXORyI+n9DKDAusdg=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20250818200422-3122310a409c/go.mod h1:gw1tLEfykwDz2ET4a12jcXt4couGAm7IwsVaTy0Sflo=
 google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
 google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
 google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
diff --git a/pkg/controller/direct/artifactregistry/repository_controller.go b/pkg/controller/direct/artifactregistry/repository_controller.go
new file mode 100644
index 000000000..553603400
--- /dev/null
+++ b/pkg/controller/direct/artifactregistry/repository_controller.go
@@ -0,0 +1,297 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package artifactregistry
+
+import (
+	"context"
+	"fmt"
+	"strings"
+
+	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/artifactregistry/v1beta1"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/config"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/common"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/directbase"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/registry"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/label"
+
+	artifactregistry "cloud.google.com/go/artifactregistry/apiv1"
+	"cloud.google.com/go/artifactregistry/apiv1/artifactregistrypb"
+	"google.golang.org/protobuf/types/known/fieldmaskpb"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/klog/v2"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+const (
+	ctrlName = "artifactregistry-controller"
+)
+
+func init() {
+	registry.RegisterModel(krm.ArtifactRegistryRepositoryGVK, NewModel)
+}
+
+func NewModel(ctx context.Context, config *config.ControllerConfig) (directbase.Model, error) {
+	return &model{config: config}, nil
+}
+
+var _ directbase.Model = &model{}
+
+type model struct {
+	config *config.ControllerConfig
+}
+
+func (m *model) client(ctx context.Context) (*artifactregistry.Client, error) {
+	log := klog.FromContext(ctx).WithName(ctrlName)
+	log.Info("creating ArtifactRegistry client", "userAgent", m.config.UserAgent, "billingProject", m.config.BillingProject)
+
+	opts, err := m.config.RESTClientOptions()
+	if err != nil {
+		return nil, fmt.Errorf("error getting REST client options: %w", err)
+	}
+
+	gcpClient, err := artifactregistry.NewRESTClient(ctx, opts...)
+	if err != nil {
+		log.Error(err, "failed to create ArtifactRegistry client")
+		return nil, fmt.Errorf("building artifact registry client: %w", err)
+	}
+
+	log.Info("successfully created ArtifactRegistry client")
+	return gcpClient, nil
+}
+
+func (m *model) AdapterForObject(ctx context.Context, reader client.Reader, u *unstructured.Unstructured) (directbase.Adapter, error) {
+	obj := &krm.ArtifactRegistryRepository{}
+	copied := u.DeepCopy()
+	if err := label.ComputeLabels(copied); err != nil {
+		return nil, err
+	}
+	if err := runtime.DefaultUnstructuredConverter.FromUnstructured(copied.Object, &obj); err != nil {
+		return nil, fmt.Errorf("error converting to %T: %w", obj, err)
+	}
+
+	id, err := NewArtifactRegistryRepositoryIdentity(ctx, reader, obj, copied)
+	if err != nil {
+		return nil, err
+	}
+
+	// Get GCP client
+	gcpClient, err := m.client(ctx)
+	if err != nil {
+		return nil, err
+	}
+	return &Adapter{
+		id:        id,
+		gcpClient: gcpClient,
+		desired:   obj,
+	}, nil
+}
+
+func (m *model) AdapterForURL(ctx context.Context, url string) (directbase.Adapter, error) {
+	// TODO: Support reading resources by URL
+	return nil, nil
+}
+
+type Adapter struct {
+	id        *ArtifactRegistryRepositoryIdentity
+	gcpClient *artifactregistry.Client
+	desired   *krm.ArtifactRegistryRepository
+	actual    *artifactregistrypb.Repository
+}
+
+var _ directbase.Adapter = &Adapter{}
+
+func (a *Adapter) Find(ctx context.Context) (bool, error) {
+	log := klog.FromContext(ctx).WithName(ctrlName)
+	log.Info("starting Find operation for ArtifactRegistry repository", "name", a.id.FullyQualifiedName(), "project", a.id.Parent.ProjectID, "location", a.id.Parent.Location)
+
+	req := &artifactregistrypb.GetRepositoryRequest{Name: a.id.FullyQualifiedName()}
+	log.Info("calling GCP GetRepository API", "request", req.Name)
+
+	repositoryPB, err := a.gcpClient.GetRepository(ctx, req)
+	if err != nil {
+		if direct.IsNotFound(err) {
+			log.Info("ArtifactRegistry repository not found in GCP", "name", a.id.FullyQualifiedName())
+			return false, nil
+		}
+		log.Error(err, "failed to get ArtifactRegistry repository from GCP", "name", a.id.FullyQualifiedName())
+		return false, fmt.Errorf("getting ArtifactRegistry repository %q: %w", a.id.FullyQualifiedName(), err)
+	}
+
+	log.Info("successfully found ArtifactRegistry repository in GCP", "name", a.id.FullyQualifiedName(), "format", repositoryPB.GetFormat())
+	a.actual = repositoryPB
+	return true, nil
+}
+
+func (a *Adapter) Create(ctx context.Context, createOp *directbase.CreateOperation) error {
+	log := klog.FromContext(ctx).WithName(ctrlName)
+	log.Info("starting Create operation for ArtifactRegistry repository", "name", a.id.FullyQualifiedName(), "project", a.id.Parent.ProjectID, "location", a.id.Parent.Location)
+
+	mapCtx := &direct.MapContext{}
+
+	desired := a.desired.DeepCopy()
+	resource := ArtifactRegistryRepositorySpec_ToProto(mapCtx, &desired.Spec)
+	if mapCtx.Err() != nil {
+		log.Error(mapCtx.Err(), "failed to map desired spec to proto")
+		return mapCtx.Err()
+	}
+
+	resource.Name = a.id.FullyQualifiedName()
+
+	req := &artifactregistrypb.CreateRepositoryRequest{
+		Parent:       a.id.Parent.String(),
+		RepositoryId: a.id.ResourceID,
+		Repository:   resource,
+	}
+
+	log.Info("calling GCP CreateRepository API", "parent", req.Parent, "repositoryId", req.RepositoryId, "format", resource.GetFormat())
+
+	op, err := a.gcpClient.CreateRepository(ctx, req)
+	if err != nil {
+		log.Error(err, "failed to create ArtifactRegistry repository in GCP", "name", a.id.FullyQualifiedName())
+		return fmt.Errorf("creating ArtifactRegistry repository %q: %w", a.id.FullyQualifiedName(), err)
+	}
+
+	log.Info("successfully called GCP CreateRepository API", "name", a.id.FullyQualifiedName(), "operation", op.Name())
+	return nil
+}
+
+func (a *Adapter) Update(ctx context.Context, updateOp *directbase.UpdateOperation) error {
+	log := klog.FromContext(ctx).WithName(ctrlName)
+	log.Info("starting Update operation for ArtifactRegistry repository", "name", a.id.FullyQualifiedName())
+
+	if a.actual == nil {
+		return fmt.Errorf("Update called without a prior call to Find")
+	}
+
+	mapCtx := &direct.MapContext{}
+
+	desired := a.desired.DeepCopy()
+	resource := ArtifactRegistryRepositorySpec_ToProto(mapCtx, &desired.Spec)
+	if mapCtx.Err() != nil {
+		return mapCtx.Err()
+	}
+
+	resource.Name = a.id.FullyQualifiedName()
+
+	// Validate critical immutable fields explicitly
+	if a.desired.Spec.Format != "" && a.actual.Format.String() != "" && a.desired.Spec.Format != a.actual.Format.String() {
+		return fmt.Errorf("field 'spec.format' is immutable and cannot be updated from %q to %q", a.actual.Format.String(), a.desired.Spec.Format)
+	}
+
+	if a.desired.Spec.Location != "" && a.actual.GetName() != "" {
+		// Extract location from actual name path (projects/.../locations/LOCATION/repositories/...)
+		if !strings.Contains(a.actual.GetName(), "locations/"+a.desired.Spec.Location+"/") {
+			return fmt.Errorf("field 'spec.location' is immutable and cannot be updated")
+		}
+	}
+
+	if a.desired.Spec.Mode != nil && a.actual.Mode.String() != "" && *a.desired.Spec.Mode != a.actual.Mode.String() {
+		return fmt.Errorf("field 'spec.mode' is immutable and cannot be updated from %q to %q", a.actual.Mode.String(), *a.desired.Spec.Mode)
+	}
+
+	// Validate Maven config immutable fields
+	if a.desired.Spec.MavenConfig != nil && a.actual.GetMavenConfig() != nil {
+		if a.desired.Spec.MavenConfig.AllowSnapshotOverwrites != nil &&
+			a.actual.GetMavenConfig().GetAllowSnapshotOverwrites() != *a.desired.Spec.MavenConfig.AllowSnapshotOverwrites {
+			return fmt.Errorf("field 'spec.mavenConfig.allowSnapshotOverwrites' is immutable and cannot be updated from %v to %v",
+				a.actual.GetMavenConfig().GetAllowSnapshotOverwrites(), *a.desired.Spec.MavenConfig.AllowSnapshotOverwrites)
+		}
+		if a.desired.Spec.MavenConfig.VersionPolicy != nil &&
+			a.actual.GetMavenConfig().GetVersionPolicy().String() != *a.desired.Spec.MavenConfig.VersionPolicy {
+			return fmt.Errorf("field 'spec.mavenConfig.versionPolicy' is immutable and cannot be updated from %q to %q",
+				a.actual.GetMavenConfig().GetVersionPolicy().String(), *a.desired.Spec.MavenConfig.VersionPolicy)
+		}
+	}
+
+	// Validate RemoteRepositoryConfig is immutable (entire block)
+	if (a.desired.Spec.RemoteRepositoryConfig != nil) != (a.actual.GetRemoteRepositoryConfig() != nil) {
+		return fmt.Errorf("field 'spec.remoteRepositoryConfig' is immutable and cannot be changed after creation")
+	}
+
+	// Use common.CompareProtoMessage to automatically detect changes and validate immutable fields
+	paths, err := common.CompareProtoMessage(resource, a.actual, common.BasicDiff)
+	if err != nil {
+		return fmt.Errorf("comparing desired and actual state: %w", err)
+	}
+
+	if len(paths) == 0 {
+		log.V(2).Info("no field needs update", "name", a.id.FullyQualifiedName())
+		return nil
+	}
+
+	updateMask := &fieldmaskpb.FieldMask{}
+	updateMask.Paths = sets.List(paths)
+
+	req := &artifactregistrypb.UpdateRepositoryRequest{
+		Repository: resource,
+		UpdateMask: updateMask,
+	}
+
+	repository, err := a.gcpClient.UpdateRepository(ctx, req)
+	if err != nil {
+		return fmt.Errorf("updating ArtifactRegistry repository %q: %w", a.id.FullyQualifiedName(), err)
+	}
+
+	log.V(2).Info("successfully updated ArtifactRegistry repository", "name", a.id.FullyQualifiedName())
+
+	a.actual = repository
+	return nil
+}
+
+func (a *Adapter) Export(ctx context.Context) (*unstructured.Unstructured, error) {
+	if a.actual == nil {
+		return nil, fmt.Errorf("Find() not called")
+	}
+	u := &unstructured.Unstructured{}
+
+	obj := &krm.ArtifactRegistryRepository{}
+	mapCtx := &direct.MapContext{}
+	obj.Spec = direct.ValueOf(ArtifactRegistryRepositorySpec_FromProto(mapCtx, a.actual))
+	if mapCtx.Err() != nil {
+		return nil, mapCtx.Err()
+	}
+	obj.Status.ObservedState = ArtifactRegistryRepositoryObservedState_FromProto(mapCtx, a.actual)
+	if mapCtx.Err() != nil {
+		return nil, mapCtx.Err()
+	}
+	uObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
+	if err != nil {
+		return nil, err
+	}
+	u.Object = uObj
+	return u, nil
+}
+
+func (a *Adapter) Delete(ctx context.Context, deleteOp *directbase.DeleteOperation) (bool, error) {
+	log := klog.FromContext(ctx).WithName(ctrlName)
+	log.V(2).Info("deleting ArtifactRegistry repository", "name", a.id.FullyQualifiedName())
+
+	req := &artifactregistrypb.DeleteRepositoryRequest{Name: a.id.FullyQualifiedName()}
+
+	_, err := a.gcpClient.DeleteRepository(ctx, req)
+	if err != nil {
+		if direct.IsNotFound(err) {
+			log.V(2).Info("ArtifactRegistry repository was not found, assuming already deleted", "name", a.id.FullyQualifiedName())
+			return true, nil
+		}
+		return false, fmt.Errorf("deleting ArtifactRegistry repository %q: %w", a.id.FullyQualifiedName(), err)
+	}
+
+	log.V(2).Info("successfully deleted ArtifactRegistry repository", "name", a.id.FullyQualifiedName())
+	return true, nil
+}
diff --git a/pkg/controller/direct/artifactregistry/repository_identity.go b/pkg/controller/direct/artifactregistry/repository_identity.go
new file mode 100644
index 000000000..476db6797
--- /dev/null
+++ b/pkg/controller/direct/artifactregistry/repository_identity.go
@@ -0,0 +1,76 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package artifactregistry
+
+import (
+	"context"
+	"fmt"
+
+	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/artifactregistry/v1beta1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+type ArtifactRegistryRepositoryIdentity struct {
+	Parent     ArtifactRegistryRepositoryParent
+	ResourceID string
+}
+
+type ArtifactRegistryRepositoryParent struct {
+	ProjectID string
+	Location  string
+}
+
+func (p *ArtifactRegistryRepositoryParent) String() string {
+	return fmt.Sprintf("projects/%s/locations/%s", p.ProjectID, p.Location)
+}
+
+func (i *ArtifactRegistryRepositoryIdentity) FullyQualifiedName() string {
+	return fmt.Sprintf("%s/repositories/%s", i.Parent.String(), i.ResourceID)
+}
+
+func NewArtifactRegistryRepositoryIdentity(ctx context.Context, reader client.Reader, obj *krm.ArtifactRegistryRepository, u *unstructured.Unstructured) (*ArtifactRegistryRepositoryIdentity, error) {
+	// Get project ID from annotation (standard Config Connector approach)
+	var projectID string
+	annotations := obj.GetAnnotations()
+	if annotations != nil {
+		if pid, ok := annotations["cnrm.cloud.google.com/project-id"]; ok {
+			projectID = pid
+		}
+	}
+	if projectID == "" {
+		return nil, fmt.Errorf("missing required annotation cnrm.cloud.google.com/project-id")
+	}
+
+	// Get location
+	location := obj.Spec.Location
+	if location == "" {
+		return nil, fmt.Errorf("missing required field spec.location")
+	}
+
+	// Get resource ID
+	resourceID := obj.Spec.ResourceID
+	if resourceID == nil {
+		resourceID = &obj.ObjectMeta.Name
+	}
+
+	return &ArtifactRegistryRepositoryIdentity{
+		Parent: ArtifactRegistryRepositoryParent{
+			ProjectID: projectID,
+			Location:  location,
+		},
+		ResourceID: *resourceID,
+	}, nil
+}
diff --git a/pkg/controller/direct/artifactregistry/repository_mapping.go b/pkg/controller/direct/artifactregistry/repository_mapping.go
new file mode 100644
index 000000000..02c9a65ec
--- /dev/null
+++ b/pkg/controller/direct/artifactregistry/repository_mapping.go
@@ -0,0 +1,519 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package artifactregistry
+
+import (
+	"strings"
+
+	"cloud.google.com/go/artifactregistry/apiv1/artifactregistrypb"
+	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/artifactregistry/v1beta1"
+	refs "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
+)
+
+// FromProto functions for reading from GCP
+
+func ArtifactRegistryRepositorySpec_FromProto(mapCtx *direct.MapContext, in *artifactregistrypb.Repository) *krm.ArtifactRegistryRepositorySpec {
+	if in == nil {
+		return nil
+	}
+	out := &krm.ArtifactRegistryRepositorySpec{}
+
+	// Convert format
+	out.Format = Repository_Format_FromProto(mapCtx, in.Format)
+
+	// Convert description
+	if in.Description != "" {
+		out.Description = &in.Description
+	}
+
+	// Convert mode
+	out.Mode = Repository_Mode_FromProto(mapCtx, in.Mode)
+
+	// Convert cleanup policy dry run
+	if in.CleanupPolicyDryRun {
+		out.CleanupPolicyDryRun = &in.CleanupPolicyDryRun
+	}
+
+	// Convert KMS key
+	if in.KmsKeyName != "" {
+		out.KmsKeyRef = &refs.KMSCryptoKeyRef{External: in.KmsKeyName}
+	}
+
+	return out
+}
+
+func Repository_Format_FromProto(mapCtx *direct.MapContext, format artifactregistrypb.Repository_Format) string {
+	switch format {
+	case artifactregistrypb.Repository_DOCKER:
+		return "DOCKER"
+	case artifactregistrypb.Repository_MAVEN:
+		return "MAVEN"
+	case artifactregistrypb.Repository_NPM:
+		return "NPM"
+	case artifactregistrypb.Repository_APT:
+		return "APT"
+	case artifactregistrypb.Repository_YUM:
+		return "YUM"
+	case artifactregistrypb.Repository_PYTHON:
+		return "PYTHON"
+	case artifactregistrypb.Repository_KFP:
+		return "KFP"
+	case artifactregistrypb.Repository_GO:
+		return "GO"
+	case artifactregistrypb.Repository_GENERIC:
+		return "GENERIC"
+	default:
+		return "FORMAT_UNSPECIFIED"
+	}
+}
+
+func Repository_Mode_FromProto(mapCtx *direct.MapContext, mode artifactregistrypb.Repository_Mode) *string {
+	var result string
+	switch mode {
+	case artifactregistrypb.Repository_STANDARD_REPOSITORY:
+		result = "STANDARD_REPOSITORY"
+	case artifactregistrypb.Repository_VIRTUAL_REPOSITORY:
+		result = "VIRTUAL_REPOSITORY"
+	case artifactregistrypb.Repository_REMOTE_REPOSITORY:
+		result = "REMOTE_REPOSITORY"
+	default:
+		result = "STANDARD_REPOSITORY"
+	}
+	return &result
+}
+
+// ToProto functions for writing to GCP
+
+func ArtifactRegistryRepositoryObservedState_FromProto(mapCtx *direct.MapContext, in *artifactregistrypb.Repository) *krm.ArtifactRegistryRepositoryObservedState {
+	if in == nil {
+		return nil
+	}
+	out := &krm.ArtifactRegistryRepositoryObservedState{}
+
+	if in.CreateTime != nil {
+		out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.CreateTime)
+	}
+	if in.UpdateTime != nil {
+		out.UpdateTime = direct.StringTimestamp_FromProto(mapCtx, in.UpdateTime)
+	}
+	// Extract repository name from the full resource name
+	// Format: projects/[project]/locations/[location]/repositories/[repository_id]
+	if in.Name != "" {
+		// Simple extraction from the resource path
+		parts := strings.Split(in.Name, "/")
+		if len(parts) >= 6 && parts[4] == "repositories" {
+			repositoryName := parts[5]
+			out.Name = &repositoryName
+		}
+	}
+
+	return out
+}
+
+func ArtifactRegistryRepositorySpec_ToProto(mapCtx *direct.MapContext, in *krm.ArtifactRegistryRepositorySpec) *artifactregistrypb.Repository {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.Repository{}
+
+	// Convert format
+	out.Format = Repository_Format_ToProto(mapCtx, in.Format)
+
+	// Convert description
+	out.Description = direct.ValueOf(in.Description)
+
+	// Convert mode
+	out.Mode = Repository_Mode_ToProto(mapCtx, in.Mode)
+
+	// Convert cleanup policies
+	if len(in.CleanupPolicies) > 0 {
+		out.CleanupPolicies = make(map[string]*artifactregistrypb.CleanupPolicy)
+		for _, cleanupPolicy := range in.CleanupPolicies {
+			out.CleanupPolicies[cleanupPolicy.Id] = CleanupPolicy_ToProto(mapCtx, &cleanupPolicy)
+		}
+	}
+
+	// Convert cleanup policy dry run
+	out.CleanupPolicyDryRun = direct.ValueOf(in.CleanupPolicyDryRun)
+
+	// Convert KMS key reference
+	if in.KmsKeyRef != nil {
+		out.KmsKeyName = in.KmsKeyRef.External
+	}
+
+	// Convert Docker config
+	if in.DockerConfig != nil {
+		out.FormatConfig = &artifactregistrypb.Repository_DockerConfig{
+			DockerConfig: DockerConfig_ToProto(mapCtx, in.DockerConfig),
+		}
+	}
+
+	// Convert Maven config
+	if in.MavenConfig != nil {
+		out.FormatConfig = &artifactregistrypb.Repository_MavenConfig{
+			MavenConfig: MavenConfig_ToProto(mapCtx, in.MavenConfig),
+		}
+	}
+
+	// Convert virtual repository config
+	if in.VirtualRepositoryConfig != nil {
+		out.ModeConfig = &artifactregistrypb.Repository_VirtualRepositoryConfig{
+			VirtualRepositoryConfig: VirtualRepositoryConfig_ToProto(mapCtx, in.VirtualRepositoryConfig),
+		}
+	}
+
+	// Convert remote repository config
+	if in.RemoteRepositoryConfig != nil {
+		out.ModeConfig = &artifactregistrypb.Repository_RemoteRepositoryConfig{
+			RemoteRepositoryConfig: RemoteRepositoryConfig_ToProto(mapCtx, in.RemoteRepositoryConfig),
+		}
+	}
+
+	return out
+}
+
+func Repository_Format_ToProto(mapCtx *direct.MapContext, format string) artifactregistrypb.Repository_Format {
+	switch format {
+	case "DOCKER":
+		return artifactregistrypb.Repository_DOCKER
+	case "MAVEN":
+		return artifactregistrypb.Repository_MAVEN
+	case "NPM":
+		return artifactregistrypb.Repository_NPM
+	case "APT":
+		return artifactregistrypb.Repository_APT
+	case "YUM":
+		return artifactregistrypb.Repository_YUM
+	case "PYTHON":
+		return artifactregistrypb.Repository_PYTHON
+	case "KFP":
+		return artifactregistrypb.Repository_KFP
+	case "GO":
+		return artifactregistrypb.Repository_GO
+	case "GENERIC":
+		return artifactregistrypb.Repository_GENERIC
+	default:
+		mapCtx.Errorf("unknown format: %s", format)
+		return artifactregistrypb.Repository_FORMAT_UNSPECIFIED
+	}
+}
+
+func Repository_Mode_ToProto(mapCtx *direct.MapContext, mode *string) artifactregistrypb.Repository_Mode {
+	if mode == nil {
+		return artifactregistrypb.Repository_STANDARD_REPOSITORY // Default mode
+	}
+	switch *mode {
+	case "STANDARD_REPOSITORY":
+		return artifactregistrypb.Repository_STANDARD_REPOSITORY
+	case "VIRTUAL_REPOSITORY":
+		return artifactregistrypb.Repository_VIRTUAL_REPOSITORY
+	case "REMOTE_REPOSITORY":
+		return artifactregistrypb.Repository_REMOTE_REPOSITORY
+	default:
+		mapCtx.Errorf("unknown mode: %s", *mode)
+		return artifactregistrypb.Repository_STANDARD_REPOSITORY
+	}
+}
+
+func CleanupPolicy_ToProto(mapCtx *direct.MapContext, in *krm.CleanupPolicies) *artifactregistrypb.CleanupPolicy {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.CleanupPolicy{}
+
+	// Set the ID
+	out.Id = in.Id
+
+	// Convert action
+	if in.Action != nil {
+		switch *in.Action {
+		case "DELETE":
+			out.Action = artifactregistrypb.CleanupPolicy_DELETE
+		case "KEEP":
+			out.Action = artifactregistrypb.CleanupPolicy_KEEP
+		default:
+			mapCtx.Errorf("unknown cleanup policy action: %s", *in.Action)
+		}
+	}
+
+	// Convert condition (oneof)
+	if in.Condition != nil {
+		out.ConditionType = &artifactregistrypb.CleanupPolicy_Condition{
+			Condition: CleanupPolicyCondition_ToProto(mapCtx, in.Condition),
+		}
+	}
+
+	// Convert most recent versions (oneof)
+	if in.MostRecentVersions != nil {
+		out.ConditionType = &artifactregistrypb.CleanupPolicy_MostRecentVersions{
+			MostRecentVersions: CleanupPolicyMostRecentVersions_ToProto(mapCtx, in.MostRecentVersions),
+		}
+	}
+
+	return out
+}
+
+func CleanupPolicyCondition_ToProto(mapCtx *direct.MapContext, in *krm.CleanupPolicyCondition) *artifactregistrypb.CleanupPolicyCondition {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.CleanupPolicyCondition{}
+
+	// Convert tag state
+	if in.TagState != nil {
+		var tagState artifactregistrypb.CleanupPolicyCondition_TagState
+		switch *in.TagState {
+		case "TAGGED":
+			tagState = artifactregistrypb.CleanupPolicyCondition_TAGGED
+		case "UNTAGGED":
+			tagState = artifactregistrypb.CleanupPolicyCondition_UNTAGGED
+		case "ANY":
+			tagState = artifactregistrypb.CleanupPolicyCondition_TAG_STATE_UNSPECIFIED
+		default:
+			mapCtx.Errorf("unknown tag state: %s", *in.TagState)
+			tagState = artifactregistrypb.CleanupPolicyCondition_TAG_STATE_UNSPECIFIED
+		}
+		out.TagState = &tagState
+	}
+
+	// Convert durations
+	if in.NewerThan != nil {
+		out.NewerThan = direct.Duration_ToProto(mapCtx, in.NewerThan)
+	}
+	if in.OlderThan != nil {
+		out.OlderThan = direct.Duration_ToProto(mapCtx, in.OlderThan)
+	}
+
+	// Convert string slices
+	out.PackageNamePrefixes = in.PackageNamePrefixes
+	out.TagPrefixes = in.TagPrefixes
+	out.VersionNamePrefixes = in.VersionNamePrefixes
+
+	return out
+}
+
+func CleanupPolicyMostRecentVersions_ToProto(mapCtx *direct.MapContext, in *krm.CleanupPolicyMostRecentVersions) *artifactregistrypb.CleanupPolicyMostRecentVersions {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.CleanupPolicyMostRecentVersions{}
+
+	if in.KeepCount != nil {
+		keepCount := int32(*in.KeepCount)
+		out.KeepCount = &keepCount
+	}
+	out.PackageNamePrefixes = in.PackageNamePrefixes
+
+	return out
+}
+
+func DockerConfig_ToProto(mapCtx *direct.MapContext, in *krm.DockerConfig) *artifactregistrypb.Repository_DockerRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.Repository_DockerRepositoryConfig{}
+
+	if in.ImmutableTags != nil {
+		out.ImmutableTags = *in.ImmutableTags
+	}
+
+	return out
+}
+
+func MavenConfig_ToProto(mapCtx *direct.MapContext, in *krm.MavenConfig) *artifactregistrypb.Repository_MavenRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.Repository_MavenRepositoryConfig{}
+
+	if in.AllowSnapshotOverwrites != nil {
+		out.AllowSnapshotOverwrites = *in.AllowSnapshotOverwrites
+	}
+
+	if in.VersionPolicy != nil {
+		switch *in.VersionPolicy {
+		case "VERSION_POLICY_UNSPECIFIED":
+			out.VersionPolicy = artifactregistrypb.Repository_MavenRepositoryConfig_VERSION_POLICY_UNSPECIFIED
+		case "RELEASE":
+			out.VersionPolicy = artifactregistrypb.Repository_MavenRepositoryConfig_RELEASE
+		case "SNAPSHOT":
+			out.VersionPolicy = artifactregistrypb.Repository_MavenRepositoryConfig_SNAPSHOT
+		default:
+			mapCtx.Errorf("unknown version policy: %s", *in.VersionPolicy)
+		}
+	}
+
+	return out
+}
+
+func VirtualRepositoryConfig_ToProto(mapCtx *direct.MapContext, in *krm.VirtualRepositoryConfig) *artifactregistrypb.VirtualRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.VirtualRepositoryConfig{}
+
+	for _, upstreamPolicy := range in.UpstreamPolicies {
+		out.UpstreamPolicies = append(out.UpstreamPolicies, UpstreamPolicy_ToProto(mapCtx, &upstreamPolicy))
+	}
+
+	return out
+}
+
+func UpstreamPolicy_ToProto(mapCtx *direct.MapContext, in *krm.UpstreamPolicy) *artifactregistrypb.UpstreamPolicy {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.UpstreamPolicy{}
+
+	if in.Id != nil {
+		out.Id = *in.Id
+	}
+	if in.Priority != nil {
+		out.Priority = int32(*in.Priority)
+	}
+	if in.RepositoryRef != nil {
+		out.Repository = in.RepositoryRef.External
+	}
+
+	return out
+}
+
+func RemoteRepositoryConfig_ToProto(mapCtx *direct.MapContext, in *krm.RemoteRepositoryConfig) *artifactregistrypb.RemoteRepositoryConfig {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.RemoteRepositoryConfig{}
+
+	if in.Description != nil {
+		out.Description = *in.Description
+	}
+
+	// Convert specific repository configurations
+	if in.DockerRepository != nil {
+		out.RemoteSource = &artifactregistrypb.RemoteRepositoryConfig_DockerRepository_{
+			DockerRepository: DockerRepository_ToProto(mapCtx, in.DockerRepository),
+		}
+	}
+	if in.MavenRepository != nil {
+		out.RemoteSource = &artifactregistrypb.RemoteRepositoryConfig_MavenRepository_{
+			MavenRepository: MavenRepository_ToProto(mapCtx, in.MavenRepository),
+		}
+	}
+	if in.NpmRepository != nil {
+		out.RemoteSource = &artifactregistrypb.RemoteRepositoryConfig_NpmRepository_{
+			NpmRepository: NpmRepository_ToProto(mapCtx, in.NpmRepository),
+		}
+	}
+	if in.PythonRepository != nil {
+		out.RemoteSource = &artifactregistrypb.RemoteRepositoryConfig_PythonRepository_{
+			PythonRepository: PythonRepository_ToProto(mapCtx, in.PythonRepository),
+		}
+	}
+
+	return out
+}
+
+func DockerRepository_ToProto(mapCtx *direct.MapContext, in *krm.DockerRepository) *artifactregistrypb.RemoteRepositoryConfig_DockerRepository {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.RemoteRepositoryConfig_DockerRepository{}
+
+	if in.PublicRepository != nil {
+		var publicRepo artifactregistrypb.RemoteRepositoryConfig_DockerRepository_PublicRepository
+		switch *in.PublicRepository {
+		case "DOCKER_HUB":
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_DockerRepository_DOCKER_HUB
+		default:
+			mapCtx.Errorf("unknown Docker public repository: %s", *in.PublicRepository)
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_DockerRepository_PUBLIC_REPOSITORY_UNSPECIFIED
+		}
+		out.Upstream = &artifactregistrypb.RemoteRepositoryConfig_DockerRepository_PublicRepository_{
+			PublicRepository: publicRepo,
+		}
+	}
+
+	return out
+}
+
+func MavenRepository_ToProto(mapCtx *direct.MapContext, in *krm.MavenRepository) *artifactregistrypb.RemoteRepositoryConfig_MavenRepository {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.RemoteRepositoryConfig_MavenRepository{}
+
+	if in.PublicRepository != nil {
+		var publicRepo artifactregistrypb.RemoteRepositoryConfig_MavenRepository_PublicRepository
+		switch *in.PublicRepository {
+		case "MAVEN_CENTRAL":
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_MavenRepository_MAVEN_CENTRAL
+		default:
+			mapCtx.Errorf("unknown Maven public repository: %s", *in.PublicRepository)
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_MavenRepository_PUBLIC_REPOSITORY_UNSPECIFIED
+		}
+		out.Upstream = &artifactregistrypb.RemoteRepositoryConfig_MavenRepository_PublicRepository_{
+			PublicRepository: publicRepo,
+		}
+	}
+
+	return out
+}
+
+func NpmRepository_ToProto(mapCtx *direct.MapContext, in *krm.NpmRepository) *artifactregistrypb.RemoteRepositoryConfig_NpmRepository {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.RemoteRepositoryConfig_NpmRepository{}
+
+	if in.PublicRepository != nil {
+		var publicRepo artifactregistrypb.RemoteRepositoryConfig_NpmRepository_PublicRepository
+		switch *in.PublicRepository {
+		case "NPMJS":
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_NpmRepository_NPMJS
+		default:
+			mapCtx.Errorf("unknown NPM public repository: %s", *in.PublicRepository)
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_NpmRepository_PUBLIC_REPOSITORY_UNSPECIFIED
+		}
+		out.Upstream = &artifactregistrypb.RemoteRepositoryConfig_NpmRepository_PublicRepository_{
+			PublicRepository: publicRepo,
+		}
+	}
+
+	return out
+}
+
+func PythonRepository_ToProto(mapCtx *direct.MapContext, in *krm.PythonRepository) *artifactregistrypb.RemoteRepositoryConfig_PythonRepository {
+	if in == nil {
+		return nil
+	}
+	out := &artifactregistrypb.RemoteRepositoryConfig_PythonRepository{}
+
+	if in.PublicRepository != nil {
+		var publicRepo artifactregistrypb.RemoteRepositoryConfig_PythonRepository_PublicRepository
+		switch *in.PublicRepository {
+		case "PYPI":
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_PythonRepository_PYPI
+		default:
+			mapCtx.Errorf("unknown Python public repository: %s", *in.PublicRepository)
+			publicRepo = artifactregistrypb.RemoteRepositoryConfig_PythonRepository_PUBLIC_REPOSITORY_UNSPECIFIED
+		}
+		out.Upstream = &artifactregistrypb.RemoteRepositoryConfig_PythonRepository_PublicRepository_{
+			PublicRepository: publicRepo,
+		}
+	}
+
+	return out
+}
diff --git a/pkg/controller/direct/artifactregistry/roundtrip_test.go b/pkg/controller/direct/artifactregistry/roundtrip_test.go
new file mode 100644
index 000000000..e86d60aa5
--- /dev/null
+++ b/pkg/controller/direct/artifactregistry/roundtrip_test.go
@@ -0,0 +1,372 @@
+// Copyright 2024 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package artifactregistry
+
+import (
+	"fmt"
+	"math/rand"
+	"testing"
+
+	pb "cloud.google.com/go/artifactregistry/apiv1/artifactregistrypb"
+
+	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
+	"github.com/google/go-cmp/cmp"
+	"google.golang.org/protobuf/encoding/prototext"
+	"google.golang.org/protobuf/proto"
+	"google.golang.org/protobuf/reflect/protoreflect"
+	"google.golang.org/protobuf/testing/protocmp"
+	"k8s.io/apimachinery/pkg/util/sets"
+	"k8s.io/klog/v2"
+)
+
+func FuzzArtifactRegistryRepositorySpec(f *testing.F) {
+	f.Fuzz(func(t *testing.T, seed int64) {
+		randStream := rand.New(rand.NewSource(seed))
+
+		p1 := &pb.Repository{}
+		fillWithRandom(t, randStream, p1)
+
+		// We don't expect output fields to round-trip
+		outputFields := sets.New(".etag")
+
+		// A few fields are not implemented yet in KRM, don't test them
+		unimplementedFields := sets.New(
+			".name",
+		)
+
+		// Status fields
+		unimplementedFields.Insert(".create_time")
+		unimplementedFields.Insert(".update_time")
+		unimplementedFields.Insert(".size_bytes")
+
+		// Remove any output only or known-unimplemented fields
+		clearFields := &ClearFields{
+			Paths: unimplementedFields.Union(outputFields),
+		}
+		visit("", p1.ProtoReflect(), nil, clearFields)
+
+		r := &ReplaceFields{}
+		r.Func = func(path string, val protoreflect.Value) (protoreflect.Value, bool) {
+			// TODO: Any values that must follow a pattern
+			return protoreflect.Value{}, false
+		}
+		visit("", p1.ProtoReflect(), nil, r)
+
+		ctx := &direct.MapContext{}
+		k := ArtifactRegistryRepositorySpec_FromProto(ctx, p1)
+		if ctx.Err() != nil {
+			t.Fatalf("error mapping from proto to krm: %v", ctx.Err())
+		}
+
+		p2 := ArtifactRegistryRepositorySpec_ToProto(ctx, k)
+		if ctx.Err() != nil {
+			t.Fatalf("error mapping from krm to proto: %v", ctx.Err())
+		}
+
+		if diff := cmp.Diff(p1, p2, protocmp.Transform()); diff != "" {
+			t.Logf("p1 = %v", prototext.Format(p1))
+			t.Logf("p2 = %v", prototext.Format(p2))
+			t.Errorf("roundtrip failed; diff:\n%s", diff)
+		}
+	})
+}
+
+func fillWithRandom(t *testing.T, randStream *rand.Rand, msg proto.Message) {
+	fillWithRandom0(t, randStream, msg.ProtoReflect())
+}
+
+func fillWithRandom0(t *testing.T, randStream *rand.Rand, msg protoreflect.Message) {
+	descriptor := msg.Descriptor()
+	if string(descriptor.FullName()) == "google.protobuf.Duration" {
+		count := randStream.Intn(10)
+		// Bias to zero
+		if count > 4 {
+			return
+		}
+		seconds := randStream.Intn(365 * 24 * 60 * 60)
+		nanos := randStream.Intn(1000000000)
+		msg.Set(descriptor.Fields().ByName("seconds"), protoreflect.ValueOfInt32(int32(seconds)))
+		msg.Set(descriptor.Fields().ByName("nanos"), protoreflect.ValueOfInt32(int32(nanos)))
+		return
+	}
+
+	fields := descriptor.Fields()
+	n := fields.Len()
+	for i := 0; i < n; i++ {
+		field := fields.Get(i)
+
+		if field.IsList() {
+			count := randStream.Intn(10)
+			// Bias heavily to zero
+			if count > 4 {
+				count = 0
+			}
+			listVal := msg.Mutable(field).List()
+			switch field.Kind() {
+			case protoreflect.MessageKind:
+				for j := 0; j < count; j++ {
+					el := listVal.AppendMutable()
+					fillWithRandom0(t, randStream, el.Message())
+				}
+			case protoreflect.StringKind:
+				for j := 0; j < count; j++ {
+					s := randomString(randStream)
+					listVal.Append(protoreflect.ValueOf(s))
+				}
+
+			default:
+				t.Fatalf("unhandled field kind %v: %v", field.Kind(), field)
+			}
+			continue
+		}
+
+		if field.IsMap() {
+			count := randStream.Intn(10)
+			// Bias heavily to zero
+			if count > 4 {
+				count = 0
+			}
+			mapType := fmt.Sprintf("%s->%s", field.MapKey().Kind(), field.MapValue().Kind())
+			switch mapType {
+			case "string->string":
+				mapVal := msg.Mutable(field).Map()
+				for j := 0; j < count; j++ {
+					k := randomString(randStream)
+					v := randomString(randStream)
+					mapVal.Set(protoreflect.ValueOf(k).MapKey(), protoreflect.ValueOf(v))
+				}
+
+			default:
+				t.Fatalf("unhandled map kind %q: %v", mapType, field)
+			}
+			continue
+		}
+
+		if field.Cardinality() == protoreflect.Optional {
+			if randStream.Intn(3) < 2 {
+				continue
+			}
+		}
+
+		switch field.Kind() {
+		case protoreflect.MessageKind:
+			fieldVal := msg.Mutable(field)
+			fillWithRandom0(t, randStream, fieldVal.Message())
+
+		case protoreflect.BoolKind:
+			msg.Set(field, protoreflect.ValueOfBool(randStream.Intn(2) == 1))
+
+		case protoreflect.DoubleKind:
+			msg.Set(field, protoreflect.ValueOfFloat64(randStream.NormFloat64()))
+		case protoreflect.Int32Kind:
+			msg.Set(field, protoreflect.ValueOfInt32(randStream.Int31()))
+		case protoreflect.Int64Kind:
+			msg.Set(field, protoreflect.ValueOfInt64(randStream.Int63()))
+		case protoreflect.StringKind:
+			s := randomString(randStream)
+			msg.Set(field, protoreflect.ValueOfString(s))
+		case protoreflect.EnumKind:
+			fieldDescriptor := field.Enum()
+			n := fieldDescriptor.Values().Len()
+			val := fieldDescriptor.Values().Get(randStream.Intn(n))
+			msg.Set(field, protoreflect.ValueOf(val.Number()))
+		default:
+			t.Fatalf("unhandled field kind %v: %v", field.Kind(), field)
+		}
+	}
+}
+
+func randomString(randStream *rand.Rand) string {
+	// TODO: This is not a good random string!
+	return fmt.Sprintf("%x", randStream.Int63())
+}
+
+type ProtoVisitor interface {
+	VisitPrimitive(path string, val protoreflect.Value, setter func(v protoreflect.Value))
+	VisitMessage(path string, msg protoreflect.Message, setter func(v protoreflect.Value))
+	VisitList(path string, msg protoreflect.List, setter func(v protoreflect.Value))
+	VisitMap(path string, msg protoreflect.Map, setter func(v protoreflect.Value))
+}
+
+type ProtoVisitorBase struct {
+}
+
+func (v *ProtoVisitorBase) VisitPrimitive(path string, val protoreflect.Value, setter func(v protoreflect.Value)) {
+
+}
+
+func (v *ProtoVisitorBase) VisitMessage(path string, msg protoreflect.Message, setter func(v protoreflect.Value)) {
+}
+
+func (v *ProtoVisitorBase) VisitList(path string, msg protoreflect.List, setter func(v protoreflect.Value)) {
+}
+
+func (v *ProtoVisitorBase) VisitMap(path string, msg protoreflect.Map, setter func(v protoreflect.Value)) {
+}
+
+var _ ProtoVisitor = &ProtoVisitorBase{}
+
+type ClearFields struct {
+	ProtoVisitorBase
+
+	Paths sets.Set[string]
+}
+
+func (v *ClearFields) VisitPrimitive(path string, val protoreflect.Value, setter func(v protoreflect.Value)) {
+	if v.Paths.Has(path) {
+		setter(protoreflect.Value{})
+	}
+}
+
+func (v *ClearFields) VisitMessage(path string, msg protoreflect.Message, setter func(v protoreflect.Value)) {
+	if v.Paths.Has(path) {
+		setter(protoreflect.Value{})
+	}
+}
+
+func (v *ClearFields) VisitList(path string, msg protoreflect.List, setter func(v protoreflect.Value)) {
+	if v.Paths.Has(path) {
+		setter(protoreflect.Value{})
+	}
+}
+
+func (v *ClearFields) VisitMap(path string, msg protoreflect.Map, setter func(v protoreflect.Value)) {
+	if v.Paths.Has(path) {
+		setter(protoreflect.Value{})
+	}
+}
+
+var _ ProtoVisitor = &ClearFields{}
+
+type ReplaceFields struct {
+	ProtoVisitorBase
+
+	Func func(path string, val protoreflect.Value) (protoreflect.Value, bool)
+}
+
+func (v *ReplaceFields) VisitPrimitive(path string, val protoreflect.Value, setter func(v protoreflect.Value)) {
+	if newVal, ok := v.Func(path, val); ok {
+		setter(newVal)
+	}
+}
+
+var _ ProtoVisitor = &ClearFields{}
+
+func visit(msgPath string, msg protoreflect.Message, setter func(v protoreflect.Value), visitor ProtoVisitor) {
+	visitor.VisitMessage(msgPath, msg, setter)
+	msg.Range(func(field protoreflect.FieldDescriptor, fieldVal protoreflect.Value) bool {
+		path := msgPath + "." + string(field.Name())
+		klog.Infof("visit %q", path)
+
+		if field.IsList() {
+			listVal := fieldVal.List()
+			setter := func(v protoreflect.Value) {
+				if v.IsValid() {
+					msg.Set(field, v)
+				} else {
+					msg.Clear(field)
+				}
+			}
+			visitor.VisitList(path, listVal, setter)
+			count := listVal.Len()
+			switch field.Kind() {
+			case protoreflect.MessageKind:
+				for j := 0; j < count; j++ {
+					el := listVal.Get(j)
+					setter := func(v protoreflect.Value) {
+						listVal.Set(j, v)
+					}
+					visit(path+"[]", el.Message(), setter, visitor)
+				}
+			case protoreflect.StringKind:
+				for j := 0; j < count; j++ {
+					el := listVal.Get(j)
+					setter := func(v protoreflect.Value) {
+						listVal.Set(j, v)
+					}
+					visitor.VisitPrimitive(path+"[]", el, setter)
+				}
+
+			default:
+				klog.Fatalf("unhandled field kind %v: %v", field.Kind(), field)
+			}
+			return true
+		}
+
+		if field.IsMap() {
+			mapType := fmt.Sprintf("%s->%s", field.MapKey().Kind(), field.MapValue().Kind())
+			switch mapType {
+			case "string->string":
+				mapVal := msg.Mutable(field).Map()
+				setter := func(v protoreflect.Value) {
+					if v.IsValid() {
+						msg.Set(field, v)
+					} else {
+						msg.Clear(field)
+					}
+				}
+				visitor.VisitMap(path, mapVal, setter)
+
+				// In case the value changes
+				mapVal = msg.Mutable(field).Map()
+				mapVal.Range(func(k protoreflect.MapKey, val protoreflect.Value) bool {
+					mapPath := path + "[" + k.String() + "]"
+					setter := func(v protoreflect.Value) {
+						mapVal.Set(k, v)
+					}
+					visitor.VisitPrimitive(mapPath, val, setter)
+					return true
+				})
+
+			default:
+				klog.Fatalf("unhandled map kind %q: %v", mapType, field)
+			}
+			return true
+		}
+
+		switch field.Kind() {
+		case protoreflect.MessageKind:
+			setter := func(v protoreflect.Value) {
+				if v.IsValid() {
+					msg.Set(field, v)
+				} else {
+					msg.Clear(field)
+				}
+			}
+			visit(path, fieldVal.Message(), setter, visitor)
+
+		case protoreflect.BoolKind,
+			protoreflect.DoubleKind,
+			protoreflect.Int32Kind,
+			protoreflect.Int64Kind,
+			protoreflect.StringKind,
+			protoreflect.EnumKind:
+			setter := func(v protoreflect.Value) {
+				if v.IsValid() {
+					msg.Set(field, v)
+				} else {
+					msg.Clear(field)
+				}
+			}
+			visitor.VisitPrimitive(path, fieldVal, setter)
+
+		default:
+			klog.Fatalf("unhandled field kind %v: %v", field.Kind(), field)
+		}
+
+		return true
+	})
+
+}
diff --git a/pkg/controller/direct/register/register.go b/pkg/controller/direct/register/register.go
index 58cf86830..86f9eb0b2 100644
--- a/pkg/controller/direct/register/register.go
+++ b/pkg/controller/direct/register/register.go
@@ -20,6 +20,7 @@ import (
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/apigee"
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/apikeys"
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/apphub"
+	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/artifactregistry"
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/asset"
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/backupdr"
 	_ "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct/batch"
diff --git a/pkg/controller/resourceconfig/static_config.go b/pkg/controller/resourceconfig/static_config.go
index fc38821a1..2dd341eba 100644
--- a/pkg/controller/resourceconfig/static_config.go
+++ b/pkg/controller/resourceconfig/static_config.go
@@ -52,7 +52,7 @@ var ControllerConfigStatic = &ResourcesControllerMap{
 	{Group: "appengine.cnrm.cloud.google.com", Kind: "AppEngineServiceSplitTraffic"}:                            {DefaultController: k8s.ReconcilerTypeTerraform, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeTerraform}},
 	{Group: "appengine.cnrm.cloud.google.com", Kind: "AppEngineStandardAppVersion"}:                             {DefaultController: k8s.ReconcilerTypeTerraform, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeTerraform}},
 	{Group: "apphub.cnrm.cloud.google.com", Kind: "AppHubApplication"}:                                          {DefaultController: k8s.ReconcilerTypeDirect, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeDirect}},
-	{Group: "artifactregistry.cnrm.cloud.google.com", Kind: "ArtifactRegistryRepository"}:                       {DefaultController: k8s.ReconcilerTypeTerraform, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeTerraform}},
+	{Group: "artifactregistry.cnrm.cloud.google.com", Kind: "ArtifactRegistryRepository"}:                       {DefaultController: k8s.ReconcilerTypeDirect, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeTerraform, k8s.ReconcilerTypeDirect}},
 	{Group: "asset.cnrm.cloud.google.com", Kind: "AssetFeed"}:                                                   {DefaultController: k8s.ReconcilerTypeDirect, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeDirect}},
 	{Group: "asset.cnrm.cloud.google.com", Kind: "AssetSavedQuery"}:                                             {DefaultController: k8s.ReconcilerTypeDirect, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeDirect}},
 	{Group: "backupdr.cnrm.cloud.google.com", Kind: "BackupDRBackupPlan"}:                                       {DefaultController: k8s.ReconcilerTypeDirect, SupportedControllers: []k8s.ReconcilerType{k8s.ReconcilerTypeDirect}},
diff --git a/pkg/gvks/supportedgvks/gvks_generated.go b/pkg/gvks/supportedgvks/gvks_generated.go
index 4f904fb8e..6a783e112 100644
--- a/pkg/gvks/supportedgvks/gvks_generated.go
+++ b/pkg/gvks/supportedgvks/gvks_generated.go
@@ -224,14 +224,6 @@ var legacyGVKs = map[schema.GroupVersionKind]legacyGVKData{
 		Terraform: true,
 		DCL:       false,
 	},
-	{
-		Group:   "artifactregistry.cnrm.cloud.google.com",
-		Version: "v1beta1",
-		Kind:    "ArtifactRegistryRepository",
-	}: {
-		Terraform: true,
-		DCL:       false,
-	},
 	{
 		Group:   "beyondcorp.cnrm.cloud.google.com",
 		Version: "v1alpha1",
diff --git a/pkg/test/fuzz/generate.go b/pkg/test/fuzz/generate.go
index 9d8ec976d..fdf39419b 100644
--- a/pkg/test/fuzz/generate.go
+++ b/pkg/test/fuzz/generate.go
@@ -54,7 +54,11 @@ func fillWithRandom0(t *testing.T, randStream *rand.Rand, msg protoreflect.Messa
 			return
 		}
 		// Generate a "reasonable" timestamp; huge values are out of range of golang time types
-		seconds := (1900 * 365 * 24 * 60 * 60) + randStream.Intn(400*365*24*60*60)
+		baseSeconds := int64(1900) * 365 * 24 * 60 * 60
+		maxRandomDays := 400 * 365 // Max days to add
+		randomDays := randStream.Intn(maxRandomDays)
+		randomSeconds := int64(randomDays) * 24 * 60 * 60
+		seconds := baseSeconds + randomSeconds
 		nanos := randStream.Intn(1000000000)
 		msg.Set(descriptor.Fields().ByName("seconds"), protoreflect.ValueOfInt64(int64(seconds)))
 		msg.Set(descriptor.Fields().ByName("nanos"), protoreflect.ValueOfInt32(int32(nanos)))
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/create.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/create.yaml
new file mode 100644
index 000000000..6bcb0ab40
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/create.yaml
@@ -0,0 +1,48 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+    env: "test"
+spec:
+  resourceID: arrepository-full-${uniqueId}
+  description: "full configuration test repository"
+  format: DOCKER
+  location: us-west1
+  mode: STANDARD_REPOSITORY
+  dockerConfig:
+    immutableTags: true
+  cleanupPolicyDryRun: true
+  cleanupPolicies:
+    - id: "delete-old-versions"
+      action: DELETE
+      condition:
+        olderThan: "30d"
+        tagState: UNTAGGED
+    - id: "keep-recent-releases"  
+      action: KEEP
+      condition:
+        tagPrefixes:
+          - "release-"
+        newerThan: "7d"
+      mostRecentVersions:
+        keepCount: 5
+        packageNamePrefixes:
+          - "prod/"
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/update.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/update.yaml
new file mode 100644
index 000000000..da733bdcb
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-full/update.yaml
@@ -0,0 +1,50 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+    env: "test"
+spec:
+  resourceID: arrepository-full-${uniqueId}
+  description: "updated full configuration test repository"
+  format: DOCKER
+  location: us-west1
+  mode: STANDARD_REPOSITORY
+  dockerConfig:
+    immutableTags: false
+  cleanupPolicyDryRun: false
+  cleanupPolicies:
+    - id: "delete-old-versions"
+      action: DELETE
+      condition:
+        olderThan: "60d"
+        tagState: UNTAGGED
+    - id: "keep-recent-releases"  
+      action: KEEP
+      condition:
+        tagPrefixes:
+          - "release-"
+          - "stable-"
+        newerThan: "14d"
+      mostRecentVersions:
+        keepCount: 10
+        packageNamePrefixes:
+          - "prod/"
+          - "staging/"
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/create.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/create.yaml
new file mode 100644
index 000000000..d1657dafa
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/create.yaml
@@ -0,0 +1,25 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+spec:
+  format: DOCKER
+  location: us-west1
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/update.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/update.yaml
new file mode 100644
index 000000000..1acb72de6
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-minimal/update.yaml
@@ -0,0 +1,26 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+spec:
+  description: updated minimal repository description
+  format: DOCKER
+  location: us-west1
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/create.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/create.yaml
new file mode 100644
index 000000000..747386543
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/create.yaml
@@ -0,0 +1,38 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+    label-one: "value-one"
+spec:
+  description: "virtual repository for testing"
+  format: DOCKER
+  location: us-west1
+  mode: VIRTUAL_REPOSITORY
+  virtualRepositoryConfig:
+    upstreamPolicies:
+      - id: "upstream-repo"
+        priority: 1
+        repositoryRef:
+          name: arrepository-${uniqueId}-2
+      - id: "backup-repo"
+        priority: 2
+        repositoryRef:
+          external: "projects/${projectId}/locations/us-west1/repositories/public-backup"
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/dependencies.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/dependencies.yaml
new file mode 100644
index 000000000..613794aa4
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/dependencies.yaml
@@ -0,0 +1,25 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}-2
+  labels:
+    label-one: "value-two"
+spec:
+  format: DOCKER
+  location: us-west1
\ No newline at end of file
diff --git a/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/update.yaml b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/update.yaml
new file mode 100644
index 000000000..e8db31914
--- /dev/null
+++ b/pkg/test/resourcefixture/testdata/basic/artifactregistry/v1beta1/artifactregistryrepository/artifactregistryrepository-virtual/update.yaml
@@ -0,0 +1,42 @@
+# Copyright 2024 Google LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: artifactregistry.cnrm.cloud.google.com/v1beta1
+kind: ArtifactRegistryRepository
+metadata:
+  annotations:
+    cnrm.cloud.google.com/project-id: "${projectId}"
+  name: arrepository-${uniqueId}
+  labels:
+    cnrm-test: "true"
+    label-one: "value-one"
+spec:
+  description: "updated virtual repository for testing"
+  format: DOCKER
+  location: us-west1
+  mode: VIRTUAL_REPOSITORY
+  virtualRepositoryConfig:
+    upstreamPolicies:
+      - id: "upstream-repo"
+        priority: 1
+        repositoryRef:
+          name: arrepository-${uniqueId}-2
+      - id: "backup-repo"
+        priority: 3
+        repositoryRef:
+          external: "projects/${projectId}/locations/us-west1/repositories/public-backup"
+      - id: "additional-repo"
+        priority: 2
+        repositoryRef:
+          external: "projects/${projectId}/locations/us-west1/repositories/additional-source"
\ No newline at end of file
