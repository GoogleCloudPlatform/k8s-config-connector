// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1alpha1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type OccurrenceAttestation struct {
	/* The serialized payload that is verified by one or
	more signatures. A base64-encoded string. */
	SerializedPayload string `json:"serializedPayload"`

	/* One or more signatures over serializedPayload.
	Verifier implementations should consider this attestation
	message verified if at least one signature verifies
	serializedPayload. See Signature in common.proto for more
	details on signature structure and verification. */
	Signatures []OccurrenceSignatures `json:"signatures"`
}

type OccurrenceSignatures struct {
	/* The identifier for the public key that verifies this
	signature. MUST be an RFC3986 conformant
	URI. * When possible, the key id should be an
	immutable reference, such as a cryptographic digest.
	Examples of valid values:

	* OpenPGP V4 public key fingerprint. See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr
	for more details on this scheme.
	* 'openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA'
	* RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization):
	* "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU". */
	PublicKeyId string `json:"publicKeyId"`

	/* The content of the signature, an opaque bytestring.
	The payload that this signature verifies MUST be
	unambiguously provided with the Signature during
	verification. A wrapper message might provide the
	payload explicitly. Alternatively, a message might
	have a canonical serialization that can always be
	unambiguously computed to derive the payload. */
	// +optional
	Signature *string `json:"signature,omitempty"`
}

type ContainerAnalysisOccurrenceSpec struct {
	/* Occurrence that represents a single "attestation". The authenticity
	of an attestation can be verified using the attached signature.
	If the verifier trusts the public key of the signer, then verifying
	the signature is sufficient to establish trust. In this circumstance,
	the authority to which this attestation is attached is primarily
	useful for lookup (how to find this attestation if you already
	know the authority and artifact to be verified) and intent (for
	which authority this attestation was intended to sign. */
	Attestation OccurrenceAttestation `json:"attestation"`

	/* Immutable. The analysis note associated with this occurrence, in the form of
	projects/[PROJECT]/notes/[NOTE_ID]. This field can be used as a
	filter in list requests. */
	NoteName string `json:"noteName"`

	/* The project that this resource belongs to. */
	ProjectRef v1alpha1.ResourceRef `json:"projectRef"`

	/* A description of actions that can be taken to remedy the note. */
	// +optional
	Remediation *string `json:"remediation,omitempty"`

	/* Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource. */
	// +optional
	ResourceID *string `json:"resourceID,omitempty"`

	/* Immutable. Required. Immutable. A URI that represents the resource for which
	the occurrence applies. For example,
	https://gcr.io/project/image@sha256:123abc for a Docker image. */
	ResourceUri string `json:"resourceUri"`
}

type ContainerAnalysisOccurrenceStatus struct {
	/* Conditions represent the latest available observations of the
	   ContainerAnalysisOccurrence's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* The time when the repository was created. */
	// +optional
	CreateTime *string `json:"createTime,omitempty"`

	/* The note kind which explicitly denotes which of the occurrence
	details are specified. This field can be used as a filter in list
	requests. */
	// +optional
	Kind *string `json:"kind,omitempty"`

	/* The name of the occurrence. */
	// +optional
	Name *string `json:"name,omitempty"`

	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	// +optional
	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`

	/* The time when the repository was last updated. */
	// +optional
	UpdateTime *string `json:"updateTime,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:categories=gcp,shortName=gcpcontaineranalysisoccurrence;gcpcontaineranalysisoccurrences
// +kubebuilder:subresource:status
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/managed-by-kcc=true"
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/stability-level=alpha"
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/system=true"
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/tf2crd=true"
// +kubebuilder:printcolumn:name="Age",JSONPath=".metadata.creationTimestamp",type="date"
// +kubebuilder:printcolumn:name="Ready",JSONPath=".status.conditions[?(@.type=='Ready')].status",type="string",description="When 'True', the most recent reconcile of the resource succeeded"
// +kubebuilder:printcolumn:name="Status",JSONPath=".status.conditions[?(@.type=='Ready')].reason",type="string",description="The reason for the value in 'Ready'"
// +kubebuilder:printcolumn:name="Status Age",JSONPath=".status.conditions[?(@.type=='Ready')].lastTransitionTime",type="date",description="The last transition time for the value in 'Status'"

// ContainerAnalysisOccurrence is the Schema for the containeranalysis API
// +k8s:openapi-gen=true
type ContainerAnalysisOccurrence struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ContainerAnalysisOccurrenceSpec   `json:"spec,omitempty"`
	Status ContainerAnalysisOccurrenceStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ContainerAnalysisOccurrenceList contains a list of ContainerAnalysisOccurrence
type ContainerAnalysisOccurrenceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerAnalysisOccurrence `json:"items"`
}

func init() {
	SchemeBuilder.Register(&ContainerAnalysisOccurrence{}, &ContainerAnalysisOccurrenceList{})
}
