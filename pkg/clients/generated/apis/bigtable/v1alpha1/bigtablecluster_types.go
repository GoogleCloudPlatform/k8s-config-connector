// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1alpha1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ClusterAutoscalingLimits struct {
	/* Required. Maximum number of nodes to scale up to. */
	// +optional
	MaxServeNodes *int32 `json:"maxServeNodes,omitempty"`

	/* Required. Minimum number of nodes to scale down to. */
	// +optional
	MinServeNodes *int32 `json:"minServeNodes,omitempty"`
}

type ClusterAutoscalingTargets struct {
	/* The cpu utilization that the Autoscaler should be trying to achieve. This number is on a scale from 0 (no utilization) to 100 (total utilization), and is limited between 10 and 80, otherwise it will return INVALID_ARGUMENT error. */
	// +optional
	CpuUtilizationPercent *int32 `json:"cpuUtilizationPercent,omitempty"`

	/* The storage utilization that the Autoscaler should be trying to achieve. This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD cluster and between 8192 (8TiB) and 16384 (16TiB) for an HDD cluster, otherwise it will return INVALID_ARGUMENT error. If this value is set to 0, it will be treated as if it were set to the default value: 2560 for SSD, 8192 for HDD. */
	// +optional
	StorageUtilizationGiBPerNode *int32 `json:"storageUtilizationGiBPerNode,omitempty"`
}

type ClusterClusterAutoscalingConfig struct {
	/* Required. Autoscaling limits for this cluster. */
	// +optional
	AutoscalingLimits *ClusterAutoscalingLimits `json:"autoscalingLimits,omitempty"`

	/* Required. Autoscaling targets for this cluster. */
	// +optional
	AutoscalingTargets *ClusterAutoscalingTargets `json:"autoscalingTargets,omitempty"`
}

type ClusterClusterConfig struct {
	/* Autoscaling configuration for this cluster. */
	// +optional
	ClusterAutoscalingConfig *ClusterClusterAutoscalingConfig `json:"clusterAutoscalingConfig,omitempty"`
}

type ClusterEncryptionConfig struct {
	/* Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster. 3) All clusters within an instance must use the same CMEK key. Values are of the form `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}` */
	// +optional
	KmsKeyRef *v1alpha1.ResourceRef `json:"kmsKeyRef,omitempty"`
}

type BigtableClusterSpec struct {
	/* Configuration for this cluster. */
	// +optional
	ClusterConfig *ClusterClusterConfig `json:"clusterConfig,omitempty"`

	/* Immutable. The type of storage used by this cluster to serve its parent instance's tables, unless explicitly overridden. */
	// +optional
	DefaultStorageType *string `json:"defaultStorageType,omitempty"`

	/* Immutable. The encryption configuration for CMEK-protected clusters. */
	// +optional
	EncryptionConfig *ClusterEncryptionConfig `json:"encryptionConfig,omitempty"`

	/* InstanceRef defines the resource reference to BigtableInstance, which "External" field holds the GCP identifier for the KRM object. */
	InstanceRef v1alpha1.ResourceRef `json:"instanceRef"`

	/* Immutable. The location where this cluster's nodes and storage reside. For best performance, clients should be located as close as possible to this cluster. Currently only zones are supported, so values should be of the form `projects/{project}/locations/{zone}`. */
	// +optional
	Location *string `json:"location,omitempty"`

	/* Immutable. The node scaling factor of this cluster. */
	// +optional
	NodeScalingFactor *string `json:"nodeScalingFactor,omitempty"`

	/* The BigtableCluster name. If not given, the metadata.name will be used. */
	// +optional
	ResourceID *string `json:"resourceID,omitempty"`

	/* The number of nodes allocated to this cluster. More nodes enable higher throughput and more consistent performance. */
	// +optional
	ServeNodes *int32 `json:"serveNodes,omitempty"`
}

type ClusterObservedStateStatus struct {
	/* Output only. The current state of the cluster. */
	// +optional
	State *string `json:"state,omitempty"`
}

type BigtableClusterStatus struct {
	/* Conditions represent the latest available observations of the
	   BigtableCluster's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* A unique specifier for the BigtableCluster resource in GCP. */
	// +optional
	ExternalRef *string `json:"externalRef,omitempty"`

	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	// +optional
	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`

	/* ObservedState is the state of the resource as most recently observed in GCP. */
	// +optional
	ObservedState *ClusterObservedStateStatus `json:"observedState,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:categories=gcp,shortName=gcpbigtablecluster;gcpbigtableclusters
// +kubebuilder:subresource:status
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/managed-by-kcc=true"
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/system=true"
// +kubebuilder:printcolumn:name="Age",JSONPath=".metadata.creationTimestamp",type="date"
// +kubebuilder:printcolumn:name="Ready",JSONPath=".status.conditions[?(@.type=='Ready')].status",type="string",description="When 'True', the most recent reconcile of the resource succeeded"
// +kubebuilder:printcolumn:name="Status",JSONPath=".status.conditions[?(@.type=='Ready')].reason",type="string",description="The reason for the value in 'Ready'"
// +kubebuilder:printcolumn:name="Status Age",JSONPath=".status.conditions[?(@.type=='Ready')].lastTransitionTime",type="date",description="The last transition time for the value in 'Status'"

// BigtableCluster is the Schema for the bigtable API
// +k8s:openapi-gen=true
type BigtableCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   BigtableClusterSpec   `json:"spec,omitempty"`
	Status BigtableClusterStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// BigtableClusterList contains a list of BigtableCluster
type BigtableClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BigtableCluster `json:"items"`
}

func init() {
	SchemeBuilder.Register(&BigtableCluster{}, &BigtableClusterList{})
}
