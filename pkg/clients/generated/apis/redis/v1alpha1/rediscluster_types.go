// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1alpha1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ClusterAofConfig struct {
	/* Optional. fsync configuration. */
	// +optional
	AppendFsync *string `json:"appendFsync,omitempty"`
}

type ClusterPersistenceConfig struct {
	/* Optional. AOF configuration. This field will be ignored if mode is not AOF. */
	// +optional
	AofConfig *ClusterAofConfig `json:"aofConfig,omitempty"`

	/* Optional. The mode of persistence. */
	// +optional
	Mode *string `json:"mode,omitempty"`

	/* Optional. RDB configuration. This field will be ignored if mode is not RDB. */
	// +optional
	RdbConfig *ClusterRdbConfig `json:"rdbConfig,omitempty"`
}

type ClusterPscConfigs struct {
	/* Required. The network where the IP address of the discovery endpoint will be reserved, in the form of projects/{network_project}/global/networks/{network_id}. */
	NetworkRef v1alpha1.ResourceRef `json:"networkRef"`
}

type ClusterRdbConfig struct {
	/* Optional. Period between RDB snapshots. */
	// +optional
	RdbSnapshotPeriod *string `json:"rdbSnapshotPeriod,omitempty"`

	/* Optional. The time that the first snapshot was/will be attempted, and to which future snapshots will be aligned. If not provided, the current time will be used. */
	// +optional
	RdbSnapshotStartTime *string `json:"rdbSnapshotStartTime,omitempty"`
}

type ClusterZoneDistributionConfig struct {
	/* Optional. The mode of zone distribution. Defaults to MULTI_ZONE, when not specified. */
	// +optional
	Mode *string `json:"mode,omitempty"`

	/* Optional. When SINGLE ZONE distribution is selected, zone field would be used to allocate all resources in that zone. This is not applicable to MULTI_ZONE, and would be ignored for MULTI_ZONE clusters. */
	// +optional
	Zone *string `json:"zone,omitempty"`
}

type RedisClusterSpec struct {
	/* Optional. The authorization mode of the Redis cluster. If not provided, auth feature is disabled for the cluster. */
	// +optional
	AuthorizationMode *string `json:"authorizationMode,omitempty"`

	/* Optional. The delete operation will fail when the value is set to true. */
	// +optional
	DeletionProtectionEnabled *bool `json:"deletionProtectionEnabled,omitempty"`

	/* Immutable. Location of the resource. */
	Location string `json:"location"`

	/* Optional. The type of a redis node in the cluster. NodeType determines the underlying machine-type of a redis node. */
	// +optional
	NodeType *string `json:"nodeType,omitempty"`

	/* Optional. Persistence config (RDB, AOF) for the cluster. */
	// +optional
	PersistenceConfig *ClusterPersistenceConfig `json:"persistenceConfig,omitempty"`

	/* Immutable. The Project that this resource belongs to. */
	ProjectRef v1alpha1.ResourceRef `json:"projectRef"`

	/* Required. Each PscConfig configures the consumer network where IPs will be designated to the cluster for client access through Private Service Connect Automation. Currently, only one PscConfig is supported. */
	// +optional
	PscConfigs []ClusterPscConfigs `json:"pscConfigs,omitempty"`

	/* Optional. Key/Value pairs of customer overrides for mutable Redis Configs */
	// +optional
	RedisConfigs map[string]string `json:"redisConfigs,omitempty"`

	/* Optional. The number of replica nodes per shard. */
	// +optional
	ReplicaCount *int32 `json:"replicaCount,omitempty"`

	/* The RedisCluster name. If not given, the metadata.name will be used. */
	// +optional
	ResourceID *string `json:"resourceID,omitempty"`

	/* Required. Number of shards for the Redis cluster. */
	// +optional
	ShardCount *int32 `json:"shardCount,omitempty"`

	/* Optional. The in-transit encryption for the Redis cluster. If not provided, encryption  is disabled for the cluster. */
	// +optional
	TransitEncryptionMode *string `json:"transitEncryptionMode,omitempty"`

	/* Optional. This config will be used to determine how the customer wants us to distribute cluster resources within the region. */
	// +optional
	ZoneDistributionConfig *ClusterZoneDistributionConfig `json:"zoneDistributionConfig,omitempty"`
}

type ClusterDiscoveryEndpointsStatus struct {
	/* Output only. Address of the exposed Redis endpoint used by clients to connect to the service. The address could be either IP or hostname. */
	// +optional
	Address *string `json:"address,omitempty"`

	/* Output only. The port number of the exposed Redis endpoint. */
	// +optional
	Port *int32 `json:"port,omitempty"`

	/* Output only. Customer configuration for where the endpoint is created and accessed from. */
	// +optional
	PscConfig *ClusterPscConfigStatus `json:"pscConfig,omitempty"`
}

type ClusterObservedStateStatus struct {
	/* Output only. The timestamp associated with the cluster creation request. */
	// +optional
	CreateTime *string `json:"createTime,omitempty"`

	/* Output only. Endpoints created on each given network, for Redis clients to connect to the cluster. Currently only one discovery endpoint is supported. */
	// +optional
	DiscoveryEndpoints []ClusterDiscoveryEndpointsStatus `json:"discoveryEndpoints,omitempty"`

	/* Output only. Precise value of redis memory size in GB for the entire cluster. */
	// +optional
	PreciseSizeGb *float64 `json:"preciseSizeGb,omitempty"`

	/* Output only. PSC connections for discovery of the cluster topology and accessing the cluster. */
	// +optional
	PscConnections []ClusterPscConnectionsStatus `json:"pscConnections,omitempty"`

	/* Output only. Redis memory size in GB for the entire cluster rounded up to the next integer. */
	// +optional
	SizeGb *int32 `json:"sizeGb,omitempty"`

	/* Output only. The current state of this cluster. Can be CREATING, READY, UPDATING, DELETING and SUSPENDED */
	// +optional
	State *string `json:"state,omitempty"`

	/* Output only. Additional information about the current state of the cluster. */
	// +optional
	StateInfo *ClusterStateInfoStatus `json:"stateInfo,omitempty"`

	/* Output only. System assigned, unique identifier for the cluster. */
	// +optional
	Uid *string `json:"uid,omitempty"`
}

type ClusterPscConfigStatus struct {
	/* Required. The network where the IP address of the discovery endpoint will be reserved, in the form of projects/{network_project}/global/networks/{network_id}. */
	// +optional
	Network *string `json:"network,omitempty"`
}

type ClusterPscConnectionsStatus struct {
	/* Output only. The IP allocated on the consumer network for the PSC forwarding rule. */
	// +optional
	Address *string `json:"address,omitempty"`

	/* Output only. The URI of the consumer side forwarding rule. Example: projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}. */
	// +optional
	ForwardingRule *string `json:"forwardingRule,omitempty"`

	/* The consumer network where the IP address resides, in the form of projects/{project_id}/global/networks/{network_id}. */
	// +optional
	Network *string `json:"network,omitempty"`

	/* Output only. The consumer project_id where the forwarding rule is created from. */
	// +optional
	ProjectID *string `json:"projectID,omitempty"`

	/* Output only. The PSC connection id of the forwarding rule connected to the service attachment. */
	// +optional
	PscConnectionID *string `json:"pscConnectionID,omitempty"`
}

type ClusterStateInfoStatus struct {
	/* Describes ongoing update on the cluster when cluster state is UPDATING. */
	// +optional
	UpdateInfo *ClusterUpdateInfoStatus `json:"updateInfo,omitempty"`
}

type ClusterUpdateInfoStatus struct {
	/* Target number of replica nodes per shard. */
	// +optional
	TargetReplicaCount *int32 `json:"targetReplicaCount,omitempty"`

	/* Target number of shards for redis cluster */
	// +optional
	TargetShardCount *int32 `json:"targetShardCount,omitempty"`
}

type RedisClusterStatus struct {
	/* Conditions represent the latest available observations of the
	   RedisCluster's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* A unique specifier for the RedisCluster resource in GCP. */
	// +optional
	ExternalRef *string `json:"externalRef,omitempty"`

	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	// +optional
	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`

	/* ObservedState is the state of the resource as most recently observed in GCP. */
	// +optional
	ObservedState *ClusterObservedStateStatus `json:"observedState,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:categories=gcp,shortName=
// +kubebuilder:subresource:status
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/managed-by-kcc=true";"cnrm.cloud.google.com/system=true"
// +kubebuilder:printcolumn:name="Age",JSONPath=".metadata.creationTimestamp",type="date"
// +kubebuilder:printcolumn:name="Ready",JSONPath=".status.conditions[?(@.type=='Ready')].status",type="string",description="When 'True', the most recent reconcile of the resource succeeded"
// +kubebuilder:printcolumn:name="Status",JSONPath=".status.conditions[?(@.type=='Ready')].reason",type="string",description="The reason for the value in 'Ready'"
// +kubebuilder:printcolumn:name="Status Age",JSONPath=".status.conditions[?(@.type=='Ready')].lastTransitionTime",type="date",description="The last transition time for the value in 'Status'"

// RedisCluster is the Schema for the redis API
// +k8s:openapi-gen=true
type RedisCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   RedisClusterSpec   `json:"spec,omitempty"`
	Status RedisClusterStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// RedisClusterList contains a list of RedisCluster
type RedisClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RedisCluster `json:"items"`
}

func init() {
	SchemeBuilder.Register(&RedisCluster{}, &RedisClusterList{})
}
