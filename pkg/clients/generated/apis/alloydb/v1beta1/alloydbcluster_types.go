// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Config Connector and manual
//     changes will be clobbered when the file is regenerated.
//
// ----------------------------------------------------------------------------

// *** DISCLAIMER ***
// Config Connector's go-client for CRDs is currently in ALPHA, which means
// that future versions of the go-client may include breaking changes.
// Please try it out and give us feedback!

package v1beta1

import (
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/clients/generated/apis/k8s/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ClusterAutomatedBackupPolicy struct {
	/* The length of the time window during which a backup can be
	taken. If a backup does not succeed within this time window, it will be
	canceled and considered failed.

	The backup window must be at least 5 minutes long. There is no upper bound
	on the window. If not set, it defaults to 1 hour. */
	// +optional
	BackupWindow *string `json:"backupWindow,omitempty"`

	/* Whether automated automated backups are enabled. If not set, defaults to true. */
	// +optional
	Enabled *bool `json:"enabled,omitempty"`

	/* Optional. The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will use the cluster's encryption config. */
	// +optional
	EncryptionConfig *ClusterEncryptionConfig `json:"encryptionConfig,omitempty"`

	/* Labels to apply to backups created using this configuration. */
	// +optional
	Labels map[string]string `json:"labels,omitempty"`

	/* The location where the backup will be stored. Currently, the only supported
	option is to store the backup in the same region as the cluster.

	If empty, defaults to the region of the cluster. */
	// +optional
	Location *string `json:"location,omitempty"`

	/* Quantity-based Backup retention policy to retain recent backups. */
	// +optional
	QuantityBasedRetention *ClusterQuantityBasedRetention `json:"quantityBasedRetention,omitempty"`

	/* Time-based Backup retention policy. */
	// +optional
	TimeBasedRetention *ClusterTimeBasedRetention `json:"timeBasedRetention,omitempty"`

	/* Weekly schedule for the Backup. */
	// +optional
	WeeklySchedule *ClusterWeeklySchedule `json:"weeklySchedule,omitempty"`
}

type ClusterContinuousBackupConfig struct {
	/* Whether ContinuousBackup is enabled. */
	// +optional
	Enabled *bool `json:"enabled,omitempty"`

	/* The encryption config can be specified to encrypt the backups with a customer-managed encryption key (CMEK). When this field is not specified, the backup will use the cluster's encryption config. */
	// +optional
	EncryptionConfig *ClusterEncryptionConfig `json:"encryptionConfig,omitempty"`

	/* The number of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window. If not set, defaults to 14 days. */
	// +optional
	RecoveryWindowDays *int32 `json:"recoveryWindowDays,omitempty"`
}

type ClusterEncryptionConfig struct {
	/* The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME] */
	// +optional
	KmsKeyNameRef *v1alpha1.ResourceRef `json:"kmsKeyNameRef,omitempty"`
}

type ClusterInitialUser struct {
	/* The initial password for the user. */
	Password ClusterPassword `json:"password"`

	/* The database username. */
	// +optional
	User *string `json:"user,omitempty"`
}

type ClusterMaintenanceUpdatePolicy struct {
	/* Preferred windows to perform maintenance. Currently limited to 1. */
	// +optional
	MaintenanceWindows []ClusterMaintenanceWindows `json:"maintenanceWindows,omitempty"`
}

type ClusterMaintenanceWindows struct {
	/* Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc. */
	Day string `json:"day"`

	/* Preferred time to start the maintenance operation on the specified day. Maintenance will start within 1 hour of this time. */
	StartTime ClusterStartTime `json:"startTime"`
}

type ClusterNetworkConfig struct {
	/* Optional. Name of the allocated IP range for the private IP AlloyDB cluster, for example: "google-managed-services-default". If set, the instance IPs for this cluster will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. Field name is intended to be consistent with Cloud SQL. */
	// +optional
	AllocatedIpRange *string `json:"allocatedIpRange,omitempty"`

	/* The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: `projects/{project_number}/global/networks/{network_id}`. This is required to create a cluster. */
	// +optional
	NetworkRef *v1alpha1.ResourceRef `json:"networkRef,omitempty"`
}

type ClusterPassword struct {
	/* Value of the field. Cannot be used if 'valueFrom' is specified. */
	// +optional
	Value *string `json:"value,omitempty"`

	/* Source for the field's value. Cannot be used if 'value' is specified. */
	// +optional
	ValueFrom *ClusterValueFrom `json:"valueFrom,omitempty"`
}

type ClusterQuantityBasedRetention struct {
	/* The number of backups to retain. */
	// +optional
	Count *int32 `json:"count,omitempty"`
}

type ClusterRestoreBackupSource struct {
	/* Required. The name of the backup resource with the format: * projects/{project}/locations/{region}/backups/{backup_id} */
	BackupNameRef v1alpha1.ResourceRef `json:"backupNameRef"`
}

type ClusterRestoreContinuousBackupSource struct {
	/* (Required) The name of the source cluster that this cluster is restored from. */
	ClusterRef v1alpha1.ResourceRef `json:"clusterRef"`

	/* Immutable. The point in time that this cluster is restored to, in RFC 3339 format. */
	PointInTime string `json:"pointInTime"`
}

type ClusterSecondaryConfig struct {
	/* The name of the primary cluster name with the format: * projects/{project}/locations/{region}/clusters/{cluster_id} */
	PrimaryClusterNameRef v1alpha1.ResourceRef `json:"primaryClusterNameRef"`
}

type ClusterStartTime struct {
	/* Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time. */
	// +optional
	Hours *int32 `json:"hours,omitempty"`

	/* Minutes of hour of day. Must be from 0 to 59. */
	// +optional
	Minutes *int32 `json:"minutes,omitempty"`

	/* Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999. */
	// +optional
	Nanos *int32 `json:"nanos,omitempty"`

	/* Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds. */
	// +optional
	Seconds *int32 `json:"seconds,omitempty"`
}

type ClusterStartTimes struct {
	/* Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time. */
	// +optional
	Hours *int32 `json:"hours,omitempty"`

	/* Minutes of hour of day. Must be from 0 to 59. */
	// +optional
	Minutes *int32 `json:"minutes,omitempty"`

	/* Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999. */
	// +optional
	Nanos *int32 `json:"nanos,omitempty"`

	/* Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds. */
	// +optional
	Seconds *int32 `json:"seconds,omitempty"`
}

type ClusterTimeBasedRetention struct {
	/* The retention period. */
	// +optional
	RetentionPeriod *string `json:"retentionPeriod,omitempty"`
}

type ClusterValueFrom struct {
	/* Reference to a value with the given key in the given Secret in the resource's namespace. */
	// +optional
	SecretKeyRef *v1alpha1.SecretKeyRef `json:"secretKeyRef,omitempty"`
}

type ClusterWeeklySchedule struct {
	/* The days of the week to perform a backup.

	If this field is left empty, the default of every day of the week is
	used. */
	// +optional
	DaysOfWeek []string `json:"daysOfWeek,omitempty"`

	/* The times during the day to start a backup. The start times are assumed
	to be in UTC and to be an exact hour (e.g., 04:00:00).

	If no start times are provided, a single fixed start time is chosen
	arbitrarily. */
	StartTimes []ClusterStartTimes `json:"startTimes"`
}

type AlloyDBClusterSpec struct {
	/* The automated backup policy for this cluster.

	If no policy is provided then the default policy will be used. If backups
	are supported for the cluster, the default policy takes one backup a day,
	has a backup window of 1 hour, and retains backups for 14 days.
	For more information on the defaults, consult the
	documentation for the message type. */
	// +optional
	AutomatedBackupPolicy *ClusterAutomatedBackupPolicy `json:"automatedBackupPolicy,omitempty"`

	/* The type of cluster. If not set, defaults to PRIMARY. Default value: "PRIMARY" Possible values: ["PRIMARY", "SECONDARY"]. */
	// +optional
	ClusterType *string `json:"clusterType,omitempty"`

	/* Optional. Continuous backup configuration for this cluster. */
	// +optional
	ContinuousBackupConfig *ClusterContinuousBackupConfig `json:"continuousBackupConfig,omitempty"`

	/* Optional. The database engine major version. This is an optional field and it is populated at the Cluster creation time. If a database version is not supplied at cluster creation time, then a default database version will be used. */
	// +optional
	DatabaseVersion *string `json:"databaseVersion,omitempty"`

	/* Policy to determine if the cluster should be deleted forcefully. Deleting a cluster forcefully, deletes the cluster and all its associated instances within the cluster. Deleting a Secondary cluster with a secondary instance REQUIRES setting deletion_policy = "FORCE" otherwise an error is returned. This is needed as there is no support to delete just the secondary instance, and the only way to delete secondary instance is to delete the associated secondary cluster forcefully which also deletes the secondary instance. */
	// +optional
	DeletionPolicy *string `json:"deletionPolicy,omitempty"`

	/* User-settable and human-readable display name for the Cluster. */
	// +optional
	DisplayName *string `json:"displayName,omitempty"`

	/* Optional. The encryption config can be specified to encrypt the data disks and other persistent data resources of a cluster with a customer-managed encryption key (CMEK). When this field is not specified, the cluster will then use default encryption scheme to protect the user data. */
	// +optional
	EncryptionConfig *ClusterEncryptionConfig `json:"encryptionConfig,omitempty"`

	/* Input only. Initial user to setup during cluster creation. Required. If used in `RestoreCluster` this is ignored. */
	// +optional
	InitialUser *ClusterInitialUser `json:"initialUser,omitempty"`

	/* Immutable. The location where the alloydb cluster should reside. */
	Location string `json:"location"`

	/* Optional. The maintenance update policy determines when to allow or deny updates. */
	// +optional
	MaintenanceUpdatePolicy *ClusterMaintenanceUpdatePolicy `json:"maintenanceUpdatePolicy,omitempty"`

	// +optional
	NetworkConfig *ClusterNetworkConfig `json:"networkConfig,omitempty"`

	/* The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster. It is specified in the form: `projects/{project}/global/networks/{network_id}`. This is required to create a cluster. Deprecated, use network_config.network instead. */
	// +optional
	NetworkRef *v1alpha1.ResourceRef `json:"networkRef,omitempty"`

	/* The project that this resource belongs to. */
	ProjectRef v1alpha1.ResourceRef `json:"projectRef"`

	/* The AlloyDBCluster name. If not given, the metadata.name will be used. */
	// +optional
	ResourceID *string `json:"resourceID,omitempty"`

	/* Immutable. The source when restoring from a backup. Conflicts with 'restoreContinuousBackupSource', both can't be set together. */
	// +optional
	RestoreBackupSource *ClusterRestoreBackupSource `json:"restoreBackupSource,omitempty"`

	/* Immutable. The source when restoring via point in time recovery (PITR). Conflicts with 'restoreBackupSource', both can't be set together. */
	// +optional
	RestoreContinuousBackupSource *ClusterRestoreContinuousBackupSource `json:"restoreContinuousBackupSource,omitempty"`

	/* Cross Region replication config specific to SECONDARY cluster. */
	// +optional
	SecondaryConfig *ClusterSecondaryConfig `json:"secondaryConfig,omitempty"`
}

type ClusterBackupSourceStatus struct {
	/* The name of the backup resource. */
	// +optional
	BackupName *string `json:"backupName,omitempty"`
}

type ClusterContinuousBackupInfoStatus struct {
	/* Output only. The earliest restorable time that can be restored to. Output only field. */
	// +optional
	EarliestRestorableTime *string `json:"earliestRestorableTime,omitempty"`

	/* Output only. When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled. */
	// +optional
	EnabledTime *string `json:"enabledTime,omitempty"`

	/* Output only. The encryption information for the WALs and backups required for ContinuousBackup. */
	// +optional
	EncryptionInfo []ClusterEncryptionInfoStatus `json:"encryptionInfo,omitempty"`

	/* Output only. Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request. */
	// +optional
	Schedule []string `json:"schedule,omitempty"`
}

type ClusterEncryptionInfoStatus struct {
	/* Output only. Type of encryption. */
	// +optional
	EncryptionType *string `json:"encryptionType,omitempty"`

	/* Output only. Cloud KMS key versions that are being used to protect the database or the backup. */
	// +optional
	KmsKeyVersions []string `json:"kmsKeyVersions,omitempty"`
}

type ClusterMigrationSourceStatus struct {
	/* Output only. The host and port of the on-premises instance in host:port format */
	// +optional
	HostPort *string `json:"hostPort,omitempty"`

	/* Output only. Place holder for the external source identifier(e.g DMS job name) that created the cluster. */
	// +optional
	ReferenceId *string `json:"referenceId,omitempty"`

	/* Output only. Type of migration source. */
	// +optional
	SourceType *string `json:"sourceType,omitempty"`
}

type ClusterObservedStateStatus struct {
	/* Output only. The type of the cluster. This is an output-only field and it's populated at the Cluster creation time or the Cluster promotion time. The cluster type is determined by which RPC was used to create the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster` */
	// +optional
	ClusterType *string `json:"clusterType,omitempty"`

	/* The database engine major version. This is an output-only field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation. */
	// +optional
	DatabaseVersion *string `json:"databaseVersion,omitempty"`
}

type AlloyDBClusterStatus struct {
	/* Conditions represent the latest available observations of the
	   AlloyDBCluster's current state. */
	Conditions []v1alpha1.Condition `json:"conditions,omitempty"`
	/* Output only. Cluster created from backup. */
	// +optional
	BackupSource []ClusterBackupSourceStatus `json:"backupSource,omitempty"`

	/* Output only. Continuous backup properties for this cluster. */
	// +optional
	ContinuousBackupInfo []ClusterContinuousBackupInfoStatus `json:"continuousBackupInfo,omitempty"`

	/* The database engine major version. This is an output-only field and it's populated at the Cluster creation time. This field cannot be changed after cluster creation. */
	// +optional
	DatabaseVersion *string `json:"databaseVersion,omitempty"`

	/* Output only. The encryption information for the cluster. */
	// +optional
	EncryptionInfo []ClusterEncryptionInfoStatus `json:"encryptionInfo,omitempty"`

	/* A unique specifier for the AlloyDBCluster resource in GCP. */
	// +optional
	ExternalRef *string `json:"externalRef,omitempty"`

	/* Output only. Cluster created via DMS migration. */
	// +optional
	MigrationSource []ClusterMigrationSourceStatus `json:"migrationSource,omitempty"`

	/* Output only. The name of the cluster resource with the format: * projects/{project}/locations/{region}/clusters/{cluster_id} where the cluster ID segment should satisfy the regex expression `[a-z0-9-]+`. For more details see https://google.aip.dev/122. The prefix of the cluster resource name is the name of the parent resource: * projects/{project}/locations/{region} */
	// +optional
	Name *string `json:"name,omitempty"`

	/* ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource. */
	// +optional
	ObservedGeneration *int64 `json:"observedGeneration,omitempty"`

	/* ObservedState is the state of the resource as most recently observed in GCP. */
	// +optional
	ObservedState *ClusterObservedStateStatus `json:"observedState,omitempty"`

	/* Output only. The system-generated UID of the resource. The UID is assigned when the resource is created, and it is retained until it is deleted. */
	// +optional
	Uid *string `json:"uid,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:categories=gcp,shortName=gcpalloydbcluster;gcpalloydbclusters
// +kubebuilder:subresource:status
// +kubebuilder:metadata:labels="cnrm.cloud.google.com/managed-by-kcc=true";"cnrm.cloud.google.com/stability-level=stable";"cnrm.cloud.google.com/system=true";"cnrm.cloud.google.com/tf2crd=true"
// +kubebuilder:printcolumn:name="Age",JSONPath=".metadata.creationTimestamp",type="date"
// +kubebuilder:printcolumn:name="Ready",JSONPath=".status.conditions[?(@.type=='Ready')].status",type="string",description="When 'True', the most recent reconcile of the resource succeeded"
// +kubebuilder:printcolumn:name="Status",JSONPath=".status.conditions[?(@.type=='Ready')].reason",type="string",description="The reason for the value in 'Ready'"
// +kubebuilder:printcolumn:name="Status Age",JSONPath=".status.conditions[?(@.type=='Ready')].lastTransitionTime",type="date",description="The last transition time for the value in 'Status'"

// AlloyDBCluster is the Schema for the alloydb API
// +k8s:openapi-gen=true
type AlloyDBCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   AlloyDBClusterSpec   `json:"spec,omitempty"`
	Status AlloyDBClusterStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// AlloyDBClusterList contains a list of AlloyDBCluster
type AlloyDBClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AlloyDBCluster `json:"items"`
}

func init() {
	SchemeBuilder.Register(&AlloyDBCluster{}, &AlloyDBClusterList{})
}
