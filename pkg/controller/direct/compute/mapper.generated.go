// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by dev/tasks/generate-all. DO NOT EDIT.
// +generated:mapper
// krm.group: compute.cnrm.cloud.google.com
// krm.version: v1beta1
// proto.service: google.cloud.compute.v1

package compute

import (
	pb "cloud.google.com/go/compute/apiv1/computepb"
	krmcomputev1alpha1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/compute/v1alpha1"
	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/compute/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
)

func ComputeSecurityPolicyObservedState_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicy) *krm.ComputeSecurityPolicyObservedState {
	if in == nil {
		return nil
	}
	out := &krm.ComputeSecurityPolicyObservedState{}
	// MISSING: CreationTimestamp
	// MISSING: DdosProtectionConfig
	// MISSING: Fingerprint
	// MISSING: ID
	// MISSING: Kind
	// MISSING: LabelFingerprint
	// MISSING: Labels
	// MISSING: Name
	// MISSING: Region
	// MISSING: SelfLink
	// MISSING: UserDefinedFields
	return out
}
func ComputeSecurityPolicyObservedState_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ComputeSecurityPolicyObservedState) *pb.SecurityPolicy {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicy{}
	// MISSING: CreationTimestamp
	// MISSING: DdosProtectionConfig
	// MISSING: Fingerprint
	// MISSING: ID
	// MISSING: Kind
	// MISSING: LabelFingerprint
	// MISSING: Labels
	// MISSING: Name
	// MISSING: Region
	// MISSING: SelfLink
	// MISSING: UserDefinedFields
	return out
}
func ComputeSecurityPolicySpec_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicy) *krm.ComputeSecurityPolicySpec {
	if in == nil {
		return nil
	}
	out := &krm.ComputeSecurityPolicySpec{}
	out.AdaptiveProtectionConfig = SecurityPolicyAdaptiveProtectionConfig_v1beta1_FromProto(mapCtx, in.GetAdaptiveProtectionConfig())
	out.AdvancedOptionsConfig = SecurityPolicyAdvancedOptionsConfig_v1beta1_FromProto(mapCtx, in.GetAdvancedOptionsConfig())
	// MISSING: CreationTimestamp
	// MISSING: DdosProtectionConfig
	out.Description = in.Description
	// MISSING: Fingerprint
	// MISSING: ID
	// MISSING: Kind
	// MISSING: LabelFingerprint
	// MISSING: Labels
	// MISSING: Name
	out.RecaptchaOptionsConfig = SecurityPolicyRecaptchaOptionsConfig_v1beta1_FromProto(mapCtx, in.GetRecaptchaOptionsConfig())
	// MISSING: Region
	out.Rules = direct.Slice_FromProto(mapCtx, in.Rules, SecurityPolicyRule_v1beta1_FromProto)
	// MISSING: SelfLink
	out.Type = in.Type
	// MISSING: UserDefinedFields
	return out
}
func ComputeSecurityPolicySpec_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ComputeSecurityPolicySpec) *pb.SecurityPolicy {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicy{}
	out.AdaptiveProtectionConfig = SecurityPolicyAdaptiveProtectionConfig_v1beta1_ToProto(mapCtx, in.AdaptiveProtectionConfig)
	out.AdvancedOptionsConfig = SecurityPolicyAdvancedOptionsConfig_v1beta1_ToProto(mapCtx, in.AdvancedOptionsConfig)
	// MISSING: CreationTimestamp
	// MISSING: DdosProtectionConfig
	out.Description = in.Description
	// MISSING: Fingerprint
	// MISSING: ID
	// MISSING: Kind
	// MISSING: LabelFingerprint
	// MISSING: Labels
	// MISSING: Name
	out.RecaptchaOptionsConfig = SecurityPolicyRecaptchaOptionsConfig_v1beta1_ToProto(mapCtx, in.RecaptchaOptionsConfig)
	// MISSING: Region
	out.Rules = direct.Slice_ToProto(mapCtx, in.Rules, SecurityPolicyRule_v1beta1_ToProto)
	// MISSING: SelfLink
	out.Type = in.Type
	// MISSING: UserDefinedFields
	return out
}
func ComputeSubnetworkSpec_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.Subnetwork) *krm.ComputeSubnetworkSpec {
	if in == nil {
		return nil
	}
	out := &krm.ComputeSubnetworkSpec{}
	// MISSING: CreationTimestamp
	out.Description = in.Description
	// MISSING: EnableFlowLogs
	// MISSING: ExternalIPV6Prefix
	// MISSING: Fingerprint
	// MISSING: GatewayAddress
	// MISSING: ID
	// MISSING: InternalIPV6Prefix
	out.IPCIDRRange = in.IpCidrRange
	// MISSING: IPCollection
	out.IPV6AccessType = in.Ipv6AccessType
	// MISSING: IPV6CIDRRange
	// MISSING: IPV6GCEEndpoint
	// MISSING: Kind
	out.LogConfig = SubnetworkLogConfig_v1beta1_FromProto(mapCtx, in.GetLogConfig())
	// MISSING: Name
	if in.GetNetwork() != "" {
		out.NetworkRef = &krm.ComputeNetworkRef{External: in.GetNetwork()}
	}
	// MISSING: Params
	out.PrivateIPGoogleAccess = in.PrivateIpGoogleAccess
	out.PrivateIPV6GoogleAccess = in.PrivateIpv6GoogleAccess
	out.Purpose = in.Purpose
	out.Region = in.Region
	// MISSING: ReservedInternalRange
	out.Role = in.Role
	out.SecondaryIPRanges = direct.Slice_FromProto(mapCtx, in.SecondaryIpRanges, SubnetworkSecondaryRange_v1beta1_FromProto)
	// MISSING: SelfLink
	out.StackType = in.StackType
	// MISSING: State
	// MISSING: SystemReservedExternalIPV6Ranges
	// MISSING: SystemReservedInternalIPV6Ranges
	return out
}
func ComputeSubnetworkSpec_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ComputeSubnetworkSpec) *pb.Subnetwork {
	if in == nil {
		return nil
	}
	out := &pb.Subnetwork{}
	// MISSING: CreationTimestamp
	out.Description = in.Description
	// MISSING: EnableFlowLogs
	// MISSING: ExternalIPV6Prefix
	// MISSING: Fingerprint
	// MISSING: GatewayAddress
	// MISSING: ID
	// MISSING: InternalIPV6Prefix
	out.IpCidrRange = in.IPCIDRRange
	// MISSING: IPCollection
	out.Ipv6AccessType = in.IPV6AccessType
	// MISSING: IPV6CIDRRange
	// MISSING: IPV6GCEEndpoint
	// MISSING: Kind
	out.LogConfig = SubnetworkLogConfig_v1beta1_ToProto(mapCtx, in.LogConfig)
	// MISSING: Name
	if in.NetworkRef != nil {
		out.Network = &in.NetworkRef.External
	}
	// MISSING: Params
	out.PrivateIpGoogleAccess = in.PrivateIPGoogleAccess
	out.PrivateIpv6GoogleAccess = in.PrivateIPV6GoogleAccess
	out.Purpose = in.Purpose
	out.Region = in.Region
	// MISSING: ReservedInternalRange
	out.Role = in.Role
	out.SecondaryIpRanges = direct.Slice_ToProto(mapCtx, in.SecondaryIPRanges, SubnetworkSecondaryRange_v1beta1_ToProto)
	// MISSING: SelfLink
	out.StackType = in.StackType
	// MISSING: State
	// MISSING: SystemReservedExternalIPV6Ranges
	// MISSING: SystemReservedInternalIPV6Ranges
	return out
}
func ComputeSubnetworkStatus_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.Subnetwork) *krm.ComputeSubnetworkStatus {
	if in == nil {
		return nil
	}
	out := &krm.ComputeSubnetworkStatus{}
	out.CreationTimestamp = in.CreationTimestamp
	// MISSING: Description
	// MISSING: EnableFlowLogs
	out.ExternalIPV6Prefix = in.ExternalIpv6Prefix
	out.Fingerprint = in.Fingerprint
	out.GatewayAddress = in.GatewayAddress
	// MISSING: ID
	out.InternalIPV6Prefix = in.InternalIpv6Prefix
	// MISSING: IPCIDRRange
	// MISSING: IPCollection
	// MISSING: IPV6AccessType
	out.IPV6CIDRRange = in.Ipv6CidrRange
	// MISSING: IPV6GCEEndpoint
	// MISSING: Kind
	// MISSING: LogConfig
	// MISSING: Name
	// MISSING: Network
	// MISSING: Params
	// MISSING: PrivateIPGoogleAccess
	// MISSING: PrivateIPV6GoogleAccess
	// MISSING: Purpose
	// MISSING: Region
	// MISSING: ReservedInternalRange
	// MISSING: Role
	// MISSING: SecondaryIPRanges
	out.SelfLink = in.SelfLink
	// MISSING: StackType
	// MISSING: State
	// MISSING: SystemReservedExternalIPV6Ranges
	// MISSING: SystemReservedInternalIPV6Ranges
	return out
}
func ComputeSubnetworkStatus_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ComputeSubnetworkStatus) *pb.Subnetwork {
	if in == nil {
		return nil
	}
	out := &pb.Subnetwork{}
	out.CreationTimestamp = in.CreationTimestamp
	// MISSING: Description
	// MISSING: EnableFlowLogs
	out.ExternalIpv6Prefix = in.ExternalIPV6Prefix
	out.Fingerprint = in.Fingerprint
	out.GatewayAddress = in.GatewayAddress
	// MISSING: ID
	out.InternalIpv6Prefix = in.InternalIPV6Prefix
	// MISSING: IPCIDRRange
	// MISSING: IPCollection
	// MISSING: IPV6AccessType
	out.Ipv6CidrRange = in.IPV6CIDRRange
	// MISSING: IPV6GCEEndpoint
	// MISSING: Kind
	// MISSING: LogConfig
	// MISSING: Name
	// MISSING: Network
	// MISSING: Params
	// MISSING: PrivateIPGoogleAccess
	// MISSING: PrivateIPV6GoogleAccess
	// MISSING: Purpose
	// MISSING: Region
	// MISSING: ReservedInternalRange
	// MISSING: Role
	// MISSING: SecondaryIPRanges
	out.SelfLink = in.SelfLink
	// MISSING: StackType
	// MISSING: State
	// MISSING: SystemReservedExternalIPV6Ranges
	// MISSING: SystemReservedInternalIPV6Ranges
	return out
}
func ComputeURLMapStatus_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.UrlMap) *krm.ComputeURLMapStatus {
	if in == nil {
		return nil
	}
	out := &krm.ComputeURLMapStatus{}
	out.CreationTimestamp = in.CreationTimestamp
	// MISSING: DefaultCustomErrorResponsePolicy
	// MISSING: DefaultRouteAction
	// MISSING: DefaultService
	// MISSING: DefaultURLRedirect
	// MISSING: Description
	out.Fingerprint = in.Fingerprint
	// MISSING: HeaderAction
	// MISSING: HostRules
	out.ID = in.Id
	// MISSING: Kind
	// MISSING: Name
	// MISSING: PathMatchers
	// MISSING: Region
	out.SelfLink = in.SelfLink
	// MISSING: Tests
	return out
}
func ComputeURLMapStatus_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ComputeURLMapStatus) *pb.UrlMap {
	if in == nil {
		return nil
	}
	out := &pb.UrlMap{}
	out.CreationTimestamp = in.CreationTimestamp
	// MISSING: DefaultCustomErrorResponsePolicy
	// MISSING: DefaultRouteAction
	// MISSING: DefaultService
	// MISSING: DefaultURLRedirect
	// MISSING: Description
	out.Fingerprint = in.Fingerprint
	// MISSING: HeaderAction
	// MISSING: HostRules
	out.Id = in.ID
	// MISSING: Kind
	// MISSING: Name
	// MISSING: PathMatchers
	// MISSING: Region
	out.SelfLink = in.SelfLink
	// MISSING: Tests
	return out
}
func CorsPolicy_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.CorsPolicy) *krm.CorsPolicy {
	if in == nil {
		return nil
	}
	out := &krm.CorsPolicy{}
	out.AllowCredentials = in.AllowCredentials
	out.AllowHeaders = in.AllowHeaders
	out.AllowMethods = in.AllowMethods
	out.AllowOriginRegexes = in.AllowOriginRegexes
	out.AllowOrigins = in.AllowOrigins
	out.Disabled = in.Disabled
	out.ExposeHeaders = in.ExposeHeaders
	out.MaxAge = in.MaxAge
	return out
}
func CorsPolicy_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.CorsPolicy) *pb.CorsPolicy {
	if in == nil {
		return nil
	}
	out := &pb.CorsPolicy{}
	out.AllowCredentials = in.AllowCredentials
	out.AllowHeaders = in.AllowHeaders
	out.AllowMethods = in.AllowMethods
	out.AllowOriginRegexes = in.AllowOriginRegexes
	out.AllowOrigins = in.AllowOrigins
	out.Disabled = in.Disabled
	out.ExposeHeaders = in.ExposeHeaders
	out.MaxAge = in.MaxAge
	return out
}
func CustomErrorResponsePolicy_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.CustomErrorResponsePolicy) *krm.CustomErrorResponsePolicy {
	if in == nil {
		return nil
	}
	out := &krm.CustomErrorResponsePolicy{}
	out.ErrorResponseRules = direct.Slice_FromProto(mapCtx, in.ErrorResponseRules, CustomErrorResponsePolicyCustomErrorResponseRule_v1beta1_FromProto)
	out.ErrorService = in.ErrorService
	return out
}
func CustomErrorResponsePolicy_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.CustomErrorResponsePolicy) *pb.CustomErrorResponsePolicy {
	if in == nil {
		return nil
	}
	out := &pb.CustomErrorResponsePolicy{}
	out.ErrorResponseRules = direct.Slice_ToProto(mapCtx, in.ErrorResponseRules, CustomErrorResponsePolicyCustomErrorResponseRule_v1beta1_ToProto)
	out.ErrorService = in.ErrorService
	return out
}
func CustomErrorResponsePolicyCustomErrorResponseRule_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.CustomErrorResponsePolicyCustomErrorResponseRule) *krm.CustomErrorResponsePolicyCustomErrorResponseRule {
	if in == nil {
		return nil
	}
	out := &krm.CustomErrorResponsePolicyCustomErrorResponseRule{}
	out.MatchResponseCodes = in.MatchResponseCodes
	out.OverrideResponseCode = in.OverrideResponseCode
	out.Path = in.Path
	return out
}
func CustomErrorResponsePolicyCustomErrorResponseRule_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.CustomErrorResponsePolicyCustomErrorResponseRule) *pb.CustomErrorResponsePolicyCustomErrorResponseRule {
	if in == nil {
		return nil
	}
	out := &pb.CustomErrorResponsePolicyCustomErrorResponseRule{}
	out.MatchResponseCodes = in.MatchResponseCodes
	out.OverrideResponseCode = in.OverrideResponseCode
	out.Path = in.Path
	return out
}
func Duration_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.Duration) *krm.Duration {
	if in == nil {
		return nil
	}
	out := &krm.Duration{}
	out.Nanos = in.Nanos
	out.Seconds = in.Seconds
	return out
}
func Duration_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.Duration) *pb.Duration {
	if in == nil {
		return nil
	}
	out := &pb.Duration{}
	out.Nanos = in.Nanos
	out.Seconds = in.Seconds
	return out
}
func Expr_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.Expr) *krm.Expr {
	if in == nil {
		return nil
	}
	out := &krm.Expr{}
	out.Description = in.Description
	out.Expression = in.Expression
	out.Location = in.Location
	out.Title = in.Title
	return out
}
func Expr_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.Expr) *pb.Expr {
	if in == nil {
		return nil
	}
	out := &pb.Expr{}
	out.Description = in.Description
	out.Expression = in.Expression
	out.Location = in.Location
	out.Title = in.Title
	return out
}
func FirewallPolicyRuleMatcher_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.FirewallPolicyRuleMatcher) *krm.FirewallPolicyRuleMatcher {
	if in == nil {
		return nil
	}
	out := &krm.FirewallPolicyRuleMatcher{}
	out.DestAddressGroups = in.DestAddressGroups
	out.DestFqdns = in.DestFqdns
	out.DestIPRanges = in.DestIpRanges
	// MISSING: DestNetworkType
	out.DestRegionCodes = in.DestRegionCodes
	out.DestThreatIntelligences = in.DestThreatIntelligences
	out.Layer4Configs = direct.Slice_FromProto(mapCtx, in.Layer4Configs, FirewallPolicyRuleMatcherLayer4Config_v1beta1_FromProto)
	out.SrcAddressGroups = in.SrcAddressGroups
	out.SrcFqdns = in.SrcFqdns
	out.SrcIPRanges = in.SrcIpRanges
	// MISSING: SrcNetworkType
	// MISSING: SrcNetworks
	out.SrcRegionCodes = in.SrcRegionCodes
	// MISSING: SrcSecureTags
	out.SrcThreatIntelligences = in.SrcThreatIntelligences
	return out
}
func FirewallPolicyRuleMatcher_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.FirewallPolicyRuleMatcher) *pb.FirewallPolicyRuleMatcher {
	if in == nil {
		return nil
	}
	out := &pb.FirewallPolicyRuleMatcher{}
	out.DestAddressGroups = in.DestAddressGroups
	out.DestFqdns = in.DestFqdns
	out.DestIpRanges = in.DestIPRanges
	// MISSING: DestNetworkType
	out.DestRegionCodes = in.DestRegionCodes
	out.DestThreatIntelligences = in.DestThreatIntelligences
	out.Layer4Configs = direct.Slice_ToProto(mapCtx, in.Layer4Configs, FirewallPolicyRuleMatcherLayer4Config_v1beta1_ToProto)
	out.SrcAddressGroups = in.SrcAddressGroups
	out.SrcFqdns = in.SrcFqdns
	out.SrcIpRanges = in.SrcIPRanges
	// MISSING: SrcNetworkType
	// MISSING: SrcNetworks
	out.SrcRegionCodes = in.SrcRegionCodes
	// MISSING: SrcSecureTags
	out.SrcThreatIntelligences = in.SrcThreatIntelligences
	return out
}
func FirewallPolicyRuleSecureTag_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.FirewallPolicyRuleSecureTag) *krm.FirewallPolicyRuleSecureTag {
	if in == nil {
		return nil
	}
	out := &krm.FirewallPolicyRuleSecureTag{}
	out.Name = in.Name
	out.State = in.State
	return out
}
func FirewallPolicyRuleSecureTag_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.FirewallPolicyRuleSecureTag) *pb.FirewallPolicyRuleSecureTag {
	if in == nil {
		return nil
	}
	out := &pb.FirewallPolicyRuleSecureTag{}
	out.Name = in.Name
	out.State = in.State
	return out
}
func ForwardingruleServiceDirectoryRegistrations_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.ForwardingRuleServiceDirectoryRegistration) *krm.ForwardingruleServiceDirectoryRegistrations {
	if in == nil {
		return nil
	}
	out := &krm.ForwardingruleServiceDirectoryRegistrations{}
	out.Namespace = in.Namespace
	out.Service = in.Service
	// MISSING: ServiceDirectoryRegion
	return out
}
func ForwardingruleServiceDirectoryRegistrations_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.ForwardingruleServiceDirectoryRegistrations) *pb.ForwardingRuleServiceDirectoryRegistration {
	if in == nil {
		return nil
	}
	out := &pb.ForwardingRuleServiceDirectoryRegistration{}
	out.Namespace = in.Namespace
	out.Service = in.Service
	// MISSING: ServiceDirectoryRegion
	return out
}
func HTTPFaultAbort_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpFaultAbort) *krm.HTTPFaultAbort {
	if in == nil {
		return nil
	}
	out := &krm.HTTPFaultAbort{}
	out.HTTPStatus = in.HttpStatus
	out.Percentage = in.Percentage
	return out
}
func HTTPFaultAbort_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPFaultAbort) *pb.HttpFaultAbort {
	if in == nil {
		return nil
	}
	out := &pb.HttpFaultAbort{}
	out.HttpStatus = in.HTTPStatus
	out.Percentage = in.Percentage
	return out
}
func HTTPFaultDelay_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpFaultDelay) *krm.HTTPFaultDelay {
	if in == nil {
		return nil
	}
	out := &krm.HTTPFaultDelay{}
	out.FixedDelay = Duration_v1beta1_FromProto(mapCtx, in.GetFixedDelay())
	out.Percentage = in.Percentage
	return out
}
func HTTPFaultDelay_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPFaultDelay) *pb.HttpFaultDelay {
	if in == nil {
		return nil
	}
	out := &pb.HttpFaultDelay{}
	out.FixedDelay = Duration_v1beta1_ToProto(mapCtx, in.FixedDelay)
	out.Percentage = in.Percentage
	return out
}
func HTTPFaultInjection_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpFaultInjection) *krm.HTTPFaultInjection {
	if in == nil {
		return nil
	}
	out := &krm.HTTPFaultInjection{}
	out.Abort = HTTPFaultAbort_v1beta1_FromProto(mapCtx, in.GetAbort())
	out.Delay = HTTPFaultDelay_v1beta1_FromProto(mapCtx, in.GetDelay())
	return out
}
func HTTPFaultInjection_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPFaultInjection) *pb.HttpFaultInjection {
	if in == nil {
		return nil
	}
	out := &pb.HttpFaultInjection{}
	out.Abort = HTTPFaultAbort_v1beta1_ToProto(mapCtx, in.Abort)
	out.Delay = HTTPFaultDelay_v1beta1_ToProto(mapCtx, in.Delay)
	return out
}
func HTTPHeaderAction_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpHeaderAction) *krm.HTTPHeaderAction {
	if in == nil {
		return nil
	}
	out := &krm.HTTPHeaderAction{}
	out.RequestHeadersToAdd = direct.Slice_FromProto(mapCtx, in.RequestHeadersToAdd, HTTPHeaderOption_v1beta1_FromProto)
	out.RequestHeadersToRemove = in.RequestHeadersToRemove
	out.ResponseHeadersToAdd = direct.Slice_FromProto(mapCtx, in.ResponseHeadersToAdd, HTTPHeaderOption_v1beta1_FromProto)
	out.ResponseHeadersToRemove = in.ResponseHeadersToRemove
	return out
}
func HTTPHeaderAction_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPHeaderAction) *pb.HttpHeaderAction {
	if in == nil {
		return nil
	}
	out := &pb.HttpHeaderAction{}
	out.RequestHeadersToAdd = direct.Slice_ToProto(mapCtx, in.RequestHeadersToAdd, HTTPHeaderOption_v1beta1_ToProto)
	out.RequestHeadersToRemove = in.RequestHeadersToRemove
	out.ResponseHeadersToAdd = direct.Slice_ToProto(mapCtx, in.ResponseHeadersToAdd, HTTPHeaderOption_v1beta1_ToProto)
	out.ResponseHeadersToRemove = in.ResponseHeadersToRemove
	return out
}
func HTTPHeaderMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpHeaderMatch) *krm.HTTPHeaderMatch {
	if in == nil {
		return nil
	}
	out := &krm.HTTPHeaderMatch{}
	out.ExactMatch = in.ExactMatch
	out.HeaderName = in.HeaderName
	out.InvertMatch = in.InvertMatch
	out.PrefixMatch = in.PrefixMatch
	out.PresentMatch = in.PresentMatch
	out.RangeMatch = Int64RangeMatch_v1beta1_FromProto(mapCtx, in.GetRangeMatch())
	out.RegexMatch = in.RegexMatch
	out.SuffixMatch = in.SuffixMatch
	return out
}
func HTTPHeaderMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPHeaderMatch) *pb.HttpHeaderMatch {
	if in == nil {
		return nil
	}
	out := &pb.HttpHeaderMatch{}
	out.ExactMatch = in.ExactMatch
	out.HeaderName = in.HeaderName
	out.InvertMatch = in.InvertMatch
	out.PrefixMatch = in.PrefixMatch
	out.PresentMatch = in.PresentMatch
	out.RangeMatch = Int64RangeMatch_v1beta1_ToProto(mapCtx, in.RangeMatch)
	out.RegexMatch = in.RegexMatch
	out.SuffixMatch = in.SuffixMatch
	return out
}
func HTTPHeaderOption_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpHeaderOption) *krm.HTTPHeaderOption {
	if in == nil {
		return nil
	}
	out := &krm.HTTPHeaderOption{}
	out.HeaderName = in.HeaderName
	out.HeaderValue = in.HeaderValue
	out.Replace = in.Replace
	return out
}
func HTTPHeaderOption_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPHeaderOption) *pb.HttpHeaderOption {
	if in == nil {
		return nil
	}
	out := &pb.HttpHeaderOption{}
	out.HeaderName = in.HeaderName
	out.HeaderValue = in.HeaderValue
	out.Replace = in.Replace
	return out
}
func HTTPQueryParameterMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpQueryParameterMatch) *krm.HTTPQueryParameterMatch {
	if in == nil {
		return nil
	}
	out := &krm.HTTPQueryParameterMatch{}
	out.ExactMatch = in.ExactMatch
	out.Name = in.Name
	out.PresentMatch = in.PresentMatch
	out.RegexMatch = in.RegexMatch
	return out
}
func HTTPQueryParameterMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPQueryParameterMatch) *pb.HttpQueryParameterMatch {
	if in == nil {
		return nil
	}
	out := &pb.HttpQueryParameterMatch{}
	out.ExactMatch = in.ExactMatch
	out.Name = in.Name
	out.PresentMatch = in.PresentMatch
	out.RegexMatch = in.RegexMatch
	return out
}
func HTTPRedirectAction_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpRedirectAction) *krm.HTTPRedirectAction {
	if in == nil {
		return nil
	}
	out := &krm.HTTPRedirectAction{}
	out.HostRedirect = in.HostRedirect
	out.HTTPSRedirect = in.HttpsRedirect
	out.PathRedirect = in.PathRedirect
	out.PrefixRedirect = in.PrefixRedirect
	out.RedirectResponseCode = in.RedirectResponseCode
	out.StripQuery = in.StripQuery
	return out
}
func HTTPRedirectAction_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPRedirectAction) *pb.HttpRedirectAction {
	if in == nil {
		return nil
	}
	out := &pb.HttpRedirectAction{}
	out.HostRedirect = in.HostRedirect
	out.HttpsRedirect = in.HTTPSRedirect
	out.PathRedirect = in.PathRedirect
	out.PrefixRedirect = in.PrefixRedirect
	out.RedirectResponseCode = in.RedirectResponseCode
	out.StripQuery = in.StripQuery
	return out
}
func HTTPRetryPolicy_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpRetryPolicy) *krm.HTTPRetryPolicy {
	if in == nil {
		return nil
	}
	out := &krm.HTTPRetryPolicy{}
	out.NumRetries = in.NumRetries
	out.PerTryTimeout = Duration_v1beta1_FromProto(mapCtx, in.GetPerTryTimeout())
	out.RetryConditions = in.RetryConditions
	return out
}
func HTTPRetryPolicy_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPRetryPolicy) *pb.HttpRetryPolicy {
	if in == nil {
		return nil
	}
	out := &pb.HttpRetryPolicy{}
	out.NumRetries = in.NumRetries
	out.PerTryTimeout = Duration_v1beta1_ToProto(mapCtx, in.PerTryTimeout)
	out.RetryConditions = in.RetryConditions
	return out
}
func HTTPRouteAction_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpRouteAction) *krm.HTTPRouteAction {
	if in == nil {
		return nil
	}
	out := &krm.HTTPRouteAction{}
	out.CorsPolicy = CorsPolicy_v1beta1_FromProto(mapCtx, in.GetCorsPolicy())
	out.FaultInjectionPolicy = HTTPFaultInjection_v1beta1_FromProto(mapCtx, in.GetFaultInjectionPolicy())
	out.MaxStreamDuration = Duration_v1beta1_FromProto(mapCtx, in.GetMaxStreamDuration())
	out.RequestMirrorPolicy = RequestMirrorPolicy_v1beta1_FromProto(mapCtx, in.GetRequestMirrorPolicy())
	out.RetryPolicy = HTTPRetryPolicy_v1beta1_FromProto(mapCtx, in.GetRetryPolicy())
	out.Timeout = Duration_v1beta1_FromProto(mapCtx, in.GetTimeout())
	out.URLRewrite = URLRewrite_v1beta1_FromProto(mapCtx, in.GetUrlRewrite())
	out.WeightedBackendServices = direct.Slice_FromProto(mapCtx, in.WeightedBackendServices, WeightedBackendService_v1beta1_FromProto)
	return out
}
func HTTPRouteAction_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPRouteAction) *pb.HttpRouteAction {
	if in == nil {
		return nil
	}
	out := &pb.HttpRouteAction{}
	out.CorsPolicy = CorsPolicy_v1beta1_ToProto(mapCtx, in.CorsPolicy)
	out.FaultInjectionPolicy = HTTPFaultInjection_v1beta1_ToProto(mapCtx, in.FaultInjectionPolicy)
	out.MaxStreamDuration = Duration_v1beta1_ToProto(mapCtx, in.MaxStreamDuration)
	out.RequestMirrorPolicy = RequestMirrorPolicy_v1beta1_ToProto(mapCtx, in.RequestMirrorPolicy)
	out.RetryPolicy = HTTPRetryPolicy_v1beta1_ToProto(mapCtx, in.RetryPolicy)
	out.Timeout = Duration_v1beta1_ToProto(mapCtx, in.Timeout)
	out.UrlRewrite = URLRewrite_v1beta1_ToProto(mapCtx, in.URLRewrite)
	out.WeightedBackendServices = direct.Slice_ToProto(mapCtx, in.WeightedBackendServices, WeightedBackendService_v1beta1_ToProto)
	return out
}
func HTTPRouteRuleMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HttpRouteRuleMatch) *krm.HTTPRouteRuleMatch {
	if in == nil {
		return nil
	}
	out := &krm.HTTPRouteRuleMatch{}
	out.FullPathMatch = in.FullPathMatch
	out.HeaderMatches = direct.Slice_FromProto(mapCtx, in.HeaderMatches, HTTPHeaderMatch_v1beta1_FromProto)
	out.IgnoreCase = in.IgnoreCase
	out.MetadataFilters = direct.Slice_FromProto(mapCtx, in.MetadataFilters, MetadataFilter_v1beta1_FromProto)
	out.PathTemplateMatch = in.PathTemplateMatch
	out.PrefixMatch = in.PrefixMatch
	out.QueryParameterMatches = direct.Slice_FromProto(mapCtx, in.QueryParameterMatches, HTTPQueryParameterMatch_v1beta1_FromProto)
	out.RegexMatch = in.RegexMatch
	return out
}
func HTTPRouteRuleMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HTTPRouteRuleMatch) *pb.HttpRouteRuleMatch {
	if in == nil {
		return nil
	}
	out := &pb.HttpRouteRuleMatch{}
	out.FullPathMatch = in.FullPathMatch
	out.HeaderMatches = direct.Slice_ToProto(mapCtx, in.HeaderMatches, HTTPHeaderMatch_v1beta1_ToProto)
	out.IgnoreCase = in.IgnoreCase
	out.MetadataFilters = direct.Slice_ToProto(mapCtx, in.MetadataFilters, MetadataFilter_v1beta1_ToProto)
	out.PathTemplateMatch = in.PathTemplateMatch
	out.PrefixMatch = in.PrefixMatch
	out.QueryParameterMatches = direct.Slice_ToProto(mapCtx, in.QueryParameterMatches, HTTPQueryParameterMatch_v1beta1_ToProto)
	out.RegexMatch = in.RegexMatch
	return out
}
func HostRule_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.HostRule) *krm.HostRule {
	if in == nil {
		return nil
	}
	out := &krm.HostRule{}
	out.Description = in.Description
	out.Hosts = in.Hosts
	out.PathMatcher = in.PathMatcher
	return out
}
func HostRule_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.HostRule) *pb.HostRule {
	if in == nil {
		return nil
	}
	out := &pb.HostRule{}
	out.Description = in.Description
	out.Hosts = in.Hosts
	out.PathMatcher = in.PathMatcher
	return out
}
func Int64RangeMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.Int64RangeMatch) *krm.Int64RangeMatch {
	if in == nil {
		return nil
	}
	out := &krm.Int64RangeMatch{}
	out.RangeEnd = in.RangeEnd
	out.RangeStart = in.RangeStart
	return out
}
func Int64RangeMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.Int64RangeMatch) *pb.Int64RangeMatch {
	if in == nil {
		return nil
	}
	out := &pb.Int64RangeMatch{}
	out.RangeEnd = in.RangeEnd
	out.RangeStart = in.RangeStart
	return out
}
func InterconnectCircuitInfo_v1alpha1_FromProto(mapCtx *direct.MapContext, in *pb.InterconnectCircuitInfo) *krmcomputev1alpha1.InterconnectCircuitInfo {
	if in == nil {
		return nil
	}
	out := &krmcomputev1alpha1.InterconnectCircuitInfo{}
	out.CustomerDemarcID = in.CustomerDemarcId
	out.GoogleCircuitID = in.GoogleCircuitId
	out.GoogleDemarcID = in.GoogleDemarcId
	return out
}
func InterconnectCircuitInfo_v1alpha1_ToProto(mapCtx *direct.MapContext, in *krmcomputev1alpha1.InterconnectCircuitInfo) *pb.InterconnectCircuitInfo {
	if in == nil {
		return nil
	}
	out := &pb.InterconnectCircuitInfo{}
	out.CustomerDemarcId = in.CustomerDemarcID
	out.GoogleCircuitId = in.GoogleCircuitID
	out.GoogleDemarcId = in.GoogleDemarcID
	return out
}
func InterconnectMacsec_v1alpha1_FromProto(mapCtx *direct.MapContext, in *pb.InterconnectMacsec) *krmcomputev1alpha1.InterconnectMacsec {
	if in == nil {
		return nil
	}
	out := &krmcomputev1alpha1.InterconnectMacsec{}
	out.FailOpen = in.FailOpen
	out.PreSharedKeys = direct.Slice_FromProto(mapCtx, in.PreSharedKeys, InterconnectMacsecPreSharedKey_v1alpha1_FromProto)
	return out
}
func InterconnectMacsec_v1alpha1_ToProto(mapCtx *direct.MapContext, in *krmcomputev1alpha1.InterconnectMacsec) *pb.InterconnectMacsec {
	if in == nil {
		return nil
	}
	out := &pb.InterconnectMacsec{}
	out.FailOpen = in.FailOpen
	out.PreSharedKeys = direct.Slice_ToProto(mapCtx, in.PreSharedKeys, InterconnectMacsecPreSharedKey_v1alpha1_ToProto)
	return out
}
func InterconnectMacsecPreSharedKey_v1alpha1_FromProto(mapCtx *direct.MapContext, in *pb.InterconnectMacsecPreSharedKey) *krmcomputev1alpha1.InterconnectMacsecPreSharedKey {
	if in == nil {
		return nil
	}
	out := &krmcomputev1alpha1.InterconnectMacsecPreSharedKey{}
	out.Name = in.Name
	out.StartTime = in.StartTime
	return out
}
func InterconnectMacsecPreSharedKey_v1alpha1_ToProto(mapCtx *direct.MapContext, in *krmcomputev1alpha1.InterconnectMacsecPreSharedKey) *pb.InterconnectMacsecPreSharedKey {
	if in == nil {
		return nil
	}
	out := &pb.InterconnectMacsecPreSharedKey{}
	out.Name = in.Name
	out.StartTime = in.StartTime
	return out
}
func InterconnectOutageNotification_v1alpha1_FromProto(mapCtx *direct.MapContext, in *pb.InterconnectOutageNotification) *krmcomputev1alpha1.InterconnectOutageNotification {
	if in == nil {
		return nil
	}
	out := &krmcomputev1alpha1.InterconnectOutageNotification{}
	out.AffectedCircuits = in.AffectedCircuits
	out.Description = in.Description
	out.EndTime = in.EndTime
	out.IssueType = in.IssueType
	out.Name = in.Name
	out.Source = in.Source
	out.StartTime = in.StartTime
	out.State = in.State
	return out
}
func InterconnectOutageNotification_v1alpha1_ToProto(mapCtx *direct.MapContext, in *krmcomputev1alpha1.InterconnectOutageNotification) *pb.InterconnectOutageNotification {
	if in == nil {
		return nil
	}
	out := &pb.InterconnectOutageNotification{}
	out.AffectedCircuits = in.AffectedCircuits
	out.Description = in.Description
	out.EndTime = in.EndTime
	out.IssueType = in.IssueType
	out.Name = in.Name
	out.Source = in.Source
	out.StartTime = in.StartTime
	out.State = in.State
	return out
}
func MetadataFilter_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.MetadataFilter) *krm.MetadataFilter {
	if in == nil {
		return nil
	}
	out := &krm.MetadataFilter{}
	out.FilterLabels = direct.Slice_FromProto(mapCtx, in.FilterLabels, MetadataFilterLabelMatch_v1beta1_FromProto)
	out.FilterMatchCriteria = in.FilterMatchCriteria
	return out
}
func MetadataFilter_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.MetadataFilter) *pb.MetadataFilter {
	if in == nil {
		return nil
	}
	out := &pb.MetadataFilter{}
	out.FilterLabels = direct.Slice_ToProto(mapCtx, in.FilterLabels, MetadataFilterLabelMatch_v1beta1_ToProto)
	out.FilterMatchCriteria = in.FilterMatchCriteria
	return out
}
func MetadataFilterLabelMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.MetadataFilterLabelMatch) *krm.MetadataFilterLabelMatch {
	if in == nil {
		return nil
	}
	out := &krm.MetadataFilterLabelMatch{}
	out.Name = in.Name
	out.Value = in.Value
	return out
}
func MetadataFilterLabelMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.MetadataFilterLabelMatch) *pb.MetadataFilterLabelMatch {
	if in == nil {
		return nil
	}
	out := &pb.MetadataFilterLabelMatch{}
	out.Name = in.Name
	out.Value = in.Value
	return out
}
func NetworkAttachmentConnectedEndpoint_v1alpha1_FromProto(mapCtx *direct.MapContext, in *pb.NetworkAttachmentConnectedEndpoint) *krmcomputev1alpha1.NetworkAttachmentConnectedEndpoint {
	if in == nil {
		return nil
	}
	out := &krmcomputev1alpha1.NetworkAttachmentConnectedEndpoint{}
	out.IPAddress = in.IpAddress
	out.IPV6Address = in.Ipv6Address
	out.ProjectIDOrNum = in.ProjectIdOrNum
	out.SecondaryIPCIDRRanges = in.SecondaryIpCidrRanges
	out.Status = in.Status
	out.Subnetwork = in.Subnetwork
	out.SubnetworkCIDRRange = in.SubnetworkCidrRange
	return out
}
func NetworkAttachmentConnectedEndpoint_v1alpha1_ToProto(mapCtx *direct.MapContext, in *krmcomputev1alpha1.NetworkAttachmentConnectedEndpoint) *pb.NetworkAttachmentConnectedEndpoint {
	if in == nil {
		return nil
	}
	out := &pb.NetworkAttachmentConnectedEndpoint{}
	out.IpAddress = in.IPAddress
	out.Ipv6Address = in.IPV6Address
	out.ProjectIdOrNum = in.ProjectIDOrNum
	out.SecondaryIpCidrRanges = in.SecondaryIPCIDRRanges
	out.Status = in.Status
	out.Subnetwork = in.Subnetwork
	out.SubnetworkCidrRange = in.SubnetworkCIDRRange
	return out
}
func RequestMirrorPolicy_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.RequestMirrorPolicy) *krm.RequestMirrorPolicy {
	if in == nil {
		return nil
	}
	out := &krm.RequestMirrorPolicy{}
	out.BackendService = in.BackendService
	return out
}
func RequestMirrorPolicy_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.RequestMirrorPolicy) *pb.RequestMirrorPolicy {
	if in == nil {
		return nil
	}
	out := &pb.RequestMirrorPolicy{}
	out.BackendService = in.BackendService
	return out
}
func SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig) *krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig{}
	out.AutoDeployConfidenceThreshold = in.AutoDeployConfidenceThreshold
	out.AutoDeployExpirationSec = in.AutoDeployExpirationSec
	out.AutoDeployImpactedBaselineThreshold = in.AutoDeployImpactedBaselineThreshold
	out.AutoDeployLoadThreshold = in.AutoDeployLoadThreshold
	out.DetectionAbsoluteQps = in.DetectionAbsoluteQps
	out.DetectionLoadThreshold = in.DetectionLoadThreshold
	out.DetectionRelativeToBaselineQps = in.DetectionRelativeToBaselineQps
	out.Name = in.Name
	out.TrafficGranularityConfigs = direct.Slice_FromProto(mapCtx, in.TrafficGranularityConfigs, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig_v1beta1_FromProto)
	return out
}
func SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig) *pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig{}
	out.AutoDeployConfidenceThreshold = in.AutoDeployConfidenceThreshold
	out.AutoDeployExpirationSec = in.AutoDeployExpirationSec
	out.AutoDeployImpactedBaselineThreshold = in.AutoDeployImpactedBaselineThreshold
	out.AutoDeployLoadThreshold = in.AutoDeployLoadThreshold
	out.DetectionAbsoluteQps = in.DetectionAbsoluteQps
	out.DetectionLoadThreshold = in.DetectionLoadThreshold
	out.DetectionRelativeToBaselineQps = in.DetectionRelativeToBaselineQps
	out.Name = in.Name
	out.TrafficGranularityConfigs = direct.Slice_ToProto(mapCtx, in.TrafficGranularityConfigs, SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig_v1beta1_ToProto)
	return out
}
func SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig) *krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig{}
	out.EnableEachUniqueValue = in.EnableEachUniqueValue
	out.Type = in.Type
	out.Value = in.Value
	return out
}
func SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig) *pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig{}
	out.EnableEachUniqueValue = in.EnableEachUniqueValue
	out.Type = in.Type
	out.Value = in.Value
	return out
}
func SecurityPolicyAdvancedOptionsConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyAdvancedOptionsConfig) *krm.SecurityPolicyAdvancedOptionsConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyAdvancedOptionsConfig{}
	out.JsonCustomConfig = SecurityPolicyAdvancedOptionsConfigJsonCustomConfig_v1beta1_FromProto(mapCtx, in.GetJsonCustomConfig())
	out.JsonParsing = in.JsonParsing
	out.LogLevel = in.LogLevel
	out.UserIPRequestHeaders = in.UserIpRequestHeaders
	return out
}
func SecurityPolicyAdvancedOptionsConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyAdvancedOptionsConfig) *pb.SecurityPolicyAdvancedOptionsConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyAdvancedOptionsConfig{}
	out.JsonCustomConfig = SecurityPolicyAdvancedOptionsConfigJsonCustomConfig_v1beta1_ToProto(mapCtx, in.JsonCustomConfig)
	out.JsonParsing = in.JsonParsing
	out.LogLevel = in.LogLevel
	out.UserIpRequestHeaders = in.UserIPRequestHeaders
	return out
}
func SecurityPolicyAdvancedOptionsConfigJsonCustomConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig) *krm.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig{}
	out.ContentTypes = in.ContentTypes
	return out
}
func SecurityPolicyAdvancedOptionsConfigJsonCustomConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig) *pb.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyAdvancedOptionsConfigJsonCustomConfig{}
	out.ContentTypes = in.ContentTypes
	return out
}
func SecurityPolicyDdosProtectionConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyDdosProtectionConfig) *krm.SecurityPolicyDdosProtectionConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyDdosProtectionConfig{}
	out.DdosProtection = in.DdosProtection
	return out
}
func SecurityPolicyDdosProtectionConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyDdosProtectionConfig) *pb.SecurityPolicyDdosProtectionConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyDdosProtectionConfig{}
	out.DdosProtection = in.DdosProtection
	return out
}
func SecurityPolicyRule_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRule) *krm.SecurityPolicyRule {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRule{}
	out.Action = in.Action
	out.Description = in.Description
	out.HeaderAction = SecurityPolicyRuleHTTPHeaderAction_v1beta1_FromProto(mapCtx, in.GetHeaderAction())
	// MISSING: Kind
	out.Match = SecurityPolicyRuleMatcher_v1beta1_FromProto(mapCtx, in.GetMatch())
	// MISSING: NetworkMatch
	out.PreconfiguredWafConfig = SecurityPolicyRulePreconfiguredWafConfig_v1beta1_FromProto(mapCtx, in.GetPreconfiguredWafConfig())
	out.Preview = in.Preview
	out.Priority = in.Priority
	out.RateLimitOptions = SecurityPolicyRuleRateLimitOptions_v1beta1_FromProto(mapCtx, in.GetRateLimitOptions())
	out.RedirectOptions = SecurityPolicyRuleRedirectOptions_v1beta1_FromProto(mapCtx, in.GetRedirectOptions())
	return out
}
func SecurityPolicyRule_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRule) *pb.SecurityPolicyRule {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRule{}
	out.Action = in.Action
	out.Description = in.Description
	out.HeaderAction = SecurityPolicyRuleHTTPHeaderAction_v1beta1_ToProto(mapCtx, in.HeaderAction)
	// MISSING: Kind
	out.Match = SecurityPolicyRuleMatcher_v1beta1_ToProto(mapCtx, in.Match)
	// MISSING: NetworkMatch
	out.PreconfiguredWafConfig = SecurityPolicyRulePreconfiguredWafConfig_v1beta1_ToProto(mapCtx, in.PreconfiguredWafConfig)
	out.Preview = in.Preview
	out.Priority = in.Priority
	out.RateLimitOptions = SecurityPolicyRuleRateLimitOptions_v1beta1_ToProto(mapCtx, in.RateLimitOptions)
	out.RedirectOptions = SecurityPolicyRuleRedirectOptions_v1beta1_ToProto(mapCtx, in.RedirectOptions)
	return out
}
func SecurityPolicyRuleHTTPHeaderAction_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleHttpHeaderAction) *krm.SecurityPolicyRuleHTTPHeaderAction {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleHTTPHeaderAction{}
	out.RequestHeadersToAdds = direct.Slice_FromProto(mapCtx, in.RequestHeadersToAdds, SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption_v1beta1_FromProto)
	return out
}
func SecurityPolicyRuleHTTPHeaderAction_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleHTTPHeaderAction) *pb.SecurityPolicyRuleHttpHeaderAction {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleHttpHeaderAction{}
	out.RequestHeadersToAdds = direct.Slice_ToProto(mapCtx, in.RequestHeadersToAdds, SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption_v1beta1_ToProto)
	return out
}
func SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleHttpHeaderActionHttpHeaderOption) *krm.SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption{}
	out.HeaderName = in.HeaderName
	out.HeaderValue = in.HeaderValue
	return out
}
func SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleHTTPHeaderActionHTTPHeaderOption) *pb.SecurityPolicyRuleHttpHeaderActionHttpHeaderOption {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleHttpHeaderActionHttpHeaderOption{}
	out.HeaderName = in.HeaderName
	out.HeaderValue = in.HeaderValue
	return out
}
func SecurityPolicyRuleMatcher_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleMatcher) *krm.SecurityPolicyRuleMatcher {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleMatcher{}
	out.Config = SecurityPolicyRuleMatcherConfig_v1beta1_FromProto(mapCtx, in.GetConfig())
	out.Expr = SecurityPolicyRuleMatcherExpr_v1beta1_FromProto(mapCtx, in.GetExpr())
	// MISSING: ExprOptions
	out.VersionedExpr = in.VersionedExpr
	return out
}
func SecurityPolicyRuleMatcher_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleMatcher) *pb.SecurityPolicyRuleMatcher {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleMatcher{}
	out.Config = SecurityPolicyRuleMatcherConfig_v1beta1_ToProto(mapCtx, in.Config)
	out.Expr = SecurityPolicyRuleMatcherExpr_v1beta1_ToProto(mapCtx, in.Expr)
	// MISSING: ExprOptions
	out.VersionedExpr = in.VersionedExpr
	return out
}
func SecurityPolicyRuleMatcherConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleMatcherConfig) *krm.SecurityPolicyRuleMatcherConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleMatcherConfig{}
	out.SrcIPRanges = in.SrcIpRanges
	return out
}
func SecurityPolicyRuleMatcherConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleMatcherConfig) *pb.SecurityPolicyRuleMatcherConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleMatcherConfig{}
	out.SrcIpRanges = in.SrcIPRanges
	return out
}
func SecurityPolicyRuleMatcherExprOptions_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleMatcherExprOptions) *krm.SecurityPolicyRuleMatcherExprOptions {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleMatcherExprOptions{}
	out.RecaptchaOptions = SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions_v1beta1_FromProto(mapCtx, in.GetRecaptchaOptions())
	return out
}
func SecurityPolicyRuleMatcherExprOptions_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleMatcherExprOptions) *pb.SecurityPolicyRuleMatcherExprOptions {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleMatcherExprOptions{}
	out.RecaptchaOptions = SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions_v1beta1_ToProto(mapCtx, in.RecaptchaOptions)
	return out
}
func SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions) *krm.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions{}
	out.ActionTokenSiteKeys = in.ActionTokenSiteKeys
	out.SessionTokenSiteKeys = in.SessionTokenSiteKeys
	return out
}
func SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions) *pb.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions{}
	out.ActionTokenSiteKeys = in.ActionTokenSiteKeys
	out.SessionTokenSiteKeys = in.SessionTokenSiteKeys
	return out
}
func SecurityPolicyRuleNetworkMatcher_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleNetworkMatcher) *krm.SecurityPolicyRuleNetworkMatcher {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleNetworkMatcher{}
	out.DestIPRanges = in.DestIpRanges
	out.DestPorts = in.DestPorts
	out.IPProtocols = in.IpProtocols
	out.SrcAsns = in.SrcAsns
	out.SrcIPRanges = in.SrcIpRanges
	out.SrcPorts = in.SrcPorts
	out.SrcRegionCodes = in.SrcRegionCodes
	out.UserDefinedFields = direct.Slice_FromProto(mapCtx, in.UserDefinedFields, SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch_v1beta1_FromProto)
	return out
}
func SecurityPolicyRuleNetworkMatcher_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleNetworkMatcher) *pb.SecurityPolicyRuleNetworkMatcher {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleNetworkMatcher{}
	out.DestIpRanges = in.DestIPRanges
	out.DestPorts = in.DestPorts
	out.IpProtocols = in.IPProtocols
	out.SrcAsns = in.SrcAsns
	out.SrcIpRanges = in.SrcIPRanges
	out.SrcPorts = in.SrcPorts
	out.SrcRegionCodes = in.SrcRegionCodes
	out.UserDefinedFields = direct.Slice_ToProto(mapCtx, in.UserDefinedFields, SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch_v1beta1_ToProto)
	return out
}
func SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch) *krm.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch{}
	out.Name = in.Name
	out.Values = in.Values
	return out
}
func SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch) *pb.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch{}
	out.Name = in.Name
	out.Values = in.Values
	return out
}
func SecurityPolicyRuleRateLimitOptions_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleRateLimitOptions) *krm.SecurityPolicyRuleRateLimitOptions {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleRateLimitOptions{}
	out.BanDurationSec = in.BanDurationSec
	out.BanThreshold = SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_FromProto(mapCtx, in.GetBanThreshold())
	out.ConformAction = in.ConformAction
	out.EnforceOnKey = in.EnforceOnKey
	out.EnforceOnKeyConfigs = direct.Slice_FromProto(mapCtx, in.EnforceOnKeyConfigs, SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig_v1beta1_FromProto)
	out.EnforceOnKeyName = in.EnforceOnKeyName
	out.ExceedAction = in.ExceedAction
	out.ExceedRedirectOptions = SecurityPolicyRuleRedirectOptions_v1beta1_FromProto(mapCtx, in.GetExceedRedirectOptions())
	out.RateLimitThreshold = SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_FromProto(mapCtx, in.GetRateLimitThreshold())
	return out
}
func SecurityPolicyRuleRateLimitOptions_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleRateLimitOptions) *pb.SecurityPolicyRuleRateLimitOptions {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleRateLimitOptions{}
	out.BanDurationSec = in.BanDurationSec
	out.BanThreshold = SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_ToProto(mapCtx, in.BanThreshold)
	out.ConformAction = in.ConformAction
	out.EnforceOnKey = in.EnforceOnKey
	out.EnforceOnKeyConfigs = direct.Slice_ToProto(mapCtx, in.EnforceOnKeyConfigs, SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig_v1beta1_ToProto)
	out.EnforceOnKeyName = in.EnforceOnKeyName
	out.ExceedAction = in.ExceedAction
	out.ExceedRedirectOptions = SecurityPolicyRuleRedirectOptions_v1beta1_ToProto(mapCtx, in.ExceedRedirectOptions)
	out.RateLimitThreshold = SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_ToProto(mapCtx, in.RateLimitThreshold)
	return out
}
func SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig) *krm.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig{}
	out.EnforceOnKeyName = in.EnforceOnKeyName
	out.EnforceOnKeyType = in.EnforceOnKeyType
	return out
}
func SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig) *pb.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig{}
	out.EnforceOnKeyName = in.EnforceOnKeyName
	out.EnforceOnKeyType = in.EnforceOnKeyType
	return out
}
func SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleRateLimitOptionsThreshold) *krm.SecurityPolicyRuleRateLimitOptionsThreshold {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleRateLimitOptionsThreshold{}
	out.Count = in.Count
	out.IntervalSec = in.IntervalSec
	return out
}
func SecurityPolicyRuleRateLimitOptionsThreshold_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleRateLimitOptionsThreshold) *pb.SecurityPolicyRuleRateLimitOptionsThreshold {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleRateLimitOptionsThreshold{}
	out.Count = in.Count
	out.IntervalSec = in.IntervalSec
	return out
}
func SecurityPolicyRuleRedirectOptions_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyRuleRedirectOptions) *krm.SecurityPolicyRuleRedirectOptions {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyRuleRedirectOptions{}
	out.Target = in.Target
	out.Type = in.Type
	return out
}
func SecurityPolicyRuleRedirectOptions_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyRuleRedirectOptions) *pb.SecurityPolicyRuleRedirectOptions {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyRuleRedirectOptions{}
	out.Target = in.Target
	out.Type = in.Type
	return out
}
func SecurityPolicyUserDefinedField_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SecurityPolicyUserDefinedField) *krm.SecurityPolicyUserDefinedField {
	if in == nil {
		return nil
	}
	out := &krm.SecurityPolicyUserDefinedField{}
	out.Base = in.Base
	out.Mask = in.Mask
	out.Name = in.Name
	out.Offset = in.Offset
	out.Size = in.Size
	return out
}
func SecurityPolicyUserDefinedField_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SecurityPolicyUserDefinedField) *pb.SecurityPolicyUserDefinedField {
	if in == nil {
		return nil
	}
	out := &pb.SecurityPolicyUserDefinedField{}
	out.Base = in.Base
	out.Mask = in.Mask
	out.Name = in.Name
	out.Offset = in.Offset
	out.Size = in.Size
	return out
}
func SubnetworkLogConfig_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SubnetworkLogConfig) *krm.SubnetworkLogConfig {
	if in == nil {
		return nil
	}
	out := &krm.SubnetworkLogConfig{}
	out.AggregationInterval = in.AggregationInterval
	// MISSING: Enable
	out.FilterExpr = in.FilterExpr
	out.FlowSampling = in.FlowSampling
	out.Metadata = in.Metadata
	out.MetadataFields = in.MetadataFields
	return out
}
func SubnetworkLogConfig_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SubnetworkLogConfig) *pb.SubnetworkLogConfig {
	if in == nil {
		return nil
	}
	out := &pb.SubnetworkLogConfig{}
	out.AggregationInterval = in.AggregationInterval
	// MISSING: Enable
	out.FilterExpr = in.FilterExpr
	out.FlowSampling = in.FlowSampling
	out.Metadata = in.Metadata
	out.MetadataFields = in.MetadataFields
	return out
}
func SubnetworkParams_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SubnetworkParams) *krm.SubnetworkParams {
	if in == nil {
		return nil
	}
	out := &krm.SubnetworkParams{}
	out.ResourceManagerTags = in.ResourceManagerTags
	return out
}
func SubnetworkParams_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SubnetworkParams) *pb.SubnetworkParams {
	if in == nil {
		return nil
	}
	out := &pb.SubnetworkParams{}
	out.ResourceManagerTags = in.ResourceManagerTags
	return out
}
func SubnetworkSecondaryRange_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.SubnetworkSecondaryRange) *krm.SubnetworkSecondaryRange {
	if in == nil {
		return nil
	}
	out := &krm.SubnetworkSecondaryRange{}
	out.IPCIDRRange = in.IpCidrRange
	out.RangeName = in.RangeName
	// MISSING: ReservedInternalRange
	return out
}
func SubnetworkSecondaryRange_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.SubnetworkSecondaryRange) *pb.SubnetworkSecondaryRange {
	if in == nil {
		return nil
	}
	out := &pb.SubnetworkSecondaryRange{}
	out.IpCidrRange = in.IPCIDRRange
	out.RangeName = in.RangeName
	// MISSING: ReservedInternalRange
	return out
}
func URLMapTestHeader_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.UrlMapTestHeader) *krm.URLMapTestHeader {
	if in == nil {
		return nil
	}
	out := &krm.URLMapTestHeader{}
	out.Name = in.Name
	out.Value = in.Value
	return out
}
func URLMapTestHeader_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.URLMapTestHeader) *pb.UrlMapTestHeader {
	if in == nil {
		return nil
	}
	out := &pb.UrlMapTestHeader{}
	out.Name = in.Name
	out.Value = in.Value
	return out
}
func URLRewrite_v1beta1_FromProto(mapCtx *direct.MapContext, in *pb.UrlRewrite) *krm.URLRewrite {
	if in == nil {
		return nil
	}
	out := &krm.URLRewrite{}
	out.HostRewrite = in.HostRewrite
	out.PathPrefixRewrite = in.PathPrefixRewrite
	out.PathTemplateRewrite = in.PathTemplateRewrite
	return out
}
func URLRewrite_v1beta1_ToProto(mapCtx *direct.MapContext, in *krm.URLRewrite) *pb.UrlRewrite {
	if in == nil {
		return nil
	}
	out := &pb.UrlRewrite{}
	out.HostRewrite = in.HostRewrite
	out.PathPrefixRewrite = in.PathPrefixRewrite
	out.PathTemplateRewrite = in.PathTemplateRewrite
	return out
}
