// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by dev/tasks/generate-all. DO NOT EDIT.
// +generated:mapper
// krm.group: sql.cnrm.cloud.google.com
// krm.version: v1beta1
// proto.service: google.cloud.sql.v1beta4

package sql

import (
	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/sql/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	pb "github.com/GoogleCloudPlatform/k8s-config-connector/pkg/gcpclients/generated/google/cloud/sql/v1beta4"
)

func AclEntry_FromProto(mapCtx *direct.MapContext, in *pb.AclEntry) *krm.AclEntry {
	if in == nil {
		return nil
	}
	out := &krm.AclEntry{}
	out.Value = direct.LazyPtr(in.GetValue())
	out.ExpirationTime = direct.StringTimestamp_FromProto(mapCtx, in.GetExpirationTime())
	out.Name = direct.LazyPtr(in.GetName())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func AclEntry_ToProto(mapCtx *direct.MapContext, in *krm.AclEntry) *pb.AclEntry {
	if in == nil {
		return nil
	}
	out := &pb.AclEntry{}
	out.Value = direct.ValueOf(in.Value)
	out.ExpirationTime = direct.StringTimestamp_ToProto(mapCtx, in.ExpirationTime)
	out.Name = direct.ValueOf(in.Name)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func AdvancedMachineFeatures_FromProto(mapCtx *direct.MapContext, in *pb.AdvancedMachineFeatures) *krm.AdvancedMachineFeatures {
	if in == nil {
		return nil
	}
	out := &krm.AdvancedMachineFeatures{}
	out.ThreadsPerCore = direct.LazyPtr(in.GetThreadsPerCore())
	return out
}
func AdvancedMachineFeatures_ToProto(mapCtx *direct.MapContext, in *krm.AdvancedMachineFeatures) *pb.AdvancedMachineFeatures {
	if in == nil {
		return nil
	}
	out := &pb.AdvancedMachineFeatures{}
	out.ThreadsPerCore = direct.ValueOf(in.ThreadsPerCore)
	return out
}
func AvailableDatabaseVersion_FromProto(mapCtx *direct.MapContext, in *pb.AvailableDatabaseVersion) *krm.AvailableDatabaseVersion {
	if in == nil {
		return nil
	}
	out := &krm.AvailableDatabaseVersion{}
	out.MajorVersion = in.MajorVersion
	out.Name = in.Name
	out.DisplayName = in.DisplayName
	return out
}
func AvailableDatabaseVersion_ToProto(mapCtx *direct.MapContext, in *krm.AvailableDatabaseVersion) *pb.AvailableDatabaseVersion {
	if in == nil {
		return nil
	}
	out := &pb.AvailableDatabaseVersion{}
	out.MajorVersion = in.MajorVersion
	out.Name = in.Name
	out.DisplayName = in.DisplayName
	return out
}
func BackupConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.BackupConfiguration) *krm.BackupConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.BackupConfiguration{}
	out.StartTime = direct.LazyPtr(in.GetStartTime())
	out.Enabled = direct.BoolValue_FromProto(mapCtx, in.GetEnabled())
	out.Kind = direct.LazyPtr(in.GetKind())
	out.BinaryLogEnabled = direct.BoolValue_FromProto(mapCtx, in.GetBinaryLogEnabled())
	out.ReplicationLogArchivingEnabled = direct.BoolValue_FromProto(mapCtx, in.GetReplicationLogArchivingEnabled())
	out.Location = direct.LazyPtr(in.GetLocation())
	out.PointInTimeRecoveryEnabled = direct.BoolValue_FromProto(mapCtx, in.GetPointInTimeRecoveryEnabled())
	out.TransactionLogRetentionDays = Int32Value_FromProto(mapCtx, in.GetTransactionLogRetentionDays())
	out.BackupRetentionSettings = BackupRetentionSettings_FromProto(mapCtx, in.GetBackupRetentionSettings())
	// MISSING: TransactionalLogStorageState
	return out
}
func BackupConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.BackupConfiguration) *pb.BackupConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.BackupConfiguration{}
	out.StartTime = direct.ValueOf(in.StartTime)
	out.Enabled = direct.BoolValue_ToProto(mapCtx, in.Enabled)
	out.Kind = direct.ValueOf(in.Kind)
	out.BinaryLogEnabled = direct.BoolValue_ToProto(mapCtx, in.BinaryLogEnabled)
	out.ReplicationLogArchivingEnabled = direct.BoolValue_ToProto(mapCtx, in.ReplicationLogArchivingEnabled)
	out.Location = direct.ValueOf(in.Location)
	out.PointInTimeRecoveryEnabled = direct.BoolValue_ToProto(mapCtx, in.PointInTimeRecoveryEnabled)
	out.TransactionLogRetentionDays = Int32Value_ToProto(mapCtx, in.TransactionLogRetentionDays)
	out.BackupRetentionSettings = BackupRetentionSettings_ToProto(mapCtx, in.BackupRetentionSettings)
	// MISSING: TransactionalLogStorageState
	return out
}
func BackupConfigurationObservedState_FromProto(mapCtx *direct.MapContext, in *pb.BackupConfiguration) *krm.BackupConfigurationObservedState {
	if in == nil {
		return nil
	}
	out := &krm.BackupConfigurationObservedState{}
	// MISSING: StartTime
	// MISSING: Enabled
	// MISSING: Kind
	// MISSING: BinaryLogEnabled
	// MISSING: ReplicationLogArchivingEnabled
	// MISSING: Location
	// MISSING: PointInTimeRecoveryEnabled
	// MISSING: TransactionLogRetentionDays
	// MISSING: BackupRetentionSettings
	out.TransactionalLogStorageState = direct.Enum_FromProto(mapCtx, in.GetTransactionalLogStorageState())
	return out
}
func BackupConfigurationObservedState_ToProto(mapCtx *direct.MapContext, in *krm.BackupConfigurationObservedState) *pb.BackupConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.BackupConfiguration{}
	// MISSING: StartTime
	// MISSING: Enabled
	// MISSING: Kind
	// MISSING: BinaryLogEnabled
	// MISSING: ReplicationLogArchivingEnabled
	// MISSING: Location
	// MISSING: PointInTimeRecoveryEnabled
	// MISSING: TransactionLogRetentionDays
	// MISSING: BackupRetentionSettings
	if oneof := BackupConfigurationObservedState_TransactionalLogStorageState_ToProto(mapCtx, in.TransactionalLogStorageState); oneof != nil {
		out.TransactionalLogStorageState = oneof
	}
	return out
}
func BackupRetentionSettings_FromProto(mapCtx *direct.MapContext, in *pb.BackupRetentionSettings) *krm.BackupRetentionSettings {
	if in == nil {
		return nil
	}
	out := &krm.BackupRetentionSettings{}
	out.RetentionUnit = direct.Enum_FromProto(mapCtx, in.GetRetentionUnit())
	out.RetainedBackups = Int32Value_FromProto(mapCtx, in.GetRetainedBackups())
	return out
}
func BackupRetentionSettings_ToProto(mapCtx *direct.MapContext, in *krm.BackupRetentionSettings) *pb.BackupRetentionSettings {
	if in == nil {
		return nil
	}
	out := &pb.BackupRetentionSettings{}
	out.RetentionUnit = direct.Enum_ToProto[pb.BackupRetentionSettings_RetentionUnit](mapCtx, in.RetentionUnit)
	out.RetainedBackups = Int32Value_ToProto(mapCtx, in.RetainedBackups)
	return out
}
func DataCacheConfig_FromProto(mapCtx *direct.MapContext, in *pb.DataCacheConfig) *krm.DataCacheConfig {
	if in == nil {
		return nil
	}
	out := &krm.DataCacheConfig{}
	out.DataCacheEnabled = direct.LazyPtr(in.GetDataCacheEnabled())
	return out
}
func DataCacheConfig_ToProto(mapCtx *direct.MapContext, in *krm.DataCacheConfig) *pb.DataCacheConfig {
	if in == nil {
		return nil
	}
	out := &pb.DataCacheConfig{}
	out.DataCacheEnabled = direct.ValueOf(in.DataCacheEnabled)
	return out
}
func DatabaseFlags_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseFlags) *krm.DatabaseFlags {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseFlags{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Value = direct.LazyPtr(in.GetValue())
	return out
}
func DatabaseFlags_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseFlags) *pb.DatabaseFlags {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseFlags{}
	out.Name = direct.ValueOf(in.Name)
	out.Value = direct.ValueOf(in.Value)
	return out
}
func DatabaseInstance_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseInstance) *krm.DatabaseInstance {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseInstance{}
	out.Kind = direct.LazyPtr(in.GetKind())
	out.State = direct.Enum_FromProto(mapCtx, in.GetState())
	out.DatabaseVersion = direct.Enum_FromProto(mapCtx, in.GetDatabaseVersion())
	out.Settings = Settings_FromProto(mapCtx, in.GetSettings())
	out.Etag = direct.LazyPtr(in.GetEtag())
	out.FailoverReplica = DatabaseInstance_SQLFailoverReplica_FromProto(mapCtx, in.GetFailoverReplica())
	out.MasterInstanceName = direct.LazyPtr(in.GetMasterInstanceName())
	out.ReplicaNames = in.ReplicaNames
	out.MaxDiskSize = direct.Int64Value_FromProto(mapCtx, in.GetMaxDiskSize())
	out.CurrentDiskSize = direct.Int64Value_FromProto(mapCtx, in.GetCurrentDiskSize())
	out.IPAddresses = direct.Slice_FromProto(mapCtx, in.IpAddresses, IPMapping_FromProto)
	out.ServerCACert = SSLCert_FromProto(mapCtx, in.GetServerCaCert())
	out.InstanceType = direct.Enum_FromProto(mapCtx, in.GetInstanceType())
	out.Project = direct.LazyPtr(in.GetProject())
	out.IPV6Address = direct.LazyPtr(in.GetIpv6Address())
	out.ServiceAccountEmailAddress = direct.LazyPtr(in.GetServiceAccountEmailAddress())
	out.OnPremisesConfiguration = OnPremisesConfiguration_FromProto(mapCtx, in.GetOnPremisesConfiguration())
	out.ReplicaConfiguration = ReplicaConfiguration_FromProto(mapCtx, in.GetReplicaConfiguration())
	out.BackendType = direct.Enum_FromProto(mapCtx, in.GetBackendType())
	out.SelfLink = direct.LazyPtr(in.GetSelfLink())
	out.SuspensionReason = direct.EnumSlice_FromProto(mapCtx, in.SuspensionReason)
	out.ConnectionName = direct.LazyPtr(in.GetConnectionName())
	out.Name = direct.LazyPtr(in.GetName())
	out.Region = direct.LazyPtr(in.GetRegion())
	out.GCEZone = direct.LazyPtr(in.GetGceZone())
	out.SecondaryGCEZone = direct.LazyPtr(in.GetSecondaryGceZone())
	out.DiskEncryptionConfiguration = DiskEncryptionConfiguration_FromProto(mapCtx, in.GetDiskEncryptionConfiguration())
	out.DiskEncryptionStatus = DiskEncryptionStatus_FromProto(mapCtx, in.GetDiskEncryptionStatus())
	out.RootPassword = direct.LazyPtr(in.GetRootPassword())
	out.ScheduledMaintenance = DatabaseInstance_SQLScheduledMaintenance_FromProto(mapCtx, in.GetScheduledMaintenance())
	out.SatisfiesPzs = direct.BoolValue_FromProto(mapCtx, in.GetSatisfiesPzs())
	// MISSING: DatabaseInstalledVersion
	out.OutOfDiskReport = DatabaseInstance_SQLOutOfDiskReport_FromProto(mapCtx, in.GetOutOfDiskReport())
	// MISSING: CreateTime
	// MISSING: AvailableMaintenanceVersions
	out.MaintenanceVersion = direct.LazyPtr(in.GetMaintenanceVersion())
	// MISSING: UpgradableDatabaseVersions
	out.SQLNetworkArchitecture = direct.Enum_FromProto(mapCtx, in.GetSqlNetworkArchitecture())
	// MISSING: PSCServiceAttachmentLink
	// MISSING: DNSName
	// MISSING: PrimaryDNSName
	// MISSING: WriteEndpoint
	out.ReplicationCluster = ReplicationCluster_FromProto(mapCtx, in.GetReplicationCluster())
	out.GeminiConfig = GeminiInstanceConfig_FromProto(mapCtx, in.GetGeminiConfig())
	return out
}
func DatabaseInstance_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseInstance) *pb.DatabaseInstance {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseInstance{}
	out.Kind = direct.ValueOf(in.Kind)
	out.State = direct.Enum_ToProto[pb.DatabaseInstance_SqlInstanceState](mapCtx, in.State)
	out.DatabaseVersion = direct.Enum_ToProto[pb.SqlDatabaseVersion](mapCtx, in.DatabaseVersion)
	out.Settings = Settings_ToProto(mapCtx, in.Settings)
	out.Etag = direct.ValueOf(in.Etag)
	out.FailoverReplica = DatabaseInstance_SQLFailoverReplica_ToProto(mapCtx, in.FailoverReplica)
	out.MasterInstanceName = direct.ValueOf(in.MasterInstanceName)
	out.ReplicaNames = in.ReplicaNames
	out.MaxDiskSize = direct.Int64Value_ToProto(mapCtx, in.MaxDiskSize)
	out.CurrentDiskSize = direct.Int64Value_ToProto(mapCtx, in.CurrentDiskSize)
	out.IpAddresses = direct.Slice_ToProto(mapCtx, in.IPAddresses, IPMapping_ToProto)
	out.ServerCaCert = SSLCert_ToProto(mapCtx, in.ServerCACert)
	out.InstanceType = direct.Enum_ToProto[pb.SqlInstanceType](mapCtx, in.InstanceType)
	out.Project = direct.ValueOf(in.Project)
	out.Ipv6Address = direct.ValueOf(in.IPV6Address)
	out.ServiceAccountEmailAddress = direct.ValueOf(in.ServiceAccountEmailAddress)
	out.OnPremisesConfiguration = OnPremisesConfiguration_ToProto(mapCtx, in.OnPremisesConfiguration)
	out.ReplicaConfiguration = ReplicaConfiguration_ToProto(mapCtx, in.ReplicaConfiguration)
	out.BackendType = direct.Enum_ToProto[pb.SqlBackendType](mapCtx, in.BackendType)
	out.SelfLink = direct.ValueOf(in.SelfLink)
	out.SuspensionReason = direct.EnumSlice_ToProto[pb.SqlSuspensionReason](mapCtx, in.SuspensionReason)
	out.ConnectionName = direct.ValueOf(in.ConnectionName)
	out.Name = direct.ValueOf(in.Name)
	out.Region = direct.ValueOf(in.Region)
	out.GceZone = direct.ValueOf(in.GCEZone)
	out.SecondaryGceZone = direct.ValueOf(in.SecondaryGCEZone)
	out.DiskEncryptionConfiguration = DiskEncryptionConfiguration_ToProto(mapCtx, in.DiskEncryptionConfiguration)
	out.DiskEncryptionStatus = DiskEncryptionStatus_ToProto(mapCtx, in.DiskEncryptionStatus)
	out.RootPassword = direct.ValueOf(in.RootPassword)
	out.ScheduledMaintenance = DatabaseInstance_SQLScheduledMaintenance_ToProto(mapCtx, in.ScheduledMaintenance)
	out.SatisfiesPzs = direct.BoolValue_ToProto(mapCtx, in.SatisfiesPzs)
	// MISSING: DatabaseInstalledVersion
	out.OutOfDiskReport = DatabaseInstance_SQLOutOfDiskReport_ToProto(mapCtx, in.OutOfDiskReport)
	// MISSING: CreateTime
	// MISSING: AvailableMaintenanceVersions
	out.MaintenanceVersion = direct.ValueOf(in.MaintenanceVersion)
	// MISSING: UpgradableDatabaseVersions
	if oneof := DatabaseInstance_SqlNetworkArchitecture_ToProto(mapCtx, in.SQLNetworkArchitecture); oneof != nil {
		out.SqlNetworkArchitecture = oneof
	}
	// MISSING: PSCServiceAttachmentLink
	// MISSING: DNSName
	// MISSING: PrimaryDNSName
	// MISSING: WriteEndpoint
	out.ReplicationCluster = ReplicationCluster_ToProto(mapCtx, in.ReplicationCluster)
	out.GeminiConfig = GeminiInstanceConfig_ToProto(mapCtx, in.GeminiConfig)
	return out
}
func DatabaseInstanceObservedState_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseInstance) *krm.DatabaseInstanceObservedState {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseInstanceObservedState{}
	// MISSING: Kind
	// MISSING: State
	// MISSING: DatabaseVersion
	out.Settings = SettingsObservedState_FromProto(mapCtx, in.GetSettings())
	// MISSING: Etag
	// MISSING: FailoverReplica
	// MISSING: MasterInstanceName
	// MISSING: ReplicaNames
	// MISSING: MaxDiskSize
	// MISSING: CurrentDiskSize
	// MISSING: IPAddresses
	// MISSING: ServerCACert
	// MISSING: InstanceType
	// MISSING: Project
	// MISSING: IPV6Address
	// MISSING: ServiceAccountEmailAddress
	// MISSING: OnPremisesConfiguration
	// MISSING: ReplicaConfiguration
	// MISSING: BackendType
	// MISSING: SelfLink
	// MISSING: SuspensionReason
	// MISSING: ConnectionName
	// MISSING: Name
	// MISSING: Region
	// MISSING: GCEZone
	// MISSING: SecondaryGCEZone
	// MISSING: DiskEncryptionConfiguration
	// MISSING: DiskEncryptionStatus
	// MISSING: RootPassword
	// MISSING: ScheduledMaintenance
	// MISSING: SatisfiesPzs
	out.DatabaseInstalledVersion = direct.LazyPtr(in.GetDatabaseInstalledVersion())
	// MISSING: OutOfDiskReport
	out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCreateTime())
	out.AvailableMaintenanceVersions = in.AvailableMaintenanceVersions
	// MISSING: MaintenanceVersion
	out.UpgradableDatabaseVersions = direct.Slice_FromProto(mapCtx, in.UpgradableDatabaseVersions, AvailableDatabaseVersion_FromProto)
	// MISSING: SQLNetworkArchitecture
	out.PSCServiceAttachmentLink = in.PscServiceAttachmentLink
	out.DNSName = in.DnsName
	out.PrimaryDNSName = in.PrimaryDnsName
	out.WriteEndpoint = in.WriteEndpoint
	out.ReplicationCluster = ReplicationClusterObservedState_FromProto(mapCtx, in.GetReplicationCluster())
	out.GeminiConfig = GeminiInstanceConfigObservedState_FromProto(mapCtx, in.GetGeminiConfig())
	return out
}
func DatabaseInstanceObservedState_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseInstanceObservedState) *pb.DatabaseInstance {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseInstance{}
	// MISSING: Kind
	// MISSING: State
	// MISSING: DatabaseVersion
	out.Settings = SettingsObservedState_ToProto(mapCtx, in.Settings)
	// MISSING: Etag
	// MISSING: FailoverReplica
	// MISSING: MasterInstanceName
	// MISSING: ReplicaNames
	// MISSING: MaxDiskSize
	// MISSING: CurrentDiskSize
	// MISSING: IPAddresses
	// MISSING: ServerCACert
	// MISSING: InstanceType
	// MISSING: Project
	// MISSING: IPV6Address
	// MISSING: ServiceAccountEmailAddress
	// MISSING: OnPremisesConfiguration
	// MISSING: ReplicaConfiguration
	// MISSING: BackendType
	// MISSING: SelfLink
	// MISSING: SuspensionReason
	// MISSING: ConnectionName
	// MISSING: Name
	// MISSING: Region
	// MISSING: GCEZone
	// MISSING: SecondaryGCEZone
	// MISSING: DiskEncryptionConfiguration
	// MISSING: DiskEncryptionStatus
	// MISSING: RootPassword
	// MISSING: ScheduledMaintenance
	// MISSING: SatisfiesPzs
	out.DatabaseInstalledVersion = direct.ValueOf(in.DatabaseInstalledVersion)
	// MISSING: OutOfDiskReport
	out.CreateTime = direct.StringTimestamp_ToProto(mapCtx, in.CreateTime)
	out.AvailableMaintenanceVersions = in.AvailableMaintenanceVersions
	// MISSING: MaintenanceVersion
	out.UpgradableDatabaseVersions = direct.Slice_ToProto(mapCtx, in.UpgradableDatabaseVersions, AvailableDatabaseVersion_ToProto)
	// MISSING: SQLNetworkArchitecture
	out.PscServiceAttachmentLink = in.PSCServiceAttachmentLink
	out.DnsName = in.DNSName
	out.PrimaryDnsName = in.PrimaryDNSName
	out.WriteEndpoint = in.WriteEndpoint
	out.ReplicationCluster = ReplicationClusterObservedState_ToProto(mapCtx, in.ReplicationCluster)
	out.GeminiConfig = GeminiInstanceConfigObservedState_ToProto(mapCtx, in.GeminiConfig)
	return out
}
func DatabaseInstance_SQLFailoverReplica_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseInstance_SqlFailoverReplica) *krm.DatabaseInstance_SQLFailoverReplica {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseInstance_SQLFailoverReplica{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Available = direct.BoolValue_FromProto(mapCtx, in.GetAvailable())
	return out
}
func DatabaseInstance_SQLFailoverReplica_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseInstance_SQLFailoverReplica) *pb.DatabaseInstance_SqlFailoverReplica {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseInstance_SqlFailoverReplica{}
	out.Name = direct.ValueOf(in.Name)
	out.Available = direct.BoolValue_ToProto(mapCtx, in.Available)
	return out
}
func DatabaseInstance_SQLOutOfDiskReport_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseInstance_SqlOutOfDiskReport) *krm.DatabaseInstance_SQLOutOfDiskReport {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseInstance_SQLOutOfDiskReport{}
	out.SQLOutOfDiskState = direct.Enum_FromProto(mapCtx, in.GetSqlOutOfDiskState())
	out.SQLMinRecommendedIncreaseSizeGB = in.SqlMinRecommendedIncreaseSizeGb
	return out
}
func DatabaseInstance_SQLOutOfDiskReport_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseInstance_SQLOutOfDiskReport) *pb.DatabaseInstance_SqlOutOfDiskReport {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseInstance_SqlOutOfDiskReport{}
	if oneof := DatabaseInstance_SQLOutOfDiskReport_SqlOutOfDiskState_ToProto(mapCtx, in.SQLOutOfDiskState); oneof != nil {
		out.SqlOutOfDiskState = oneof
	}
	out.SqlMinRecommendedIncreaseSizeGb = in.SQLMinRecommendedIncreaseSizeGB
	return out
}
func DatabaseInstance_SQLScheduledMaintenance_FromProto(mapCtx *direct.MapContext, in *pb.DatabaseInstance_SqlScheduledMaintenance) *krm.DatabaseInstance_SQLScheduledMaintenance {
	if in == nil {
		return nil
	}
	out := &krm.DatabaseInstance_SQLScheduledMaintenance{}
	out.StartTime = direct.StringTimestamp_FromProto(mapCtx, in.GetStartTime())
	out.CanDefer = direct.LazyPtr(in.GetCanDefer())
	out.CanReschedule = direct.LazyPtr(in.GetCanReschedule())
	out.ScheduleDeadlineTime = direct.StringTimestamp_FromProto(mapCtx, in.GetScheduleDeadlineTime())
	return out
}
func DatabaseInstance_SQLScheduledMaintenance_ToProto(mapCtx *direct.MapContext, in *krm.DatabaseInstance_SQLScheduledMaintenance) *pb.DatabaseInstance_SqlScheduledMaintenance {
	if in == nil {
		return nil
	}
	out := &pb.DatabaseInstance_SqlScheduledMaintenance{}
	out.StartTime = direct.StringTimestamp_ToProto(mapCtx, in.StartTime)
	out.CanDefer = direct.ValueOf(in.CanDefer)
	out.CanReschedule = direct.ValueOf(in.CanReschedule)
	out.ScheduleDeadlineTime = direct.StringTimestamp_ToProto(mapCtx, in.ScheduleDeadlineTime)
	return out
}
func DenyMaintenancePeriod_FromProto(mapCtx *direct.MapContext, in *pb.DenyMaintenancePeriod) *krm.DenyMaintenancePeriod {
	if in == nil {
		return nil
	}
	out := &krm.DenyMaintenancePeriod{}
	out.StartDate = direct.LazyPtr(in.GetStartDate())
	out.EndDate = direct.LazyPtr(in.GetEndDate())
	out.Time = direct.LazyPtr(in.GetTime())
	return out
}
func DenyMaintenancePeriod_ToProto(mapCtx *direct.MapContext, in *krm.DenyMaintenancePeriod) *pb.DenyMaintenancePeriod {
	if in == nil {
		return nil
	}
	out := &pb.DenyMaintenancePeriod{}
	out.StartDate = direct.ValueOf(in.StartDate)
	out.EndDate = direct.ValueOf(in.EndDate)
	out.Time = direct.ValueOf(in.Time)
	return out
}
func DiskEncryptionConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.DiskEncryptionConfiguration) *krm.DiskEncryptionConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.DiskEncryptionConfiguration{}
	out.KMSKeyName = direct.LazyPtr(in.GetKmsKeyName())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func DiskEncryptionConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.DiskEncryptionConfiguration) *pb.DiskEncryptionConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.DiskEncryptionConfiguration{}
	out.KmsKeyName = direct.ValueOf(in.KMSKeyName)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func DiskEncryptionStatus_FromProto(mapCtx *direct.MapContext, in *pb.DiskEncryptionStatus) *krm.DiskEncryptionStatus {
	if in == nil {
		return nil
	}
	out := &krm.DiskEncryptionStatus{}
	out.KMSKeyVersionName = direct.LazyPtr(in.GetKmsKeyVersionName())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func DiskEncryptionStatus_ToProto(mapCtx *direct.MapContext, in *krm.DiskEncryptionStatus) *pb.DiskEncryptionStatus {
	if in == nil {
		return nil
	}
	out := &pb.DiskEncryptionStatus{}
	out.KmsKeyVersionName = direct.ValueOf(in.KMSKeyVersionName)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func GeminiInstanceConfig_FromProto(mapCtx *direct.MapContext, in *pb.GeminiInstanceConfig) *krm.GeminiInstanceConfig {
	if in == nil {
		return nil
	}
	out := &krm.GeminiInstanceConfig{}
	// MISSING: Entitled
	// MISSING: GoogleVacuumMgmtEnabled
	// MISSING: OomSessionCancelEnabled
	// MISSING: ActiveQueryEnabled
	// MISSING: IndexAdvisorEnabled
	// MISSING: FlagRecommenderEnabled
	return out
}
func GeminiInstanceConfig_ToProto(mapCtx *direct.MapContext, in *krm.GeminiInstanceConfig) *pb.GeminiInstanceConfig {
	if in == nil {
		return nil
	}
	out := &pb.GeminiInstanceConfig{}
	// MISSING: Entitled
	// MISSING: GoogleVacuumMgmtEnabled
	// MISSING: OomSessionCancelEnabled
	// MISSING: ActiveQueryEnabled
	// MISSING: IndexAdvisorEnabled
	// MISSING: FlagRecommenderEnabled
	return out
}
func GeminiInstanceConfigObservedState_FromProto(mapCtx *direct.MapContext, in *pb.GeminiInstanceConfig) *krm.GeminiInstanceConfigObservedState {
	if in == nil {
		return nil
	}
	out := &krm.GeminiInstanceConfigObservedState{}
	out.Entitled = in.Entitled
	out.GoogleVacuumMgmtEnabled = in.GoogleVacuumMgmtEnabled
	out.OomSessionCancelEnabled = in.OomSessionCancelEnabled
	out.ActiveQueryEnabled = in.ActiveQueryEnabled
	out.IndexAdvisorEnabled = in.IndexAdvisorEnabled
	out.FlagRecommenderEnabled = in.FlagRecommenderEnabled
	return out
}
func GeminiInstanceConfigObservedState_ToProto(mapCtx *direct.MapContext, in *krm.GeminiInstanceConfigObservedState) *pb.GeminiInstanceConfig {
	if in == nil {
		return nil
	}
	out := &pb.GeminiInstanceConfig{}
	out.Entitled = in.Entitled
	out.GoogleVacuumMgmtEnabled = in.GoogleVacuumMgmtEnabled
	out.OomSessionCancelEnabled = in.OomSessionCancelEnabled
	out.ActiveQueryEnabled = in.ActiveQueryEnabled
	out.IndexAdvisorEnabled = in.IndexAdvisorEnabled
	out.FlagRecommenderEnabled = in.FlagRecommenderEnabled
	return out
}
func IPConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.IpConfiguration) *krm.IPConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.IPConfiguration{}
	out.IPV4Enabled = direct.BoolValue_FromProto(mapCtx, in.GetIpv4Enabled())
	out.PrivateNetwork = direct.LazyPtr(in.GetPrivateNetwork())
	out.RequireSSL = direct.BoolValue_FromProto(mapCtx, in.GetRequireSsl())
	out.AuthorizedNetworks = direct.Slice_FromProto(mapCtx, in.AuthorizedNetworks, AclEntry_FromProto)
	out.AllocatedIPRange = direct.LazyPtr(in.GetAllocatedIpRange())
	out.EnablePrivatePathForGoogleCloudServices = direct.BoolValue_FromProto(mapCtx, in.GetEnablePrivatePathForGoogleCloudServices())
	out.SSLMode = direct.Enum_FromProto(mapCtx, in.GetSslMode())
	out.PSCConfig = PSCConfig_FromProto(mapCtx, in.GetPscConfig())
	return out
}
func IPConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.IPConfiguration) *pb.IpConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.IpConfiguration{}
	out.Ipv4Enabled = direct.BoolValue_ToProto(mapCtx, in.IPV4Enabled)
	out.PrivateNetwork = direct.ValueOf(in.PrivateNetwork)
	out.RequireSsl = direct.BoolValue_ToProto(mapCtx, in.RequireSSL)
	out.AuthorizedNetworks = direct.Slice_ToProto(mapCtx, in.AuthorizedNetworks, AclEntry_ToProto)
	out.AllocatedIpRange = direct.ValueOf(in.AllocatedIPRange)
	out.EnablePrivatePathForGoogleCloudServices = direct.BoolValue_ToProto(mapCtx, in.EnablePrivatePathForGoogleCloudServices)
	out.SslMode = direct.Enum_ToProto[pb.IpConfiguration_SslMode](mapCtx, in.SSLMode)
	out.PscConfig = PSCConfig_ToProto(mapCtx, in.PSCConfig)
	return out
}
func IPMapping_FromProto(mapCtx *direct.MapContext, in *pb.IpMapping) *krm.IPMapping {
	if in == nil {
		return nil
	}
	out := &krm.IPMapping{}
	out.Type = direct.Enum_FromProto(mapCtx, in.GetType())
	out.IPAddress = direct.LazyPtr(in.GetIpAddress())
	out.TimeToRetire = direct.StringTimestamp_FromProto(mapCtx, in.GetTimeToRetire())
	return out
}
func IPMapping_ToProto(mapCtx *direct.MapContext, in *krm.IPMapping) *pb.IpMapping {
	if in == nil {
		return nil
	}
	out := &pb.IpMapping{}
	out.Type = direct.Enum_ToProto[pb.SqlIpAddressType](mapCtx, in.Type)
	out.IpAddress = direct.ValueOf(in.IPAddress)
	out.TimeToRetire = direct.StringTimestamp_ToProto(mapCtx, in.TimeToRetire)
	return out
}
func InsightsConfig_FromProto(mapCtx *direct.MapContext, in *pb.InsightsConfig) *krm.InsightsConfig {
	if in == nil {
		return nil
	}
	out := &krm.InsightsConfig{}
	out.QueryInsightsEnabled = direct.LazyPtr(in.GetQueryInsightsEnabled())
	out.RecordClientAddress = direct.LazyPtr(in.GetRecordClientAddress())
	out.RecordApplicationTags = direct.LazyPtr(in.GetRecordApplicationTags())
	out.QueryStringLength = Int32Value_FromProto(mapCtx, in.GetQueryStringLength())
	out.QueryPlansPerMinute = Int32Value_FromProto(mapCtx, in.GetQueryPlansPerMinute())
	return out
}
func InsightsConfig_ToProto(mapCtx *direct.MapContext, in *krm.InsightsConfig) *pb.InsightsConfig {
	if in == nil {
		return nil
	}
	out := &pb.InsightsConfig{}
	out.QueryInsightsEnabled = direct.ValueOf(in.QueryInsightsEnabled)
	out.RecordClientAddress = direct.ValueOf(in.RecordClientAddress)
	out.RecordApplicationTags = direct.ValueOf(in.RecordApplicationTags)
	out.QueryStringLength = Int32Value_ToProto(mapCtx, in.QueryStringLength)
	out.QueryPlansPerMinute = Int32Value_ToProto(mapCtx, in.QueryPlansPerMinute)
	return out
}
func InstanceReference_FromProto(mapCtx *direct.MapContext, in *pb.InstanceReference) *krm.InstanceReference {
	if in == nil {
		return nil
	}
	out := &krm.InstanceReference{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Region = direct.LazyPtr(in.GetRegion())
	out.Project = direct.LazyPtr(in.GetProject())
	return out
}
func InstanceReference_ToProto(mapCtx *direct.MapContext, in *krm.InstanceReference) *pb.InstanceReference {
	if in == nil {
		return nil
	}
	out := &pb.InstanceReference{}
	out.Name = direct.ValueOf(in.Name)
	out.Region = direct.ValueOf(in.Region)
	out.Project = direct.ValueOf(in.Project)
	return out
}
func LocationPreference_FromProto(mapCtx *direct.MapContext, in *pb.LocationPreference) *krm.LocationPreference {
	if in == nil {
		return nil
	}
	out := &krm.LocationPreference{}
	out.FollowGaeApplication = direct.LazyPtr(in.GetFollowGaeApplication())
	out.Zone = direct.LazyPtr(in.GetZone())
	out.SecondaryZone = direct.LazyPtr(in.GetSecondaryZone())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func LocationPreference_ToProto(mapCtx *direct.MapContext, in *krm.LocationPreference) *pb.LocationPreference {
	if in == nil {
		return nil
	}
	out := &pb.LocationPreference{}
	out.FollowGaeApplication = direct.ValueOf(in.FollowGaeApplication)
	out.Zone = direct.ValueOf(in.Zone)
	out.SecondaryZone = direct.ValueOf(in.SecondaryZone)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func MaintenanceWindow_FromProto(mapCtx *direct.MapContext, in *pb.MaintenanceWindow) *krm.MaintenanceWindow {
	if in == nil {
		return nil
	}
	out := &krm.MaintenanceWindow{}
	out.Hour = Int32Value_FromProto(mapCtx, in.GetHour())
	out.Day = Int32Value_FromProto(mapCtx, in.GetDay())
	out.UpdateTrack = direct.Enum_FromProto(mapCtx, in.GetUpdateTrack())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func MaintenanceWindow_ToProto(mapCtx *direct.MapContext, in *krm.MaintenanceWindow) *pb.MaintenanceWindow {
	if in == nil {
		return nil
	}
	out := &pb.MaintenanceWindow{}
	out.Hour = Int32Value_ToProto(mapCtx, in.Hour)
	out.Day = Int32Value_ToProto(mapCtx, in.Day)
	out.UpdateTrack = direct.Enum_ToProto[pb.SqlUpdateTrack](mapCtx, in.UpdateTrack)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func MySQLReplicaConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.MySqlReplicaConfiguration) *krm.MySQLReplicaConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.MySQLReplicaConfiguration{}
	out.DumpFilePath = direct.LazyPtr(in.GetDumpFilePath())
	out.Username = direct.LazyPtr(in.GetUsername())
	out.Password = direct.LazyPtr(in.GetPassword())
	out.ConnectRetryInterval = Int32Value_FromProto(mapCtx, in.GetConnectRetryInterval())
	out.MasterHeartbeatPeriod = direct.Int64Value_FromProto(mapCtx, in.GetMasterHeartbeatPeriod())
	out.CACertificate = direct.LazyPtr(in.GetCaCertificate())
	out.ClientCertificate = direct.LazyPtr(in.GetClientCertificate())
	out.ClientKey = direct.LazyPtr(in.GetClientKey())
	out.SSLCipher = direct.LazyPtr(in.GetSslCipher())
	out.VerifyServerCertificate = direct.BoolValue_FromProto(mapCtx, in.GetVerifyServerCertificate())
	out.Kind = direct.LazyPtr(in.GetKind())
	return out
}
func MySQLReplicaConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.MySQLReplicaConfiguration) *pb.MySqlReplicaConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.MySqlReplicaConfiguration{}
	out.DumpFilePath = direct.ValueOf(in.DumpFilePath)
	out.Username = direct.ValueOf(in.Username)
	out.Password = direct.ValueOf(in.Password)
	out.ConnectRetryInterval = Int32Value_ToProto(mapCtx, in.ConnectRetryInterval)
	out.MasterHeartbeatPeriod = direct.Int64Value_ToProto(mapCtx, in.MasterHeartbeatPeriod)
	out.CaCertificate = direct.ValueOf(in.CACertificate)
	out.ClientCertificate = direct.ValueOf(in.ClientCertificate)
	out.ClientKey = direct.ValueOf(in.ClientKey)
	out.SslCipher = direct.ValueOf(in.SSLCipher)
	out.VerifyServerCertificate = direct.BoolValue_ToProto(mapCtx, in.VerifyServerCertificate)
	out.Kind = direct.ValueOf(in.Kind)
	return out
}
func OnPremisesConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.OnPremisesConfiguration) *krm.OnPremisesConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.OnPremisesConfiguration{}
	out.HostPort = direct.LazyPtr(in.GetHostPort())
	out.Kind = direct.LazyPtr(in.GetKind())
	out.Username = direct.LazyPtr(in.GetUsername())
	out.Password = direct.LazyPtr(in.GetPassword())
	out.CACertificate = direct.LazyPtr(in.GetCaCertificate())
	out.ClientCertificate = direct.LazyPtr(in.GetClientCertificate())
	out.ClientKey = direct.LazyPtr(in.GetClientKey())
	out.DumpFilePath = direct.LazyPtr(in.GetDumpFilePath())
	out.SourceInstance = InstanceReference_FromProto(mapCtx, in.GetSourceInstance())
	return out
}
func OnPremisesConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.OnPremisesConfiguration) *pb.OnPremisesConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.OnPremisesConfiguration{}
	out.HostPort = direct.ValueOf(in.HostPort)
	out.Kind = direct.ValueOf(in.Kind)
	out.Username = direct.ValueOf(in.Username)
	out.Password = direct.ValueOf(in.Password)
	out.CaCertificate = direct.ValueOf(in.CACertificate)
	out.ClientCertificate = direct.ValueOf(in.ClientCertificate)
	out.ClientKey = direct.ValueOf(in.ClientKey)
	out.DumpFilePath = direct.ValueOf(in.DumpFilePath)
	out.SourceInstance = InstanceReference_ToProto(mapCtx, in.SourceInstance)
	return out
}
func PSCConfig_FromProto(mapCtx *direct.MapContext, in *pb.PscConfig) *krm.PSCConfig {
	if in == nil {
		return nil
	}
	out := &krm.PSCConfig{}
	out.PSCEnabled = in.PscEnabled
	out.AllowedConsumerProjects = in.AllowedConsumerProjects
	return out
}
func PSCConfig_ToProto(mapCtx *direct.MapContext, in *krm.PSCConfig) *pb.PscConfig {
	if in == nil {
		return nil
	}
	out := &pb.PscConfig{}
	out.PscEnabled = in.PSCEnabled
	out.AllowedConsumerProjects = in.AllowedConsumerProjects
	return out
}
func PasswordValidationPolicy_FromProto(mapCtx *direct.MapContext, in *pb.PasswordValidationPolicy) *krm.PasswordValidationPolicy {
	if in == nil {
		return nil
	}
	out := &krm.PasswordValidationPolicy{}
	out.MinLength = Int32Value_FromProto(mapCtx, in.GetMinLength())
	out.Complexity = direct.Enum_FromProto(mapCtx, in.GetComplexity())
	out.ReuseInterval = Int32Value_FromProto(mapCtx, in.GetReuseInterval())
	out.DisallowUsernameSubstring = direct.BoolValue_FromProto(mapCtx, in.GetDisallowUsernameSubstring())
	out.PasswordChangeInterval = direct.StringDuration_FromProto(mapCtx, in.GetPasswordChangeInterval())
	out.EnablePasswordPolicy = direct.BoolValue_FromProto(mapCtx, in.GetEnablePasswordPolicy())
	out.DisallowCompromisedCredentials = direct.BoolValue_FromProto(mapCtx, in.GetDisallowCompromisedCredentials())
	return out
}
func PasswordValidationPolicy_ToProto(mapCtx *direct.MapContext, in *krm.PasswordValidationPolicy) *pb.PasswordValidationPolicy {
	if in == nil {
		return nil
	}
	out := &pb.PasswordValidationPolicy{}
	out.MinLength = Int32Value_ToProto(mapCtx, in.MinLength)
	out.Complexity = direct.Enum_ToProto[pb.PasswordValidationPolicy_Complexity](mapCtx, in.Complexity)
	out.ReuseInterval = Int32Value_ToProto(mapCtx, in.ReuseInterval)
	out.DisallowUsernameSubstring = direct.BoolValue_ToProto(mapCtx, in.DisallowUsernameSubstring)
	out.PasswordChangeInterval = direct.StringDuration_ToProto(mapCtx, in.PasswordChangeInterval)
	out.EnablePasswordPolicy = direct.BoolValue_ToProto(mapCtx, in.EnablePasswordPolicy)
	out.DisallowCompromisedCredentials = direct.BoolValue_ToProto(mapCtx, in.DisallowCompromisedCredentials)
	return out
}
func ReplicaConfiguration_FromProto(mapCtx *direct.MapContext, in *pb.ReplicaConfiguration) *krm.ReplicaConfiguration {
	if in == nil {
		return nil
	}
	out := &krm.ReplicaConfiguration{}
	out.Kind = direct.LazyPtr(in.GetKind())
	out.MysqlReplicaConfiguration = MySQLReplicaConfiguration_FromProto(mapCtx, in.GetMysqlReplicaConfiguration())
	out.FailoverTarget = direct.BoolValue_FromProto(mapCtx, in.GetFailoverTarget())
	out.CascadableReplica = direct.BoolValue_FromProto(mapCtx, in.GetCascadableReplica())
	return out
}
func ReplicaConfiguration_ToProto(mapCtx *direct.MapContext, in *krm.ReplicaConfiguration) *pb.ReplicaConfiguration {
	if in == nil {
		return nil
	}
	out := &pb.ReplicaConfiguration{}
	out.Kind = direct.ValueOf(in.Kind)
	out.MysqlReplicaConfiguration = MySQLReplicaConfiguration_ToProto(mapCtx, in.MysqlReplicaConfiguration)
	out.FailoverTarget = direct.BoolValue_ToProto(mapCtx, in.FailoverTarget)
	out.CascadableReplica = direct.BoolValue_ToProto(mapCtx, in.CascadableReplica)
	return out
}

/* found existing non-generated mapping function "ReplicationClusterObservedState_FromProto", skipping
func ReplicationClusterObservedState_FromProto(mapCtx *direct.MapContext, in *pb.ReplicationCluster) *krm.ReplicationClusterObservedState {
	if in == nil {
		return nil
	}
	out := &krm.ReplicationClusterObservedState{}
	out.PsaWriteEndpoint = in.PsaWriteEndpoint
	// MISSING: FailoverDrReplicaName
	out.DrReplica = in.DrReplica
	return out
}
*/

/*
found existing non-generated mapping function "ReplicationClusterObservedState_ToProto", skipping

	func ReplicationClusterObservedState_ToProto(mapCtx *direct.MapContext, in *krm.ReplicationClusterObservedState) *pb.ReplicationCluster {
		if in == nil {
			return nil
		}
		out := &pb.ReplicationCluster{}
		out.PsaWriteEndpoint = in.PsaWriteEndpoint
		// MISSING: FailoverDrReplicaName
		out.DrReplica = in.DrReplica
		return out
	}
*/
func SQLActiveDirectoryConfig_FromProto(mapCtx *direct.MapContext, in *pb.SqlActiveDirectoryConfig) *krm.SQLActiveDirectoryConfig {
	if in == nil {
		return nil
	}
	out := &krm.SQLActiveDirectoryConfig{}
	out.Kind = direct.LazyPtr(in.GetKind())
	out.Domain = direct.LazyPtr(in.GetDomain())
	return out
}
func SQLActiveDirectoryConfig_ToProto(mapCtx *direct.MapContext, in *krm.SQLActiveDirectoryConfig) *pb.SqlActiveDirectoryConfig {
	if in == nil {
		return nil
	}
	out := &pb.SqlActiveDirectoryConfig{}
	out.Kind = direct.ValueOf(in.Kind)
	out.Domain = direct.ValueOf(in.Domain)
	return out
}
func SQLServerAuditConfig_FromProto(mapCtx *direct.MapContext, in *pb.SqlServerAuditConfig) *krm.SQLServerAuditConfig {
	if in == nil {
		return nil
	}
	out := &krm.SQLServerAuditConfig{}
	out.Kind = direct.LazyPtr(in.GetKind())
	out.Bucket = direct.LazyPtr(in.GetBucket())
	out.RetentionInterval = direct.StringDuration_FromProto(mapCtx, in.GetRetentionInterval())
	out.UploadInterval = direct.StringDuration_FromProto(mapCtx, in.GetUploadInterval())
	return out
}
func SQLServerAuditConfig_ToProto(mapCtx *direct.MapContext, in *krm.SQLServerAuditConfig) *pb.SqlServerAuditConfig {
	if in == nil {
		return nil
	}
	out := &pb.SqlServerAuditConfig{}
	out.Kind = direct.ValueOf(in.Kind)
	out.Bucket = direct.ValueOf(in.Bucket)
	out.RetentionInterval = direct.StringDuration_ToProto(mapCtx, in.RetentionInterval)
	out.UploadInterval = direct.StringDuration_ToProto(mapCtx, in.UploadInterval)
	return out
}
func SSLCert_FromProto(mapCtx *direct.MapContext, in *pb.SslCert) *krm.SSLCert {
	if in == nil {
		return nil
	}
	out := &krm.SSLCert{}
	out.Kind = direct.LazyPtr(in.GetKind())
	out.CertSerialNumber = direct.LazyPtr(in.GetCertSerialNumber())
	out.Cert = direct.LazyPtr(in.GetCert())
	out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCreateTime())
	out.CommonName = direct.LazyPtr(in.GetCommonName())
	out.ExpirationTime = direct.StringTimestamp_FromProto(mapCtx, in.GetExpirationTime())
	out.Sha1Fingerprint = direct.LazyPtr(in.GetSha1Fingerprint())
	out.Instance = direct.LazyPtr(in.GetInstance())
	out.SelfLink = direct.LazyPtr(in.GetSelfLink())
	return out
}
func SSLCert_ToProto(mapCtx *direct.MapContext, in *krm.SSLCert) *pb.SslCert {
	if in == nil {
		return nil
	}
	out := &pb.SslCert{}
	out.Kind = direct.ValueOf(in.Kind)
	out.CertSerialNumber = direct.ValueOf(in.CertSerialNumber)
	out.Cert = direct.ValueOf(in.Cert)
	out.CreateTime = direct.StringTimestamp_ToProto(mapCtx, in.CreateTime)
	out.CommonName = direct.ValueOf(in.CommonName)
	out.ExpirationTime = direct.StringTimestamp_ToProto(mapCtx, in.ExpirationTime)
	out.Sha1Fingerprint = direct.ValueOf(in.Sha1Fingerprint)
	out.Instance = direct.ValueOf(in.Instance)
	out.SelfLink = direct.ValueOf(in.SelfLink)
	return out
}
func Settings_FromProto(mapCtx *direct.MapContext, in *pb.Settings) *krm.Settings {
	if in == nil {
		return nil
	}
	out := &krm.Settings{}
	out.SettingsVersion = direct.Int64Value_FromProto(mapCtx, in.GetSettingsVersion())
	out.AuthorizedGaeApplications = in.AuthorizedGaeApplications
	out.Tier = direct.LazyPtr(in.GetTier())
	out.Kind = direct.LazyPtr(in.GetKind())
	out.UserLabels = in.UserLabels
	out.AvailabilityType = direct.Enum_FromProto(mapCtx, in.GetAvailabilityType())
	out.PricingPlan = direct.Enum_FromProto(mapCtx, in.GetPricingPlan())
	out.ReplicationType = direct.Enum_FromProto(mapCtx, in.GetReplicationType())
	out.StorageAutoResizeLimit = direct.Int64Value_FromProto(mapCtx, in.GetStorageAutoResizeLimit())
	out.ActivationPolicy = direct.Enum_FromProto(mapCtx, in.GetActivationPolicy())
	out.IPConfiguration = IPConfiguration_FromProto(mapCtx, in.GetIpConfiguration())
	out.StorageAutoResize = direct.BoolValue_FromProto(mapCtx, in.GetStorageAutoResize())
	out.LocationPreference = LocationPreference_FromProto(mapCtx, in.GetLocationPreference())
	out.DatabaseFlags = direct.Slice_FromProto(mapCtx, in.DatabaseFlags, DatabaseFlags_FromProto)
	out.DataDiskType = direct.Enum_FromProto(mapCtx, in.GetDataDiskType())
	out.MaintenanceWindow = MaintenanceWindow_FromProto(mapCtx, in.GetMaintenanceWindow())
	out.BackupConfiguration = BackupConfiguration_FromProto(mapCtx, in.GetBackupConfiguration())
	out.DatabaseReplicationEnabled = direct.BoolValue_FromProto(mapCtx, in.GetDatabaseReplicationEnabled())
	out.CrashSafeReplicationEnabled = direct.BoolValue_FromProto(mapCtx, in.GetCrashSafeReplicationEnabled())
	out.DataDiskSizeGB = direct.Int64Value_FromProto(mapCtx, in.GetDataDiskSizeGb())
	out.ActiveDirectoryConfig = SQLActiveDirectoryConfig_FromProto(mapCtx, in.GetActiveDirectoryConfig())
	out.Collation = direct.LazyPtr(in.GetCollation())
	out.DenyMaintenancePeriods = direct.Slice_FromProto(mapCtx, in.DenyMaintenancePeriods, DenyMaintenancePeriod_FromProto)
	out.InsightsConfig = InsightsConfig_FromProto(mapCtx, in.GetInsightsConfig())
	out.PasswordValidationPolicy = PasswordValidationPolicy_FromProto(mapCtx, in.GetPasswordValidationPolicy())
	out.SQLServerAuditConfig = SQLServerAuditConfig_FromProto(mapCtx, in.GetSqlServerAuditConfig())
	out.Edition = direct.Enum_FromProto(mapCtx, in.GetEdition())
	out.ConnectorEnforcement = direct.Enum_FromProto(mapCtx, in.GetConnectorEnforcement())
	out.DeletionProtectionEnabled = direct.BoolValue_FromProto(mapCtx, in.GetDeletionProtectionEnabled())
	out.TimeZone = direct.LazyPtr(in.GetTimeZone())
	out.AdvancedMachineFeatures = AdvancedMachineFeatures_FromProto(mapCtx, in.GetAdvancedMachineFeatures())
	out.DataCacheConfig = DataCacheConfig_FromProto(mapCtx, in.GetDataCacheConfig())
	out.EnableGoogleMlIntegration = direct.BoolValue_FromProto(mapCtx, in.GetEnableGoogleMlIntegration())
	out.EnableDataplexIntegration = direct.BoolValue_FromProto(mapCtx, in.GetEnableDataplexIntegration())
	return out
}
func Settings_ToProto(mapCtx *direct.MapContext, in *krm.Settings) *pb.Settings {
	if in == nil {
		return nil
	}
	out := &pb.Settings{}
	out.SettingsVersion = direct.Int64Value_ToProto(mapCtx, in.SettingsVersion)
	out.AuthorizedGaeApplications = in.AuthorizedGaeApplications
	out.Tier = direct.ValueOf(in.Tier)
	out.Kind = direct.ValueOf(in.Kind)
	out.UserLabels = in.UserLabels
	out.AvailabilityType = direct.Enum_ToProto[pb.SqlAvailabilityType](mapCtx, in.AvailabilityType)
	out.PricingPlan = direct.Enum_ToProto[pb.SqlPricingPlan](mapCtx, in.PricingPlan)
	out.ReplicationType = direct.Enum_ToProto[pb.SqlReplicationType](mapCtx, in.ReplicationType)
	out.StorageAutoResizeLimit = direct.Int64Value_ToProto(mapCtx, in.StorageAutoResizeLimit)
	out.ActivationPolicy = direct.Enum_ToProto[pb.Settings_SqlActivationPolicy](mapCtx, in.ActivationPolicy)
	out.IpConfiguration = IPConfiguration_ToProto(mapCtx, in.IPConfiguration)
	out.StorageAutoResize = direct.BoolValue_ToProto(mapCtx, in.StorageAutoResize)
	out.LocationPreference = LocationPreference_ToProto(mapCtx, in.LocationPreference)
	out.DatabaseFlags = direct.Slice_ToProto(mapCtx, in.DatabaseFlags, DatabaseFlags_ToProto)
	out.DataDiskType = direct.Enum_ToProto[pb.SqlDataDiskType](mapCtx, in.DataDiskType)
	out.MaintenanceWindow = MaintenanceWindow_ToProto(mapCtx, in.MaintenanceWindow)
	out.BackupConfiguration = BackupConfiguration_ToProto(mapCtx, in.BackupConfiguration)
	out.DatabaseReplicationEnabled = direct.BoolValue_ToProto(mapCtx, in.DatabaseReplicationEnabled)
	out.CrashSafeReplicationEnabled = direct.BoolValue_ToProto(mapCtx, in.CrashSafeReplicationEnabled)
	out.DataDiskSizeGb = direct.Int64Value_ToProto(mapCtx, in.DataDiskSizeGB)
	out.ActiveDirectoryConfig = SQLActiveDirectoryConfig_ToProto(mapCtx, in.ActiveDirectoryConfig)
	out.Collation = direct.ValueOf(in.Collation)
	out.DenyMaintenancePeriods = direct.Slice_ToProto(mapCtx, in.DenyMaintenancePeriods, DenyMaintenancePeriod_ToProto)
	out.InsightsConfig = InsightsConfig_ToProto(mapCtx, in.InsightsConfig)
	out.PasswordValidationPolicy = PasswordValidationPolicy_ToProto(mapCtx, in.PasswordValidationPolicy)
	out.SqlServerAuditConfig = SQLServerAuditConfig_ToProto(mapCtx, in.SQLServerAuditConfig)
	out.Edition = direct.Enum_ToProto[pb.Settings_Edition](mapCtx, in.Edition)
	out.ConnectorEnforcement = direct.Enum_ToProto[pb.Settings_ConnectorEnforcement](mapCtx, in.ConnectorEnforcement)
	out.DeletionProtectionEnabled = direct.BoolValue_ToProto(mapCtx, in.DeletionProtectionEnabled)
	out.TimeZone = direct.ValueOf(in.TimeZone)
	out.AdvancedMachineFeatures = AdvancedMachineFeatures_ToProto(mapCtx, in.AdvancedMachineFeatures)
	out.DataCacheConfig = DataCacheConfig_ToProto(mapCtx, in.DataCacheConfig)
	out.EnableGoogleMlIntegration = direct.BoolValue_ToProto(mapCtx, in.EnableGoogleMlIntegration)
	out.EnableDataplexIntegration = direct.BoolValue_ToProto(mapCtx, in.EnableDataplexIntegration)
	return out
}
func SettingsObservedState_FromProto(mapCtx *direct.MapContext, in *pb.Settings) *krm.SettingsObservedState {
	if in == nil {
		return nil
	}
	out := &krm.SettingsObservedState{}
	// MISSING: SettingsVersion
	// MISSING: AuthorizedGaeApplications
	// MISSING: Tier
	// MISSING: Kind
	// MISSING: UserLabels
	// MISSING: AvailabilityType
	// MISSING: PricingPlan
	// MISSING: ReplicationType
	// MISSING: StorageAutoResizeLimit
	// MISSING: ActivationPolicy
	// MISSING: IPConfiguration
	// MISSING: StorageAutoResize
	// MISSING: LocationPreference
	// MISSING: DatabaseFlags
	// MISSING: DataDiskType
	// MISSING: MaintenanceWindow
	out.BackupConfiguration = BackupConfigurationObservedState_FromProto(mapCtx, in.GetBackupConfiguration())
	// MISSING: DatabaseReplicationEnabled
	// MISSING: CrashSafeReplicationEnabled
	// MISSING: DataDiskSizeGB
	// MISSING: ActiveDirectoryConfig
	// MISSING: Collation
	// MISSING: DenyMaintenancePeriods
	// MISSING: InsightsConfig
	// MISSING: PasswordValidationPolicy
	// MISSING: SQLServerAuditConfig
	// MISSING: Edition
	// MISSING: ConnectorEnforcement
	// MISSING: DeletionProtectionEnabled
	// MISSING: TimeZone
	// MISSING: AdvancedMachineFeatures
	// MISSING: DataCacheConfig
	// MISSING: EnableGoogleMlIntegration
	// MISSING: EnableDataplexIntegration
	return out
}
func SettingsObservedState_ToProto(mapCtx *direct.MapContext, in *krm.SettingsObservedState) *pb.Settings {
	if in == nil {
		return nil
	}
	out := &pb.Settings{}
	// MISSING: SettingsVersion
	// MISSING: AuthorizedGaeApplications
	// MISSING: Tier
	// MISSING: Kind
	// MISSING: UserLabels
	// MISSING: AvailabilityType
	// MISSING: PricingPlan
	// MISSING: ReplicationType
	// MISSING: StorageAutoResizeLimit
	// MISSING: ActivationPolicy
	// MISSING: IPConfiguration
	// MISSING: StorageAutoResize
	// MISSING: LocationPreference
	// MISSING: DatabaseFlags
	// MISSING: DataDiskType
	// MISSING: MaintenanceWindow
	out.BackupConfiguration = BackupConfigurationObservedState_ToProto(mapCtx, in.BackupConfiguration)
	// MISSING: DatabaseReplicationEnabled
	// MISSING: CrashSafeReplicationEnabled
	// MISSING: DataDiskSizeGB
	// MISSING: ActiveDirectoryConfig
	// MISSING: Collation
	// MISSING: DenyMaintenancePeriods
	// MISSING: InsightsConfig
	// MISSING: PasswordValidationPolicy
	// MISSING: SQLServerAuditConfig
	// MISSING: Edition
	// MISSING: ConnectorEnforcement
	// MISSING: DeletionProtectionEnabled
	// MISSING: TimeZone
	// MISSING: AdvancedMachineFeatures
	// MISSING: DataCacheConfig
	// MISSING: EnableGoogleMlIntegration
	// MISSING: EnableDataplexIntegration
	return out
}
