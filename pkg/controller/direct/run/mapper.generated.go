// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by dev/tasks/generate-all. DO NOT EDIT.
// +generated:mapper
// krm.group: run.cnrm.cloud.google.com
// krm.version: v1alpha1
// proto.service: google.cloud.run.v2

package run

import (
	pb "cloud.google.com/go/run/apiv2/runpb"
	krmcomputev1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/compute/v1beta1"
	refsv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/refs/v1beta1"
	krm "github.com/GoogleCloudPlatform/k8s-config-connector/apis/run/v1alpha1"
	krmrunv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/run/v1beta1"
	krmsecretmanagerv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/secretmanager/v1beta1"
	krmvpcaccessv1beta1 "github.com/GoogleCloudPlatform/k8s-config-connector/apis/vpcaccess/v1beta1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/controller/direct"
	apipb "google.golang.org/genproto/googleapis/api"
)

func BinaryAuthorization_FromProto(mapCtx *direct.MapContext, in *pb.BinaryAuthorization) *krmrunv1beta1.BinaryAuthorization {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.BinaryAuthorization{}
	out.UseDefault = direct.LazyPtr(in.GetUseDefault())
	// MISSING: Policy
	out.BreakglassJustification = direct.LazyPtr(in.GetBreakglassJustification())
	return out
}
func BinaryAuthorization_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.BinaryAuthorization) *pb.BinaryAuthorization {
	if in == nil {
		return nil
	}
	out := &pb.BinaryAuthorization{}
	if oneof := BinaryAuthorization_UseDefault_ToProto(mapCtx, in.UseDefault); oneof != nil {
		out.BinauthzMethod = oneof
	}
	// MISSING: Policy
	out.BreakglassJustification = direct.ValueOf(in.BreakglassJustification)
	return out
}
func BinaryAuthorization_UseDefault_ToProto(mapCtx *direct.MapContext, in *bool) *pb.BinaryAuthorization_UseDefault {
	if in == nil {
		return nil
	}
	return &pb.BinaryAuthorization_UseDefault{UseDefault: *in}
}
func BuildInfo_FromProto(mapCtx *direct.MapContext, in *pb.BuildInfo) *krmrunv1beta1.BuildInfo {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.BuildInfo{}
	// MISSING: FunctionTarget
	// MISSING: SourceLocation
	return out
}
func BuildInfo_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.BuildInfo) *pb.BuildInfo {
	if in == nil {
		return nil
	}
	out := &pb.BuildInfo{}
	// MISSING: FunctionTarget
	// MISSING: SourceLocation
	return out
}
func BuildInfoObservedState_FromProto(mapCtx *direct.MapContext, in *pb.BuildInfo) *krmrunv1beta1.BuildInfoObservedState {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.BuildInfoObservedState{}
	out.FunctionTarget = direct.LazyPtr(in.GetFunctionTarget())
	out.SourceLocation = direct.LazyPtr(in.GetSourceLocation())
	return out
}
func BuildInfoObservedState_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.BuildInfoObservedState) *pb.BuildInfo {
	if in == nil {
		return nil
	}
	out := &pb.BuildInfo{}
	out.FunctionTarget = direct.ValueOf(in.FunctionTarget)
	out.SourceLocation = direct.ValueOf(in.SourceLocation)
	return out
}
func CloudSQLInstance_FromProto(mapCtx *direct.MapContext, in *pb.CloudSqlInstance) *krmrunv1beta1.CloudSQLInstance {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.CloudSQLInstance{}

	if v := in.GetInstances(); len(v) != 0 {
		for i := range v {
			out.InstanceRefs = append(out.InstanceRefs, &refsv1beta1.SQLInstanceRef{External: v[i]})
		}
	}

	return out
}
func CloudSQLInstance_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.CloudSQLInstance) *pb.CloudSqlInstance {
	if in == nil {
		return nil
	}
	out := &pb.CloudSqlInstance{}

	if v := in.InstanceRefs; len(v) != 0 {
		for i := range v {
			out.Instances = append(out.Instances, v[i].External)
		}
	}

	return out
}
func Condition_FromProto(mapCtx *direct.MapContext, in *pb.Condition) *krmrunv1beta1.Condition {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.Condition{}
	out.Type = direct.LazyPtr(in.GetType())
	out.State = direct.Enum_FromProto(mapCtx, in.GetState())
	out.Message = direct.LazyPtr(in.GetMessage())
	out.LastTransitionTime = direct.StringTimestamp_FromProto(mapCtx, in.GetLastTransitionTime())
	out.Severity = direct.Enum_FromProto(mapCtx, in.GetSeverity())
	out.Reason = direct.Enum_FromProto(mapCtx, in.GetReason())
	out.RevisionReason = direct.Enum_FromProto(mapCtx, in.GetRevisionReason())
	out.ExecutionReason = direct.Enum_FromProto(mapCtx, in.GetExecutionReason())
	return out
}
func Condition_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.Condition) *pb.Condition {
	if in == nil {
		return nil
	}
	out := &pb.Condition{}
	out.Type = direct.ValueOf(in.Type)
	out.State = direct.Enum_ToProto[pb.Condition_State](mapCtx, in.State)
	out.Message = direct.ValueOf(in.Message)
	out.LastTransitionTime = direct.StringTimestamp_ToProto(mapCtx, in.LastTransitionTime)
	out.Severity = direct.Enum_ToProto[pb.Condition_Severity](mapCtx, in.Severity)
	if oneof := Condition_Reason_ToProto(mapCtx, in.Reason); oneof != nil {
		out.Reasons = oneof
	}
	if oneof := Condition_RevisionReason_ToProto(mapCtx, in.RevisionReason); oneof != nil {
		out.Reasons = oneof
	}
	if oneof := Condition_ExecutionReason_ToProto(mapCtx, in.ExecutionReason); oneof != nil {
		out.Reasons = oneof
	}
	return out
}
func Condition_Reason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_Reason {
	if in == nil {
		return nil
	}
	return &pb.Condition_Reason{Reason: direct.Enum_ToProto[pb.Condition_CommonReason](mapCtx, in)}
}
func Condition_RevisionReason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_RevisionReason_ {
	if in == nil {
		return nil
	}
	return &pb.Condition_RevisionReason_{RevisionReason: direct.Enum_ToProto[pb.Condition_RevisionReason](mapCtx, in)}
}
func Condition_ExecutionReason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_ExecutionReason_ {
	if in == nil {
		return nil
	}
	return &pb.Condition_ExecutionReason_{ExecutionReason: direct.Enum_ToProto[pb.Condition_ExecutionReason](mapCtx, in)}
}
func Container_FromProto(mapCtx *direct.MapContext, in *pb.Container) *krmrunv1beta1.Container {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.Container{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Image = direct.LazyPtr(in.GetImage())
	// MISSING: SourceCode
	out.Command = in.Command
	out.Args = in.Args
	out.Env = direct.Slice_FromProto(mapCtx, in.Env, EnvVar_FromProto)
	out.Resources = ResourceRequirements_FromProto(mapCtx, in.GetResources())
	out.Ports = direct.Slice_FromProto(mapCtx, in.Ports, ContainerPort_FromProto)
	out.VolumeMounts = direct.Slice_FromProto(mapCtx, in.VolumeMounts, VolumeMount_FromProto)
	out.WorkingDir = direct.LazyPtr(in.GetWorkingDir())
	out.LivenessProbe = Probe_FromProto(mapCtx, in.GetLivenessProbe())
	out.StartupProbe = Probe_FromProto(mapCtx, in.GetStartupProbe())
	// MISSING: ReadinessProbe
	out.DependsOn = in.DependsOn
	// MISSING: BaseImageURI
	// MISSING: BuildInfo
	return out
}
func Container_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.Container) *pb.Container {
	if in == nil {
		return nil
	}
	out := &pb.Container{}
	out.Name = direct.ValueOf(in.Name)
	out.Image = direct.ValueOf(in.Image)
	// MISSING: SourceCode
	out.Command = in.Command
	out.Args = in.Args
	out.Env = direct.Slice_ToProto(mapCtx, in.Env, EnvVar_ToProto)
	out.Resources = ResourceRequirements_ToProto(mapCtx, in.Resources)
	out.Ports = direct.Slice_ToProto(mapCtx, in.Ports, ContainerPort_ToProto)
	out.VolumeMounts = direct.Slice_ToProto(mapCtx, in.VolumeMounts, VolumeMount_ToProto)
	out.WorkingDir = direct.ValueOf(in.WorkingDir)
	out.LivenessProbe = Probe_ToProto(mapCtx, in.LivenessProbe)
	out.StartupProbe = Probe_ToProto(mapCtx, in.StartupProbe)
	// MISSING: ReadinessProbe
	out.DependsOn = in.DependsOn
	// MISSING: BaseImageURI
	// MISSING: BuildInfo
	return out
}
func ContainerPort_FromProto(mapCtx *direct.MapContext, in *pb.ContainerPort) *krmrunv1beta1.ContainerPort {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.ContainerPort{}
	out.Name = direct.LazyPtr(in.GetName())
	out.ContainerPort = direct.LazyPtr(in.GetContainerPort())
	return out
}
func ContainerPort_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.ContainerPort) *pb.ContainerPort {
	if in == nil {
		return nil
	}
	out := &pb.ContainerPort{}
	out.Name = direct.ValueOf(in.Name)
	out.ContainerPort = direct.ValueOf(in.ContainerPort)
	return out
}
func EmptyDirVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.EmptyDirVolumeSource) *krmrunv1beta1.EmptyDirVolumeSource {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.EmptyDirVolumeSource{}
	out.Medium = direct.Enum_FromProto(mapCtx, in.GetMedium())
	out.SizeLimit = direct.LazyPtr(in.GetSizeLimit())
	return out
}
func EmptyDirVolumeSource_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.EmptyDirVolumeSource) *pb.EmptyDirVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.EmptyDirVolumeSource{}
	out.Medium = direct.Enum_ToProto[pb.EmptyDirVolumeSource_Medium](mapCtx, in.Medium)
	out.SizeLimit = direct.ValueOf(in.SizeLimit)
	return out
}
func EnvVar_FromProto(mapCtx *direct.MapContext, in *pb.EnvVar) *krmrunv1beta1.EnvVar {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.EnvVar{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Value = direct.LazyPtr(in.GetValue())
	out.ValueSource = EnvVarSource_FromProto(mapCtx, in.GetValueSource())
	return out
}
func EnvVar_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.EnvVar) *pb.EnvVar {
	if in == nil {
		return nil
	}
	out := &pb.EnvVar{}
	out.Name = direct.ValueOf(in.Name)
	if oneof := EnvVar_Value_ToProto(mapCtx, in.Value); oneof != nil {
		out.Values = oneof
	}
	if oneof := EnvVarSource_ToProto(mapCtx, in.ValueSource); oneof != nil {
		out.Values = &pb.EnvVar_ValueSource{ValueSource: oneof}
	}
	return out
}
func EnvVar_Value_ToProto(mapCtx *direct.MapContext, in *string) *pb.EnvVar_Value {
	if in == nil {
		return nil
	}
	return &pb.EnvVar_Value{Value: *in}
}
func EnvVarSource_FromProto(mapCtx *direct.MapContext, in *pb.EnvVarSource) *krmrunv1beta1.EnvVarSource {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.EnvVarSource{}
	out.SecretKeyRef = SecretKeySelector_FromProto(mapCtx, in.GetSecretKeyRef())
	return out
}
func EnvVarSource_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.EnvVarSource) *pb.EnvVarSource {
	if in == nil {
		return nil
	}
	out := &pb.EnvVarSource{}
	out.SecretKeyRef = SecretKeySelector_ToProto(mapCtx, in.SecretKeyRef)
	return out
}
func ExecutionReference_FromProto(mapCtx *direct.MapContext, in *pb.ExecutionReference) *krmrunv1beta1.ExecutionReference {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.ExecutionReference{}
	out.Name = direct.LazyPtr(in.GetName())
	out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCreateTime())
	out.CompletionTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCompletionTime())
	out.DeleteTime = direct.StringTimestamp_FromProto(mapCtx, in.GetDeleteTime())
	out.CompletionStatus = direct.Enum_FromProto(mapCtx, in.GetCompletionStatus())
	return out
}
func ExecutionReference_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.ExecutionReference) *pb.ExecutionReference {
	if in == nil {
		return nil
	}
	out := &pb.ExecutionReference{}
	out.Name = direct.ValueOf(in.Name)
	out.CreateTime = direct.StringTimestamp_ToProto(mapCtx, in.CreateTime)
	out.CompletionTime = direct.StringTimestamp_ToProto(mapCtx, in.CompletionTime)
	out.DeleteTime = direct.StringTimestamp_ToProto(mapCtx, in.DeleteTime)
	out.CompletionStatus = direct.Enum_ToProto[pb.ExecutionReference_CompletionStatus](mapCtx, in.CompletionStatus)
	return out
}
func ExecutionTemplate_FromProto(mapCtx *direct.MapContext, in *pb.ExecutionTemplate) *krmrunv1beta1.ExecutionTemplate {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.ExecutionTemplate{}
	// MISSING: Labels
	out.Annotations = in.Annotations
	out.Parallelism = direct.LazyPtr(in.GetParallelism())
	out.TaskCount = direct.LazyPtr(in.GetTaskCount())
	out.Template = TaskTemplate_FromProto(mapCtx, in.GetTemplate())
	return out
}
func ExecutionTemplate_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.ExecutionTemplate) *pb.ExecutionTemplate {
	if in == nil {
		return nil
	}
	out := &pb.ExecutionTemplate{}
	// MISSING: Labels
	out.Annotations = in.Annotations
	out.Parallelism = direct.ValueOf(in.Parallelism)
	out.TaskCount = direct.ValueOf(in.TaskCount)
	out.Template = TaskTemplate_ToProto(mapCtx, in.Template)
	return out
}
func GCSVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.GCSVolumeSource) *krmrunv1beta1.GCSVolumeSource {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.GCSVolumeSource{}
	out.Bucket = direct.LazyPtr(in.GetBucket())
	out.ReadOnly = direct.LazyPtr(in.GetReadOnly())
	out.MountOptions = in.MountOptions
	return out
}
func GCSVolumeSource_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.GCSVolumeSource) *pb.GCSVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.GCSVolumeSource{}
	out.Bucket = direct.ValueOf(in.Bucket)
	out.ReadOnly = direct.ValueOf(in.ReadOnly)
	out.MountOptions = in.MountOptions
	return out
}
func GrpcAction_FromProto(mapCtx *direct.MapContext, in *pb.GRPCAction) *krmrunv1beta1.GrpcAction {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.GrpcAction{}
	out.Port = direct.LazyPtr(in.GetPort())
	out.Service = direct.LazyPtr(in.GetService())
	return out
}
func GrpcAction_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.GrpcAction) *pb.GRPCAction {
	if in == nil {
		return nil
	}
	out := &pb.GRPCAction{}
	out.Port = direct.ValueOf(in.Port)
	out.Service = direct.ValueOf(in.Service)
	return out
}
func HTTPGetAction_FromProto(mapCtx *direct.MapContext, in *pb.HTTPGetAction) *krmrunv1beta1.HTTPGetAction {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.HTTPGetAction{}
	out.Path = direct.LazyPtr(in.GetPath())
	// MISSING: HTTPHeaders
	// (near miss): "HTTPHeaders" vs "HttpHeaders"
	out.Port = direct.LazyPtr(in.GetPort())
	return out
}
func HTTPGetAction_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.HTTPGetAction) *pb.HTTPGetAction {
	if in == nil {
		return nil
	}
	out := &pb.HTTPGetAction{}
	out.Path = direct.ValueOf(in.Path)
	// MISSING: HTTPHeaders
	// (near miss): "HTTPHeaders" vs "HttpHeaders"
	out.Port = direct.ValueOf(in.Port)
	return out
}
func HTTPHeader_FromProto(mapCtx *direct.MapContext, in *pb.HTTPHeader) *krmrunv1beta1.HTTPHeader {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.HTTPHeader{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Value = direct.LazyPtr(in.GetValue())
	return out
}
func HTTPHeader_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.HTTPHeader) *pb.HTTPHeader {
	if in == nil {
		return nil
	}
	out := &pb.HTTPHeader{}
	out.Name = direct.ValueOf(in.Name)
	out.Value = direct.ValueOf(in.Value)
	return out
}
func NfsVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.NFSVolumeSource) *krmrunv1beta1.NfsVolumeSource {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.NfsVolumeSource{}
	out.Server = direct.LazyPtr(in.GetServer())
	out.Path = direct.LazyPtr(in.GetPath())
	out.ReadOnly = direct.LazyPtr(in.GetReadOnly())
	return out
}
func NfsVolumeSource_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.NfsVolumeSource) *pb.NFSVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.NFSVolumeSource{}
	out.Server = direct.ValueOf(in.Server)
	out.Path = direct.ValueOf(in.Path)
	out.ReadOnly = direct.ValueOf(in.ReadOnly)
	return out
}
func NodeSelector_FromProto(mapCtx *direct.MapContext, in *pb.NodeSelector) *krmrunv1beta1.NodeSelector {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.NodeSelector{}
	out.Accelerator = direct.LazyPtr(in.GetAccelerator())
	return out
}
func NodeSelector_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.NodeSelector) *pb.NodeSelector {
	if in == nil {
		return nil
	}
	out := &pb.NodeSelector{}
	out.Accelerator = direct.ValueOf(in.Accelerator)
	return out
}
func Probe_FromProto(mapCtx *direct.MapContext, in *pb.Probe) *krmrunv1beta1.Probe {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.Probe{}
	out.InitialDelaySeconds = direct.LazyPtr(in.GetInitialDelaySeconds())
	out.TimeoutSeconds = direct.LazyPtr(in.GetTimeoutSeconds())
	out.PeriodSeconds = direct.LazyPtr(in.GetPeriodSeconds())
	out.FailureThreshold = direct.LazyPtr(in.GetFailureThreshold())
	out.HTTPGet = HTTPGetAction_FromProto(mapCtx, in.GetHttpGet())
	out.TCPSocket = TCPSocketAction_FromProto(mapCtx, in.GetTcpSocket())
	// MISSING: Grpc
	return out
}
func Probe_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.Probe) *pb.Probe {
	if in == nil {
		return nil
	}
	out := &pb.Probe{}
	out.InitialDelaySeconds = direct.ValueOf(in.InitialDelaySeconds)
	out.TimeoutSeconds = direct.ValueOf(in.TimeoutSeconds)
	out.PeriodSeconds = direct.ValueOf(in.PeriodSeconds)
	out.FailureThreshold = direct.ValueOf(in.FailureThreshold)
	if oneof := HTTPGetAction_ToProto(mapCtx, in.HTTPGet); oneof != nil {
		out.ProbeType = &pb.Probe_HttpGet{HttpGet: oneof}
	}
	if oneof := TCPSocketAction_ToProto(mapCtx, in.TCPSocket); oneof != nil {
		out.ProbeType = &pb.Probe_TcpSocket{TcpSocket: oneof}
	}
	// MISSING: Grpc
	return out
}
func ResourceRequirements_FromProto(mapCtx *direct.MapContext, in *pb.ResourceRequirements) *krmrunv1beta1.ResourceRequirements {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.ResourceRequirements{}
	out.Limits = in.Limits
	// MISSING: CPUIdle
	// MISSING: StartupCPUBoost
	return out
}
func ResourceRequirements_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.ResourceRequirements) *pb.ResourceRequirements {
	if in == nil {
		return nil
	}
	out := &pb.ResourceRequirements{}
	out.Limits = in.Limits
	// MISSING: CPUIdle
	// MISSING: StartupCPUBoost
	return out
}
func RunJobObservedState_FromProto(mapCtx *direct.MapContext, in *pb.Job) *krmrunv1beta1.RunJobObservedState {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.RunJobObservedState{}
	// MISSING: Name
	out.Uid = direct.LazyPtr(in.GetUid())
	// MISSING: Generation
	// MISSING: Labels
	out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCreateTime())
	out.UpdateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetUpdateTime())
	out.DeleteTime = direct.StringTimestamp_FromProto(mapCtx, in.GetDeleteTime())
	out.ExpireTime = direct.StringTimestamp_FromProto(mapCtx, in.GetExpireTime())
	out.Creator = direct.LazyPtr(in.GetCreator())
	out.LastModifier = direct.LazyPtr(in.GetLastModifier())
	// MISSING: ObservedGeneration
	if v := in.GetTerminalCondition(); v != nil {
		out.TerminalCondition = []*krmrunv1beta1.Condition{Condition_FromProto(mapCtx, v)}
	}
	// MISSING: Conditions
	out.ExecutionCount = direct.LazyPtr(in.GetExecutionCount())
	if v := in.GetLatestCreatedExecution(); v != nil {
		out.LatestCreatedExecution = []*krmrunv1beta1.ExecutionReference{ExecutionReference_FromProto(mapCtx, v)}
	}
	out.Reconciling = direct.LazyPtr(in.GetReconciling())
	// MISSING: SatisfiesPzs
	// MISSING: StartExecutionToken
	// MISSING: RunExecutionToken
	out.Etag = direct.LazyPtr(in.GetEtag())
	return out
}
func RunJobObservedState_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.RunJobObservedState) *pb.Job {
	if in == nil {
		return nil
	}
	out := &pb.Job{}
	// MISSING: Name
	out.Uid = direct.ValueOf(in.Uid)
	// MISSING: Generation
	// MISSING: Labels
	out.CreateTime = direct.StringTimestamp_ToProto(mapCtx, in.CreateTime)
	out.UpdateTime = direct.StringTimestamp_ToProto(mapCtx, in.UpdateTime)
	out.DeleteTime = direct.StringTimestamp_ToProto(mapCtx, in.DeleteTime)
	out.ExpireTime = direct.StringTimestamp_ToProto(mapCtx, in.ExpireTime)
	out.Creator = direct.ValueOf(in.Creator)
	out.LastModifier = direct.ValueOf(in.LastModifier)
	// MISSING: ObservedGeneration
	if len(in.TerminalCondition) > 0 && in.TerminalCondition[0] != nil {
		out.TerminalCondition = Condition_ToProto(mapCtx, in.TerminalCondition[0])
	}
	// MISSING: Conditions
	out.ExecutionCount = direct.ValueOf(in.ExecutionCount)
	if len(in.LatestCreatedExecution) > 0 && in.LatestCreatedExecution[0] != nil {
		out.LatestCreatedExecution = ExecutionReference_ToProto(mapCtx, in.LatestCreatedExecution[0])
	}
	out.Reconciling = direct.ValueOf(in.Reconciling)
	// MISSING: SatisfiesPzs
	// MISSING: StartExecutionToken
	// MISSING: RunExecutionToken
	out.Etag = direct.ValueOf(in.Etag)
	return out
}
func RunJobSpec_FromProto(mapCtx *direct.MapContext, in *pb.Job) *krmrunv1beta1.RunJobSpec {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.RunJobSpec{}
	// MISSING: Name
	// MISSING: Generation
	// MISSING: Labels
	out.Annotations = in.Annotations
	out.Client = direct.LazyPtr(in.GetClient())
	out.ClientVersion = direct.LazyPtr(in.GetClientVersion())
	out.LaunchStage = direct.Enum_FromProto(mapCtx, in.GetLaunchStage())
	out.BinaryAuthorization = BinaryAuthorization_FromProto(mapCtx, in.GetBinaryAuthorization())
	out.Template = ExecutionTemplate_FromProto(mapCtx, in.GetTemplate())
	// MISSING: ObservedGeneration
	// MISSING: Conditions
	// MISSING: SatisfiesPzs
	// MISSING: StartExecutionToken
	// MISSING: RunExecutionToken
	return out
}
func RunJobSpec_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.RunJobSpec) *pb.Job {
	if in == nil {
		return nil
	}
	out := &pb.Job{}
	// MISSING: Name
	// MISSING: Generation
	// MISSING: Labels
	out.Annotations = in.Annotations
	out.Client = direct.ValueOf(in.Client)
	out.ClientVersion = direct.ValueOf(in.ClientVersion)
	out.LaunchStage = direct.Enum_ToProto[apipb.LaunchStage](mapCtx, in.LaunchStage)
	out.BinaryAuthorization = BinaryAuthorization_ToProto(mapCtx, in.BinaryAuthorization)
	out.Template = ExecutionTemplate_ToProto(mapCtx, in.Template)
	// MISSING: ObservedGeneration
	// MISSING: Conditions
	// MISSING: SatisfiesPzs
	// MISSING: StartExecutionToken
	// MISSING: RunExecutionToken
	return out
}
func RunWorkerPoolObservedState_FromProto(mapCtx *direct.MapContext, in *pb.WorkerPool) *krm.RunWorkerPoolObservedState {
	if in == nil {
		return nil
	}
	out := &krm.RunWorkerPoolObservedState{}
	// MISSING: Name
	out.Uid = direct.LazyPtr(in.GetUid())
	out.Generation = direct.LazyPtr(in.GetGeneration())
	out.CreateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetCreateTime())
	out.UpdateTime = direct.StringTimestamp_FromProto(mapCtx, in.GetUpdateTime())
	out.DeleteTime = direct.StringTimestamp_FromProto(mapCtx, in.GetDeleteTime())
	out.ExpireTime = direct.StringTimestamp_FromProto(mapCtx, in.GetExpireTime())
	out.Creator = direct.LazyPtr(in.GetCreator())
	out.LastModifier = direct.LazyPtr(in.GetLastModifier())
	out.Template = WorkerPoolRevisionTemplateObservedState_FromProto(mapCtx, in.GetTemplate())
	out.ObservedGeneration = direct.LazyPtr(in.GetObservedGeneration())
	out.TerminalCondition = WorkerPoolCondition_FromProto(mapCtx, in.GetTerminalCondition())
	out.Conditions = direct.Slice_FromProto(mapCtx, in.Conditions, WorkerPoolCondition_FromProto)
	out.LatestReadyRevision = direct.LazyPtr(in.GetLatestReadyRevision())
	out.LatestCreatedRevision = direct.LazyPtr(in.GetLatestCreatedRevision())
	out.InstanceSplitStatuses = direct.Slice_FromProto(mapCtx, in.InstanceSplitStatuses, WorkerPoolInstanceSplitStatus_FromProto)
	out.ThreatDetectionEnabled = direct.LazyPtr(in.GetThreatDetectionEnabled())
	out.SatisfiesPzs = direct.LazyPtr(in.GetSatisfiesPzs())
	out.Reconciling = direct.LazyPtr(in.GetReconciling())
	// MISSING: Etag
	return out
}
func RunWorkerPoolObservedState_ToProto(mapCtx *direct.MapContext, in *krm.RunWorkerPoolObservedState) *pb.WorkerPool {
	if in == nil {
		return nil
	}
	out := &pb.WorkerPool{}
	// MISSING: Name
	out.Uid = direct.ValueOf(in.Uid)
	out.Generation = direct.ValueOf(in.Generation)
	out.CreateTime = direct.StringTimestamp_ToProto(mapCtx, in.CreateTime)
	out.UpdateTime = direct.StringTimestamp_ToProto(mapCtx, in.UpdateTime)
	out.DeleteTime = direct.StringTimestamp_ToProto(mapCtx, in.DeleteTime)
	out.ExpireTime = direct.StringTimestamp_ToProto(mapCtx, in.ExpireTime)
	out.Creator = direct.ValueOf(in.Creator)
	out.LastModifier = direct.ValueOf(in.LastModifier)
	out.Template = WorkerPoolRevisionTemplateObservedState_ToProto(mapCtx, in.Template)
	out.ObservedGeneration = direct.ValueOf(in.ObservedGeneration)
	out.TerminalCondition = WorkerPoolCondition_ToProto(mapCtx, in.TerminalCondition)
	out.Conditions = direct.Slice_ToProto(mapCtx, in.Conditions, WorkerPoolCondition_ToProto)
	out.LatestReadyRevision = direct.ValueOf(in.LatestReadyRevision)
	out.LatestCreatedRevision = direct.ValueOf(in.LatestCreatedRevision)
	out.InstanceSplitStatuses = direct.Slice_ToProto(mapCtx, in.InstanceSplitStatuses, WorkerPoolInstanceSplitStatus_ToProto)
	out.ThreatDetectionEnabled = direct.ValueOf(in.ThreatDetectionEnabled)
	out.SatisfiesPzs = direct.ValueOf(in.SatisfiesPzs)
	out.Reconciling = direct.ValueOf(in.Reconciling)
	// MISSING: Etag
	return out
}
func RunWorkerPoolSpec_FromProto(mapCtx *direct.MapContext, in *pb.WorkerPool) *krm.RunWorkerPoolSpec {
	if in == nil {
		return nil
	}
	out := &krm.RunWorkerPoolSpec{}
	// MISSING: Name
	out.Description = direct.LazyPtr(in.GetDescription())
	out.Labels = in.Labels
	out.Annotations = in.Annotations
	out.Client = direct.LazyPtr(in.GetClient())
	out.ClientVersion = direct.LazyPtr(in.GetClientVersion())
	out.LaunchStage = direct.Enum_FromProto(mapCtx, in.GetLaunchStage())
	out.BinaryAuthorization = WorkerPoolBinaryAuthorization_FromProto(mapCtx, in.GetBinaryAuthorization())
	out.Template = WorkerPoolRevisionTemplate_FromProto(mapCtx, in.GetTemplate())
	out.InstanceSplits = direct.Slice_FromProto(mapCtx, in.InstanceSplits, WorkerPoolInstanceSplit_FromProto)
	out.Scaling = WorkerPoolScaling_FromProto(mapCtx, in.GetScaling())
	out.CustomAudiences = in.CustomAudiences
	// MISSING: Etag
	return out
}
func RunWorkerPoolSpec_ToProto(mapCtx *direct.MapContext, in *krm.RunWorkerPoolSpec) *pb.WorkerPool {
	if in == nil {
		return nil
	}
	out := &pb.WorkerPool{}
	// MISSING: Name
	out.Description = direct.ValueOf(in.Description)
	out.Labels = in.Labels
	out.Annotations = in.Annotations
	out.Client = direct.ValueOf(in.Client)
	out.ClientVersion = direct.ValueOf(in.ClientVersion)
	out.LaunchStage = direct.Enum_ToProto[apipb.LaunchStage](mapCtx, in.LaunchStage)
	out.BinaryAuthorization = WorkerPoolBinaryAuthorization_ToProto(mapCtx, in.BinaryAuthorization)
	out.Template = WorkerPoolRevisionTemplate_ToProto(mapCtx, in.Template)
	out.InstanceSplits = direct.Slice_ToProto(mapCtx, in.InstanceSplits, WorkerPoolInstanceSplit_ToProto)
	out.Scaling = WorkerPoolScaling_ToProto(mapCtx, in.Scaling)
	out.CustomAudiences = in.CustomAudiences
	// MISSING: Etag
	return out
}
func SecretKeySelector_FromProto(mapCtx *direct.MapContext, in *pb.SecretKeySelector) *krmrunv1beta1.SecretKeySelector {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.SecretKeySelector{}
	if in.GetSecret() != "" {
		out.SecretRef = &krmsecretmanagerv1beta1.SecretRef{External: in.GetSecret()}
	}
	if in.GetVersion() != "" {
		out.VersionRef = &krmsecretmanagerv1beta1.SecretVersionRef{External: in.GetVersion()}
	}
	return out
}
func SecretKeySelector_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.SecretKeySelector) *pb.SecretKeySelector {
	if in == nil {
		return nil
	}
	out := &pb.SecretKeySelector{}
	if in.SecretRef != nil {
		out.Secret = in.SecretRef.External
	}
	if in.VersionRef != nil {
		out.Version = in.VersionRef.External
	}
	return out
}
func SecretVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.SecretVolumeSource) *krmrunv1beta1.SecretVolumeSource {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.SecretVolumeSource{}
	if in.GetSecret() != "" {
		out.SecretRef = &krmsecretmanagerv1beta1.SecretRef{External: in.GetSecret()}
	}
	out.Items = direct.Slice_FromProto(mapCtx, in.Items, VersionToPath_FromProto)
	out.DefaultMode = direct.LazyPtr(in.GetDefaultMode())
	return out
}
func SecretVolumeSource_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.SecretVolumeSource) *pb.SecretVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.SecretVolumeSource{}
	if in.SecretRef != nil {
		out.Secret = in.SecretRef.External
	}
	out.Items = direct.Slice_ToProto(mapCtx, in.Items, VersionToPath_ToProto)
	out.DefaultMode = direct.ValueOf(in.DefaultMode)
	return out
}
func TCPSocketAction_FromProto(mapCtx *direct.MapContext, in *pb.TCPSocketAction) *krmrunv1beta1.TCPSocketAction {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.TCPSocketAction{}
	out.Port = direct.LazyPtr(in.GetPort())
	return out
}
func TCPSocketAction_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.TCPSocketAction) *pb.TCPSocketAction {
	if in == nil {
		return nil
	}
	out := &pb.TCPSocketAction{}
	out.Port = direct.ValueOf(in.Port)
	return out
}
func TaskTemplate_FromProto(mapCtx *direct.MapContext, in *pb.TaskTemplate) *krmrunv1beta1.TaskTemplate {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.TaskTemplate{}
	out.Containers = direct.Slice_FromProto(mapCtx, in.Containers, Container_FromProto)
	out.Volumes = direct.Slice_FromProto(mapCtx, in.Volumes, Volume_FromProto)
	out.MaxRetries = direct.LazyPtr(in.GetMaxRetries())
	out.Timeout = direct.StringDuration_FromProto(mapCtx, in.GetTimeout())
	if in.GetServiceAccount() != "" {
		out.ServiceAccountRef = &refsv1beta1.IAMServiceAccountRef{External: in.GetServiceAccount()}
	}
	out.ExecutionEnvironment = direct.Enum_FromProto(mapCtx, in.GetExecutionEnvironment())
	if in.GetEncryptionKey() != "" {
		out.EncryptionKeyRef = &refsv1beta1.KMSCryptoKeyRef{External: in.GetEncryptionKey()}
	}
	out.VPCAccess = VPCAccess_FromProto(mapCtx, in.GetVpcAccess())
	// MISSING: NodeSelector
	// MISSING: GpuZonalRedundancyDisabled
	return out
}
func TaskTemplate_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.TaskTemplate) *pb.TaskTemplate {
	if in == nil {
		return nil
	}
	out := &pb.TaskTemplate{}
	out.Containers = direct.Slice_ToProto(mapCtx, in.Containers, Container_ToProto)
	out.Volumes = direct.Slice_ToProto(mapCtx, in.Volumes, Volume_ToProto)
	if oneof := TaskTemplate_MaxRetries_ToProto(mapCtx, in.MaxRetries); oneof != nil {
		out.Retries = oneof
	}
	out.Timeout = direct.StringDuration_ToProto(mapCtx, in.Timeout)
	if in.ServiceAccountRef != nil {
		out.ServiceAccount = in.ServiceAccountRef.External
	}
	out.ExecutionEnvironment = direct.Enum_ToProto[pb.ExecutionEnvironment](mapCtx, in.ExecutionEnvironment)
	if in.EncryptionKeyRef != nil {
		out.EncryptionKey = in.EncryptionKeyRef.External
	}
	out.VpcAccess = VPCAccess_ToProto(mapCtx, in.VPCAccess)
	// MISSING: NodeSelector
	// MISSING: GpuZonalRedundancyDisabled
	return out
}
func TaskTemplate_MaxRetries_ToProto(mapCtx *direct.MapContext, in *int32) *pb.TaskTemplate_MaxRetries {
	if in == nil {
		return nil
	}
	return &pb.TaskTemplate_MaxRetries{MaxRetries: *in}
}
func VPCAccess_FromProto(mapCtx *direct.MapContext, in *pb.VpcAccess) *krmrunv1beta1.VPCAccess {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.VPCAccess{}
	if in.GetConnector() != "" {
		out.ConnectorRef = &krmvpcaccessv1beta1.VPCAccessConnectorRef{External: in.GetConnector()}
	}
	out.Egress = direct.Enum_FromProto(mapCtx, in.GetEgress())
	out.NetworkInterfaces = direct.Slice_FromProto(mapCtx, in.NetworkInterfaces, VPCAccess_NetworkInterface_FromProto)
	return out
}
func VPCAccess_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.VPCAccess) *pb.VpcAccess {
	if in == nil {
		return nil
	}
	out := &pb.VpcAccess{}
	if in.ConnectorRef != nil {
		out.Connector = in.ConnectorRef.External
	}
	out.Egress = direct.Enum_ToProto[pb.VpcAccess_VpcEgress](mapCtx, in.Egress)
	out.NetworkInterfaces = direct.Slice_ToProto(mapCtx, in.NetworkInterfaces, VPCAccess_NetworkInterface_ToProto)
	return out
}
func VPCAccess_NetworkInterface_FromProto(mapCtx *direct.MapContext, in *pb.VpcAccess_NetworkInterface) *krmrunv1beta1.VPCAccess_NetworkInterface {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.VPCAccess_NetworkInterface{}
	if in.GetNetwork() != "" {
		out.NetworkRef = &krmcomputev1beta1.ComputeNetworkRef{External: in.GetNetwork()}
	}
	if in.GetSubnetwork() != "" {
		out.SubnetworkRef = &refsv1beta1.ComputeSubnetworkRef{External: in.GetSubnetwork()}
	}
	out.Tags = in.Tags
	return out
}
func VPCAccess_NetworkInterface_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.VPCAccess_NetworkInterface) *pb.VpcAccess_NetworkInterface {
	if in == nil {
		return nil
	}
	out := &pb.VpcAccess_NetworkInterface{}
	if in.NetworkRef != nil {
		out.Network = in.NetworkRef.External
	}
	if in.SubnetworkRef != nil {
		out.Subnetwork = in.SubnetworkRef.External
	}
	out.Tags = in.Tags
	return out
}
func VersionToPath_FromProto(mapCtx *direct.MapContext, in *pb.VersionToPath) *krmrunv1beta1.VersionToPath {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.VersionToPath{}
	out.Path = direct.LazyPtr(in.GetPath())
	if in.GetVersion() != "" {
		out.VersionRef = &krmsecretmanagerv1beta1.SecretVersionRef{External: in.GetVersion()}
	}
	out.Mode = direct.LazyPtr(in.GetMode())
	return out
}
func VersionToPath_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.VersionToPath) *pb.VersionToPath {
	if in == nil {
		return nil
	}
	out := &pb.VersionToPath{}
	out.Path = direct.ValueOf(in.Path)
	if in.VersionRef != nil {
		out.Version = in.VersionRef.External
	}
	out.Mode = direct.ValueOf(in.Mode)
	return out
}
func Volume_FromProto(mapCtx *direct.MapContext, in *pb.Volume) *krmrunv1beta1.Volume {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.Volume{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Secret = SecretVolumeSource_FromProto(mapCtx, in.GetSecret())
	out.CloudSQLInstance = CloudSQLInstance_FromProto(mapCtx, in.GetCloudSqlInstance())
	out.EmptyDir = EmptyDirVolumeSource_FromProto(mapCtx, in.GetEmptyDir())
	// MISSING: Nfs
	// MISSING: GCS
	return out
}
func Volume_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.Volume) *pb.Volume {
	if in == nil {
		return nil
	}
	out := &pb.Volume{}
	out.Name = direct.ValueOf(in.Name)
	if oneof := SecretVolumeSource_ToProto(mapCtx, in.Secret); oneof != nil {
		out.VolumeType = &pb.Volume_Secret{Secret: oneof}
	}
	if oneof := CloudSQLInstance_ToProto(mapCtx, in.CloudSQLInstance); oneof != nil {
		out.VolumeType = &pb.Volume_CloudSqlInstance{CloudSqlInstance: oneof}
	}
	if oneof := EmptyDirVolumeSource_ToProto(mapCtx, in.EmptyDir); oneof != nil {
		out.VolumeType = &pb.Volume_EmptyDir{EmptyDir: oneof}
	}
	// MISSING: Nfs
	// MISSING: GCS
	return out
}
func VolumeMount_FromProto(mapCtx *direct.MapContext, in *pb.VolumeMount) *krmrunv1beta1.VolumeMount {
	if in == nil {
		return nil
	}
	out := &krmrunv1beta1.VolumeMount{}
	out.Name = direct.LazyPtr(in.GetName())
	out.MountPath = direct.LazyPtr(in.GetMountPath())
	// MISSING: SubPath
	return out
}
func VolumeMount_ToProto(mapCtx *direct.MapContext, in *krmrunv1beta1.VolumeMount) *pb.VolumeMount {
	if in == nil {
		return nil
	}
	out := &pb.VolumeMount{}
	out.Name = direct.ValueOf(in.Name)
	out.MountPath = direct.ValueOf(in.MountPath)
	// MISSING: SubPath
	return out
}
func WorkerPoolBinaryAuthorization_FromProto(mapCtx *direct.MapContext, in *pb.BinaryAuthorization) *krm.WorkerPoolBinaryAuthorization {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolBinaryAuthorization{}
	out.UseDefault = direct.LazyPtr(in.GetUseDefault())
	out.Policy = direct.LazyPtr(in.GetPolicy())
	out.BreakglassJustification = direct.LazyPtr(in.GetBreakglassJustification())
	return out
}
func WorkerPoolBinaryAuthorization_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolBinaryAuthorization) *pb.BinaryAuthorization {
	if in == nil {
		return nil
	}
	out := &pb.BinaryAuthorization{}
	if oneof := WorkerPoolBinaryAuthorization_UseDefault_ToProto(mapCtx, in.UseDefault); oneof != nil {
		out.BinauthzMethod = oneof
	}
	if oneof := WorkerPoolBinaryAuthorization_Policy_ToProto(mapCtx, in.Policy); oneof != nil {
		out.BinauthzMethod = oneof
	}
	out.BreakglassJustification = direct.ValueOf(in.BreakglassJustification)
	return out
}
func WorkerPoolBinaryAuthorization_UseDefault_ToProto(mapCtx *direct.MapContext, in *bool) *pb.BinaryAuthorization_UseDefault {
	if in == nil {
		return nil
	}
	return &pb.BinaryAuthorization_UseDefault{UseDefault: *in}
}
func WorkerPoolBinaryAuthorization_Policy_ToProto(mapCtx *direct.MapContext, in *string) *pb.BinaryAuthorization_Policy {
	if in == nil {
		return nil
	}
	return &pb.BinaryAuthorization_Policy{Policy: *in}
}
func WorkerPoolBuildInfoObservedState_FromProto(mapCtx *direct.MapContext, in *pb.BuildInfo) *krm.WorkerPoolBuildInfoObservedState {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolBuildInfoObservedState{}
	out.FunctionTarget = direct.LazyPtr(in.GetFunctionTarget())
	out.SourceLocation = direct.LazyPtr(in.GetSourceLocation())
	return out
}
func WorkerPoolBuildInfoObservedState_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolBuildInfoObservedState) *pb.BuildInfo {
	if in == nil {
		return nil
	}
	out := &pb.BuildInfo{}
	out.FunctionTarget = direct.ValueOf(in.FunctionTarget)
	out.SourceLocation = direct.ValueOf(in.SourceLocation)
	return out
}
func WorkerPoolCloudSQLInstance_FromProto(mapCtx *direct.MapContext, in *pb.CloudSqlInstance) *krm.WorkerPoolCloudSQLInstance {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolCloudSQLInstance{}

	if v := in.GetInstances(); len(v) != 0 {
		for i := range v {
			out.InstanceRefs = append(out.InstanceRefs, &refsv1beta1.SQLInstanceRef{External: v[i]})
		}
	}

	return out
}
func WorkerPoolCloudSQLInstance_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolCloudSQLInstance) *pb.CloudSqlInstance {
	if in == nil {
		return nil
	}
	out := &pb.CloudSqlInstance{}

	if v := in.InstanceRefs; len(v) != 0 {
		for i := range v {
			out.Instances = append(out.Instances, v[i].External)
		}
	}

	return out
}
func WorkerPoolCondition_FromProto(mapCtx *direct.MapContext, in *pb.Condition) *krm.WorkerPoolCondition {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolCondition{}
	out.Type = direct.LazyPtr(in.GetType())
	out.State = direct.Enum_FromProto(mapCtx, in.GetState())
	out.Message = direct.LazyPtr(in.GetMessage())
	out.LastTransitionTime = direct.StringTimestamp_FromProto(mapCtx, in.GetLastTransitionTime())
	out.Severity = direct.Enum_FromProto(mapCtx, in.GetSeverity())
	out.Reason = direct.Enum_FromProto(mapCtx, in.GetReason())
	out.RevisionReason = direct.Enum_FromProto(mapCtx, in.GetRevisionReason())
	out.ExecutionReason = direct.Enum_FromProto(mapCtx, in.GetExecutionReason())
	return out
}
func WorkerPoolCondition_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolCondition) *pb.Condition {
	if in == nil {
		return nil
	}
	out := &pb.Condition{}
	out.Type = direct.ValueOf(in.Type)
	out.State = direct.Enum_ToProto[pb.Condition_State](mapCtx, in.State)
	out.Message = direct.ValueOf(in.Message)
	out.LastTransitionTime = direct.StringTimestamp_ToProto(mapCtx, in.LastTransitionTime)
	out.Severity = direct.Enum_ToProto[pb.Condition_Severity](mapCtx, in.Severity)
	if oneof := WorkerPoolCondition_Reason_ToProto(mapCtx, in.Reason); oneof != nil {
		out.Reasons = oneof
	}
	if oneof := WorkerPoolCondition_RevisionReason_ToProto(mapCtx, in.RevisionReason); oneof != nil {
		out.Reasons = oneof
	}
	if oneof := WorkerPoolCondition_ExecutionReason_ToProto(mapCtx, in.ExecutionReason); oneof != nil {
		out.Reasons = oneof
	}
	return out
}
func WorkerPoolCondition_Reason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_Reason {
	if in == nil {
		return nil
	}
	return &pb.Condition_Reason{Reason: direct.Enum_ToProto[pb.Condition_CommonReason](mapCtx, in)}
}
func WorkerPoolCondition_RevisionReason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_RevisionReason_ {
	if in == nil {
		return nil
	}
	return &pb.Condition_RevisionReason_{RevisionReason: direct.Enum_ToProto[pb.Condition_RevisionReason](mapCtx, in)}
}
func WorkerPoolCondition_ExecutionReason_ToProto(mapCtx *direct.MapContext, in *string) *pb.Condition_ExecutionReason_ {
	if in == nil {
		return nil
	}
	return &pb.Condition_ExecutionReason_{ExecutionReason: direct.Enum_ToProto[pb.Condition_ExecutionReason](mapCtx, in)}
}
func WorkerPoolContainer_FromProto(mapCtx *direct.MapContext, in *pb.Container) *krm.WorkerPoolContainer {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolContainer{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Image = direct.LazyPtr(in.GetImage())
	out.SourceCode = WorkerPoolSourceCode_FromProto(mapCtx, in.GetSourceCode())
	out.Command = in.Command
	out.Args = in.Args
	out.Env = direct.Slice_FromProto(mapCtx, in.Env, WorkerPoolEnvVar_FromProto)
	out.Resources = WorkerPoolResourceRequirements_FromProto(mapCtx, in.GetResources())
	out.Ports = direct.Slice_FromProto(mapCtx, in.Ports, WorkerPoolContainerPort_FromProto)
	out.VolumeMounts = direct.Slice_FromProto(mapCtx, in.VolumeMounts, WorkerPoolVolumeMount_FromProto)
	out.WorkingDir = direct.LazyPtr(in.GetWorkingDir())
	out.LivenessProbe = WorkerPoolProbe_FromProto(mapCtx, in.GetLivenessProbe())
	out.StartupProbe = WorkerPoolProbe_FromProto(mapCtx, in.GetStartupProbe())
	// MISSING: ReadinessProbe
	out.DependsOn = in.DependsOn
	out.BaseImageURI = direct.LazyPtr(in.GetBaseImageUri())
	// MISSING: BuildInfo
	return out
}
func WorkerPoolContainer_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolContainer) *pb.Container {
	if in == nil {
		return nil
	}
	out := &pb.Container{}
	out.Name = direct.ValueOf(in.Name)
	out.Image = direct.ValueOf(in.Image)
	out.SourceCode = WorkerPoolSourceCode_ToProto(mapCtx, in.SourceCode)
	out.Command = in.Command
	out.Args = in.Args
	out.Env = direct.Slice_ToProto(mapCtx, in.Env, WorkerPoolEnvVar_ToProto)
	out.Resources = WorkerPoolResourceRequirements_ToProto(mapCtx, in.Resources)
	out.Ports = direct.Slice_ToProto(mapCtx, in.Ports, WorkerPoolContainerPort_ToProto)
	out.VolumeMounts = direct.Slice_ToProto(mapCtx, in.VolumeMounts, WorkerPoolVolumeMount_ToProto)
	out.WorkingDir = direct.ValueOf(in.WorkingDir)
	out.LivenessProbe = WorkerPoolProbe_ToProto(mapCtx, in.LivenessProbe)
	out.StartupProbe = WorkerPoolProbe_ToProto(mapCtx, in.StartupProbe)
	// MISSING: ReadinessProbe
	out.DependsOn = in.DependsOn
	out.BaseImageUri = direct.ValueOf(in.BaseImageURI)
	// MISSING: BuildInfo
	return out
}
func WorkerPoolContainerObservedState_FromProto(mapCtx *direct.MapContext, in *pb.Container) *krm.WorkerPoolContainerObservedState {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolContainerObservedState{}
	// MISSING: Name
	// MISSING: Image
	// MISSING: SourceCode
	// MISSING: Command
	// MISSING: Args
	// MISSING: Env
	// MISSING: Resources
	// MISSING: Ports
	// MISSING: VolumeMounts
	// MISSING: WorkingDir
	// MISSING: LivenessProbe
	// MISSING: StartupProbe
	// MISSING: ReadinessProbe
	// MISSING: DependsOn
	// MISSING: BaseImageURI
	out.BuildInfo = WorkerPoolBuildInfoObservedState_FromProto(mapCtx, in.GetBuildInfo())
	return out
}
func WorkerPoolContainerObservedState_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolContainerObservedState) *pb.Container {
	if in == nil {
		return nil
	}
	out := &pb.Container{}
	// MISSING: Name
	// MISSING: Image
	// MISSING: SourceCode
	// MISSING: Command
	// MISSING: Args
	// MISSING: Env
	// MISSING: Resources
	// MISSING: Ports
	// MISSING: VolumeMounts
	// MISSING: WorkingDir
	// MISSING: LivenessProbe
	// MISSING: StartupProbe
	// MISSING: ReadinessProbe
	// MISSING: DependsOn
	// MISSING: BaseImageURI
	out.BuildInfo = WorkerPoolBuildInfoObservedState_ToProto(mapCtx, in.BuildInfo)
	return out
}
func WorkerPoolContainerPort_FromProto(mapCtx *direct.MapContext, in *pb.ContainerPort) *krm.WorkerPoolContainerPort {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolContainerPort{}
	out.Name = direct.LazyPtr(in.GetName())
	out.ContainerPort = direct.LazyPtr(in.GetContainerPort())
	return out
}
func WorkerPoolContainerPort_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolContainerPort) *pb.ContainerPort {
	if in == nil {
		return nil
	}
	out := &pb.ContainerPort{}
	out.Name = direct.ValueOf(in.Name)
	out.ContainerPort = direct.ValueOf(in.ContainerPort)
	return out
}
func WorkerPoolEmptyDirVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.EmptyDirVolumeSource) *krm.WorkerPoolEmptyDirVolumeSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolEmptyDirVolumeSource{}
	out.Medium = direct.Enum_FromProto(mapCtx, in.GetMedium())
	out.SizeLimit = direct.LazyPtr(in.GetSizeLimit())
	return out
}
func WorkerPoolEmptyDirVolumeSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolEmptyDirVolumeSource) *pb.EmptyDirVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.EmptyDirVolumeSource{}
	out.Medium = direct.Enum_ToProto[pb.EmptyDirVolumeSource_Medium](mapCtx, in.Medium)
	out.SizeLimit = direct.ValueOf(in.SizeLimit)
	return out
}
func WorkerPoolEnvVar_FromProto(mapCtx *direct.MapContext, in *pb.EnvVar) *krm.WorkerPoolEnvVar {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolEnvVar{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Value = direct.LazyPtr(in.GetValue())
	out.ValueSource = WorkerPoolEnvVarSource_FromProto(mapCtx, in.GetValueSource())
	return out
}
func WorkerPoolEnvVar_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolEnvVar) *pb.EnvVar {
	if in == nil {
		return nil
	}
	out := &pb.EnvVar{}
	out.Name = direct.ValueOf(in.Name)
	if oneof := WorkerPoolEnvVar_Value_ToProto(mapCtx, in.Value); oneof != nil {
		out.Values = oneof
	}
	if oneof := WorkerPoolEnvVarSource_ToProto(mapCtx, in.ValueSource); oneof != nil {
		out.Values = &pb.EnvVar_ValueSource{ValueSource: oneof}
	}
	return out
}
func WorkerPoolEnvVar_Value_ToProto(mapCtx *direct.MapContext, in *string) *pb.EnvVar_Value {
	if in == nil {
		return nil
	}
	return &pb.EnvVar_Value{Value: *in}
}
func WorkerPoolEnvVarSource_FromProto(mapCtx *direct.MapContext, in *pb.EnvVarSource) *krm.WorkerPoolEnvVarSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolEnvVarSource{}
	out.SecretKeyRef = WorkerPoolSecretKeySelector_FromProto(mapCtx, in.GetSecretKeyRef())
	return out
}
func WorkerPoolEnvVarSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolEnvVarSource) *pb.EnvVarSource {
	if in == nil {
		return nil
	}
	out := &pb.EnvVarSource{}
	out.SecretKeyRef = WorkerPoolSecretKeySelector_ToProto(mapCtx, in.SecretKeyRef)
	return out
}
func WorkerPoolGCSVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.GCSVolumeSource) *krm.WorkerPoolGCSVolumeSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolGCSVolumeSource{}
	out.Bucket = direct.LazyPtr(in.GetBucket())
	out.ReadOnly = direct.LazyPtr(in.GetReadOnly())
	out.MountOptions = in.MountOptions
	return out
}
func WorkerPoolGCSVolumeSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolGCSVolumeSource) *pb.GCSVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.GCSVolumeSource{}
	out.Bucket = direct.ValueOf(in.Bucket)
	out.ReadOnly = direct.ValueOf(in.ReadOnly)
	out.MountOptions = in.MountOptions
	return out
}
func WorkerPoolGRPCAction_FromProto(mapCtx *direct.MapContext, in *pb.GRPCAction) *krm.WorkerPoolGRPCAction {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolGRPCAction{}
	out.Port = direct.LazyPtr(in.GetPort())
	out.Service = direct.LazyPtr(in.GetService())
	return out
}
func WorkerPoolGRPCAction_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolGRPCAction) *pb.GRPCAction {
	if in == nil {
		return nil
	}
	out := &pb.GRPCAction{}
	out.Port = direct.ValueOf(in.Port)
	out.Service = direct.ValueOf(in.Service)
	return out
}
func WorkerPoolHTTPGetAction_FromProto(mapCtx *direct.MapContext, in *pb.HTTPGetAction) *krm.WorkerPoolHTTPGetAction {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolHTTPGetAction{}
	out.Path = direct.LazyPtr(in.GetPath())
	out.HTTPHeaders = direct.Slice_FromProto(mapCtx, in.HttpHeaders, WorkerPoolHTTPHeader_FromProto)
	out.Port = direct.LazyPtr(in.GetPort())
	return out
}
func WorkerPoolHTTPGetAction_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolHTTPGetAction) *pb.HTTPGetAction {
	if in == nil {
		return nil
	}
	out := &pb.HTTPGetAction{}
	out.Path = direct.ValueOf(in.Path)
	out.HttpHeaders = direct.Slice_ToProto(mapCtx, in.HTTPHeaders, WorkerPoolHTTPHeader_ToProto)
	out.Port = direct.ValueOf(in.Port)
	return out
}
func WorkerPoolHTTPHeader_FromProto(mapCtx *direct.MapContext, in *pb.HTTPHeader) *krm.WorkerPoolHTTPHeader {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolHTTPHeader{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Value = direct.LazyPtr(in.GetValue())
	return out
}
func WorkerPoolHTTPHeader_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolHTTPHeader) *pb.HTTPHeader {
	if in == nil {
		return nil
	}
	out := &pb.HTTPHeader{}
	out.Name = direct.ValueOf(in.Name)
	out.Value = direct.ValueOf(in.Value)
	return out
}
func WorkerPoolInstanceSplit_FromProto(mapCtx *direct.MapContext, in *pb.InstanceSplit) *krm.WorkerPoolInstanceSplit {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolInstanceSplit{}
	out.Type = direct.Enum_FromProto(mapCtx, in.GetType())
	out.Revision = direct.LazyPtr(in.GetRevision())
	out.Percent = direct.LazyPtr(in.GetPercent())
	return out
}
func WorkerPoolInstanceSplit_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolInstanceSplit) *pb.InstanceSplit {
	if in == nil {
		return nil
	}
	out := &pb.InstanceSplit{}
	out.Type = direct.Enum_ToProto[pb.InstanceSplitAllocationType](mapCtx, in.Type)
	out.Revision = direct.ValueOf(in.Revision)
	out.Percent = direct.ValueOf(in.Percent)
	return out
}
func WorkerPoolInstanceSplitStatus_FromProto(mapCtx *direct.MapContext, in *pb.InstanceSplitStatus) *krm.WorkerPoolInstanceSplitStatus {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolInstanceSplitStatus{}
	out.Type = direct.Enum_FromProto(mapCtx, in.GetType())
	out.Revision = direct.LazyPtr(in.GetRevision())
	out.Percent = direct.LazyPtr(in.GetPercent())
	return out
}
func WorkerPoolInstanceSplitStatus_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolInstanceSplitStatus) *pb.InstanceSplitStatus {
	if in == nil {
		return nil
	}
	out := &pb.InstanceSplitStatus{}
	out.Type = direct.Enum_ToProto[pb.InstanceSplitAllocationType](mapCtx, in.Type)
	out.Revision = direct.ValueOf(in.Revision)
	out.Percent = direct.ValueOf(in.Percent)
	return out
}
func WorkerPoolNFSVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.NFSVolumeSource) *krm.WorkerPoolNFSVolumeSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolNFSVolumeSource{}
	out.Server = direct.LazyPtr(in.GetServer())
	out.Path = direct.LazyPtr(in.GetPath())
	out.ReadOnly = direct.LazyPtr(in.GetReadOnly())
	return out
}
func WorkerPoolNFSVolumeSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolNFSVolumeSource) *pb.NFSVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.NFSVolumeSource{}
	out.Server = direct.ValueOf(in.Server)
	out.Path = direct.ValueOf(in.Path)
	out.ReadOnly = direct.ValueOf(in.ReadOnly)
	return out
}
func WorkerPoolNodeSelector_FromProto(mapCtx *direct.MapContext, in *pb.NodeSelector) *krm.WorkerPoolNodeSelector {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolNodeSelector{}
	out.Accelerator = direct.LazyPtr(in.GetAccelerator())
	return out
}
func WorkerPoolNodeSelector_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolNodeSelector) *pb.NodeSelector {
	if in == nil {
		return nil
	}
	out := &pb.NodeSelector{}
	out.Accelerator = direct.ValueOf(in.Accelerator)
	return out
}
func WorkerPoolProbe_FromProto(mapCtx *direct.MapContext, in *pb.Probe) *krm.WorkerPoolProbe {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolProbe{}
	out.InitialDelaySeconds = direct.LazyPtr(in.GetInitialDelaySeconds())
	// MISSING: TimeoutSeconds
	out.PeriodSeconds = direct.LazyPtr(in.GetPeriodSeconds())
	out.FailureThreshold = direct.LazyPtr(in.GetFailureThreshold())
	out.HTTPGet = WorkerPoolHTTPGetAction_FromProto(mapCtx, in.GetHttpGet())
	out.TCPSocket = WorkerPoolTCPSocketAction_FromProto(mapCtx, in.GetTcpSocket())
	out.Grpc = WorkerPoolGRPCAction_FromProto(mapCtx, in.GetGrpc())
	return out
}
func WorkerPoolProbe_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolProbe) *pb.Probe {
	if in == nil {
		return nil
	}
	out := &pb.Probe{}
	out.InitialDelaySeconds = direct.ValueOf(in.InitialDelaySeconds)
	// MISSING: TimeoutSeconds
	out.PeriodSeconds = direct.ValueOf(in.PeriodSeconds)
	out.FailureThreshold = direct.ValueOf(in.FailureThreshold)
	if oneof := WorkerPoolHTTPGetAction_ToProto(mapCtx, in.HTTPGet); oneof != nil {
		out.ProbeType = &pb.Probe_HttpGet{HttpGet: oneof}
	}
	if oneof := WorkerPoolTCPSocketAction_ToProto(mapCtx, in.TCPSocket); oneof != nil {
		out.ProbeType = &pb.Probe_TcpSocket{TcpSocket: oneof}
	}
	if oneof := WorkerPoolGRPCAction_ToProto(mapCtx, in.Grpc); oneof != nil {
		out.ProbeType = &pb.Probe_Grpc{Grpc: oneof}
	}
	return out
}
func WorkerPoolResourceRequirements_FromProto(mapCtx *direct.MapContext, in *pb.ResourceRequirements) *krm.WorkerPoolResourceRequirements {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolResourceRequirements{}
	out.Limits = in.Limits
	out.CPUIdle = direct.LazyPtr(in.GetCpuIdle())
	out.StartupCPUBoost = direct.LazyPtr(in.GetStartupCpuBoost())
	return out
}
func WorkerPoolResourceRequirements_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolResourceRequirements) *pb.ResourceRequirements {
	if in == nil {
		return nil
	}
	out := &pb.ResourceRequirements{}
	out.Limits = in.Limits
	out.CpuIdle = direct.ValueOf(in.CPUIdle)
	out.StartupCpuBoost = direct.ValueOf(in.StartupCPUBoost)
	return out
}
func WorkerPoolRevisionTemplate_FromProto(mapCtx *direct.MapContext, in *pb.WorkerPoolRevisionTemplate) *krm.WorkerPoolRevisionTemplate {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolRevisionTemplate{}
	out.Revision = direct.LazyPtr(in.GetRevision())
	out.Labels = in.Labels
	out.Annotations = in.Annotations
	out.VPCAccess = WorkerPoolVPCAccess_FromProto(mapCtx, in.GetVpcAccess())
	if in.GetServiceAccount() != "" {
		out.ServiceAccountRef = &refsv1beta1.IAMServiceAccountRef{External: in.GetServiceAccount()}
	}
	out.Containers = direct.Slice_FromProto(mapCtx, in.Containers, WorkerPoolContainer_FromProto)
	out.Volumes = direct.Slice_FromProto(mapCtx, in.Volumes, WorkerPoolVolume_FromProto)
	if in.GetEncryptionKey() != "" {
		out.EncryptionKeyRef = &refsv1beta1.KMSCryptoKeyRef{External: in.GetEncryptionKey()}
	}
	out.ServiceMesh = WorkerPoolServiceMesh_FromProto(mapCtx, in.GetServiceMesh())
	out.EncryptionKeyRevocationAction = direct.Enum_FromProto(mapCtx, in.GetEncryptionKeyRevocationAction())
	out.EncryptionKeyShutdownDuration = direct.StringDuration_FromProto(mapCtx, in.GetEncryptionKeyShutdownDuration())
	out.NodeSelector = WorkerPoolNodeSelector_FromProto(mapCtx, in.GetNodeSelector())
	out.GpuZonalRedundancyDisabled = in.GpuZonalRedundancyDisabled
	return out
}
func WorkerPoolRevisionTemplate_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolRevisionTemplate) *pb.WorkerPoolRevisionTemplate {
	if in == nil {
		return nil
	}
	out := &pb.WorkerPoolRevisionTemplate{}
	out.Revision = direct.ValueOf(in.Revision)
	out.Labels = in.Labels
	out.Annotations = in.Annotations
	out.VpcAccess = WorkerPoolVPCAccess_ToProto(mapCtx, in.VPCAccess)
	if in.ServiceAccountRef != nil {
		out.ServiceAccount = in.ServiceAccountRef.External
	}
	out.Containers = direct.Slice_ToProto(mapCtx, in.Containers, WorkerPoolContainer_ToProto)
	out.Volumes = direct.Slice_ToProto(mapCtx, in.Volumes, WorkerPoolVolume_ToProto)
	if in.EncryptionKeyRef != nil {
		out.EncryptionKey = in.EncryptionKeyRef.External
	}
	out.ServiceMesh = WorkerPoolServiceMesh_ToProto(mapCtx, in.ServiceMesh)
	out.EncryptionKeyRevocationAction = direct.Enum_ToProto[pb.EncryptionKeyRevocationAction](mapCtx, in.EncryptionKeyRevocationAction)
	out.EncryptionKeyShutdownDuration = direct.StringDuration_ToProto(mapCtx, in.EncryptionKeyShutdownDuration)
	out.NodeSelector = WorkerPoolNodeSelector_ToProto(mapCtx, in.NodeSelector)
	out.GpuZonalRedundancyDisabled = in.GpuZonalRedundancyDisabled
	return out
}
func WorkerPoolRevisionTemplateObservedState_FromProto(mapCtx *direct.MapContext, in *pb.WorkerPoolRevisionTemplate) *krm.WorkerPoolRevisionTemplateObservedState {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolRevisionTemplateObservedState{}
	// MISSING: Revision
	// MISSING: Labels
	// MISSING: Annotations
	// MISSING: VPCAccess
	// MISSING: ServiceAccount
	out.Containers = direct.Slice_FromProto(mapCtx, in.Containers, WorkerPoolContainerObservedState_FromProto)
	// MISSING: Volumes
	// MISSING: EncryptionKey
	// MISSING: ServiceMesh
	// MISSING: EncryptionKeyRevocationAction
	// MISSING: EncryptionKeyShutdownDuration
	// MISSING: NodeSelector
	// MISSING: GpuZonalRedundancyDisabled
	return out
}
func WorkerPoolRevisionTemplateObservedState_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolRevisionTemplateObservedState) *pb.WorkerPoolRevisionTemplate {
	if in == nil {
		return nil
	}
	out := &pb.WorkerPoolRevisionTemplate{}
	// MISSING: Revision
	// MISSING: Labels
	// MISSING: Annotations
	// MISSING: VPCAccess
	// MISSING: ServiceAccount
	out.Containers = direct.Slice_ToProto(mapCtx, in.Containers, WorkerPoolContainerObservedState_ToProto)
	// MISSING: Volumes
	// MISSING: EncryptionKey
	// MISSING: ServiceMesh
	// MISSING: EncryptionKeyRevocationAction
	// MISSING: EncryptionKeyShutdownDuration
	// MISSING: NodeSelector
	// MISSING: GpuZonalRedundancyDisabled
	return out
}
func WorkerPoolScaling_FromProto(mapCtx *direct.MapContext, in *pb.WorkerPoolScaling) *krm.WorkerPoolScaling {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolScaling{}
	out.ManualInstanceCount = in.ManualInstanceCount
	return out
}
func WorkerPoolScaling_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolScaling) *pb.WorkerPoolScaling {
	if in == nil {
		return nil
	}
	out := &pb.WorkerPoolScaling{}
	out.ManualInstanceCount = in.ManualInstanceCount
	return out
}
func WorkerPoolSecretKeySelector_FromProto(mapCtx *direct.MapContext, in *pb.SecretKeySelector) *krm.WorkerPoolSecretKeySelector {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolSecretKeySelector{}
	if in.GetSecret() != "" {
		out.SecretRef = &krmsecretmanagerv1beta1.SecretRef{External: in.GetSecret()}
	}
	if in.GetVersion() != "" {
		out.VersionRef = &krmsecretmanagerv1beta1.SecretVersionRef{External: in.GetVersion()}
	}
	return out
}
func WorkerPoolSecretKeySelector_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolSecretKeySelector) *pb.SecretKeySelector {
	if in == nil {
		return nil
	}
	out := &pb.SecretKeySelector{}
	if in.SecretRef != nil {
		out.Secret = in.SecretRef.External
	}
	if in.VersionRef != nil {
		out.Version = in.VersionRef.External
	}
	return out
}
func WorkerPoolSecretVolumeSource_FromProto(mapCtx *direct.MapContext, in *pb.SecretVolumeSource) *krm.WorkerPoolSecretVolumeSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolSecretVolumeSource{}
	if in.GetSecret() != "" {
		out.SecretRef = &krmsecretmanagerv1beta1.SecretRef{External: in.GetSecret()}
	}
	out.Items = direct.Slice_FromProto(mapCtx, in.Items, WorkerPoolVersionToPath_FromProto)
	out.DefaultMode = direct.LazyPtr(in.GetDefaultMode())
	return out
}
func WorkerPoolSecretVolumeSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolSecretVolumeSource) *pb.SecretVolumeSource {
	if in == nil {
		return nil
	}
	out := &pb.SecretVolumeSource{}
	if in.SecretRef != nil {
		out.Secret = in.SecretRef.External
	}
	out.Items = direct.Slice_ToProto(mapCtx, in.Items, WorkerPoolVersionToPath_ToProto)
	out.DefaultMode = direct.ValueOf(in.DefaultMode)
	return out
}
func WorkerPoolServiceMesh_FromProto(mapCtx *direct.MapContext, in *pb.ServiceMesh) *krm.WorkerPoolServiceMesh {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolServiceMesh{}
	out.Mesh = direct.LazyPtr(in.GetMesh())
	return out
}
func WorkerPoolServiceMesh_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolServiceMesh) *pb.ServiceMesh {
	if in == nil {
		return nil
	}
	out := &pb.ServiceMesh{}
	out.Mesh = direct.ValueOf(in.Mesh)
	return out
}
func WorkerPoolSourceCode_FromProto(mapCtx *direct.MapContext, in *pb.SourceCode) *krm.WorkerPoolSourceCode {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolSourceCode{}
	out.CloudStorageSource = WorkerPoolSourceCodeCloudStorageSource_FromProto(mapCtx, in.GetCloudStorageSource())
	return out
}
func WorkerPoolSourceCode_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolSourceCode) *pb.SourceCode {
	if in == nil {
		return nil
	}
	out := &pb.SourceCode{}
	if oneof := WorkerPoolSourceCodeCloudStorageSource_ToProto(mapCtx, in.CloudStorageSource); oneof != nil {
		out.SourceType = &pb.SourceCode_CloudStorageSource_{CloudStorageSource: oneof}
	}
	return out
}
func WorkerPoolSourceCodeCloudStorageSource_FromProto(mapCtx *direct.MapContext, in *pb.SourceCode_CloudStorageSource) *krm.WorkerPoolSourceCodeCloudStorageSource {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolSourceCodeCloudStorageSource{}
	out.Bucket = direct.LazyPtr(in.GetBucket())
	out.Object = direct.LazyPtr(in.GetObject())
	out.Generation = direct.LazyPtr(in.GetGeneration())
	return out
}
func WorkerPoolSourceCodeCloudStorageSource_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolSourceCodeCloudStorageSource) *pb.SourceCode_CloudStorageSource {
	if in == nil {
		return nil
	}
	out := &pb.SourceCode_CloudStorageSource{}
	out.Bucket = direct.ValueOf(in.Bucket)
	out.Object = direct.ValueOf(in.Object)
	out.Generation = direct.ValueOf(in.Generation)
	return out
}
func WorkerPoolTCPSocketAction_FromProto(mapCtx *direct.MapContext, in *pb.TCPSocketAction) *krm.WorkerPoolTCPSocketAction {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolTCPSocketAction{}
	out.Port = direct.LazyPtr(in.GetPort())
	return out
}
func WorkerPoolTCPSocketAction_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolTCPSocketAction) *pb.TCPSocketAction {
	if in == nil {
		return nil
	}
	out := &pb.TCPSocketAction{}
	out.Port = direct.ValueOf(in.Port)
	return out
}
func WorkerPoolVPCAccess_FromProto(mapCtx *direct.MapContext, in *pb.VpcAccess) *krm.WorkerPoolVPCAccess {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolVPCAccess{}
	if in.GetConnector() != "" {
		out.ConnectorRef = &krmvpcaccessv1beta1.VPCAccessConnectorRef{External: in.GetConnector()}
	}
	out.Egress = direct.Enum_FromProto(mapCtx, in.GetEgress())
	out.NetworkInterfaces = direct.Slice_FromProto(mapCtx, in.NetworkInterfaces, WorkerPoolVPCAccessNetworkInterface_FromProto)
	return out
}
func WorkerPoolVPCAccess_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolVPCAccess) *pb.VpcAccess {
	if in == nil {
		return nil
	}
	out := &pb.VpcAccess{}
	if in.ConnectorRef != nil {
		out.Connector = in.ConnectorRef.External
	}
	out.Egress = direct.Enum_ToProto[pb.VpcAccess_VpcEgress](mapCtx, in.Egress)
	out.NetworkInterfaces = direct.Slice_ToProto(mapCtx, in.NetworkInterfaces, WorkerPoolVPCAccessNetworkInterface_ToProto)
	return out
}
func WorkerPoolVPCAccessNetworkInterface_FromProto(mapCtx *direct.MapContext, in *pb.VpcAccess_NetworkInterface) *krm.WorkerPoolVPCAccessNetworkInterface {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolVPCAccessNetworkInterface{}
	if in.GetNetwork() != "" {
		out.NetworkRef = &krmcomputev1beta1.ComputeNetworkRef{External: in.GetNetwork()}
	}
	if in.GetSubnetwork() != "" {
		out.SubnetworkRef = &refsv1beta1.ComputeSubnetworkRef{External: in.GetSubnetwork()}
	}
	out.Tags = in.Tags
	return out
}
func WorkerPoolVPCAccessNetworkInterface_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolVPCAccessNetworkInterface) *pb.VpcAccess_NetworkInterface {
	if in == nil {
		return nil
	}
	out := &pb.VpcAccess_NetworkInterface{}
	if in.NetworkRef != nil {
		out.Network = in.NetworkRef.External
	}
	if in.SubnetworkRef != nil {
		out.Subnetwork = in.SubnetworkRef.External
	}
	out.Tags = in.Tags
	return out
}
func WorkerPoolVersionToPath_FromProto(mapCtx *direct.MapContext, in *pb.VersionToPath) *krm.WorkerPoolVersionToPath {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolVersionToPath{}
	out.Path = direct.LazyPtr(in.GetPath())
	if in.GetVersion() != "" {
		out.VersionRef = &krmsecretmanagerv1beta1.SecretVersionRef{External: in.GetVersion()}
	}
	out.Mode = direct.LazyPtr(in.GetMode())
	return out
}
func WorkerPoolVersionToPath_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolVersionToPath) *pb.VersionToPath {
	if in == nil {
		return nil
	}
	out := &pb.VersionToPath{}
	out.Path = direct.ValueOf(in.Path)
	if in.VersionRef != nil {
		out.Version = in.VersionRef.External
	}
	out.Mode = direct.ValueOf(in.Mode)
	return out
}
func WorkerPoolVolume_FromProto(mapCtx *direct.MapContext, in *pb.Volume) *krm.WorkerPoolVolume {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolVolume{}
	out.Name = direct.LazyPtr(in.GetName())
	out.Secret = WorkerPoolSecretVolumeSource_FromProto(mapCtx, in.GetSecret())
	out.CloudSQLInstance = WorkerPoolCloudSQLInstance_FromProto(mapCtx, in.GetCloudSqlInstance())
	out.EmptyDir = WorkerPoolEmptyDirVolumeSource_FromProto(mapCtx, in.GetEmptyDir())
	out.Nfs = WorkerPoolNFSVolumeSource_FromProto(mapCtx, in.GetNfs())
	out.GCS = WorkerPoolGCSVolumeSource_FromProto(mapCtx, in.GetGcs())
	return out
}
func WorkerPoolVolume_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolVolume) *pb.Volume {
	if in == nil {
		return nil
	}
	out := &pb.Volume{}
	out.Name = direct.ValueOf(in.Name)
	if oneof := WorkerPoolSecretVolumeSource_ToProto(mapCtx, in.Secret); oneof != nil {
		out.VolumeType = &pb.Volume_Secret{Secret: oneof}
	}
	if oneof := WorkerPoolCloudSQLInstance_ToProto(mapCtx, in.CloudSQLInstance); oneof != nil {
		out.VolumeType = &pb.Volume_CloudSqlInstance{CloudSqlInstance: oneof}
	}
	if oneof := WorkerPoolEmptyDirVolumeSource_ToProto(mapCtx, in.EmptyDir); oneof != nil {
		out.VolumeType = &pb.Volume_EmptyDir{EmptyDir: oneof}
	}
	if oneof := WorkerPoolNFSVolumeSource_ToProto(mapCtx, in.Nfs); oneof != nil {
		out.VolumeType = &pb.Volume_Nfs{Nfs: oneof}
	}
	if oneof := WorkerPoolGCSVolumeSource_ToProto(mapCtx, in.GCS); oneof != nil {
		out.VolumeType = &pb.Volume_Gcs{Gcs: oneof}
	}
	return out
}
func WorkerPoolVolumeMount_FromProto(mapCtx *direct.MapContext, in *pb.VolumeMount) *krm.WorkerPoolVolumeMount {
	if in == nil {
		return nil
	}
	out := &krm.WorkerPoolVolumeMount{}
	out.Name = direct.LazyPtr(in.GetName())
	out.MountPath = direct.LazyPtr(in.GetMountPath())
	out.SubPath = direct.LazyPtr(in.GetSubPath())
	return out
}
func WorkerPoolVolumeMount_ToProto(mapCtx *direct.MapContext, in *krm.WorkerPoolVolumeMount) *pb.VolumeMount {
	if in == nil {
		return nil
	}
	out := &pb.VolumeMount{}
	out.Name = direct.ValueOf(in.Name)
	out.MountPath = direct.ValueOf(in.MountPath)
	out.SubPath = direct.ValueOf(in.SubPath)
	return out
}
