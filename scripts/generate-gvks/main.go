// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file generates a list of all GVKs supported by KCC.

package main

import (
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"

	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/crd/crdloader"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/k8s"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

func main() {
	outputDir := ""
	flag.StringVar(&outputDir, "output-dir", outputDir, "Output directory to write GVK -> reconciler type mapping.")
	flag.Parse()

	if outputDir == "" {
		fmt.Fprintf(os.Stderr, "error: --output-dir must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	crds, err := crdloader.LoadCRDs()
	if err != nil {
		fmt.Fprintf(os.Stderr, "error loading CRDs: %v\n", err)
		os.Exit(1)
	}

	out := `// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "scripts/generate-gvks" in "make manifests"; DO NOT EDIT.

package supportedgvks

import "k8s.io/apimachinery/pkg/runtime/schema"

type legacyGVKData struct {
	Terraform bool
	DCL       bool
}

var legacyGVKs = map[schema.GroupVersionKind]legacyGVKData{`

	for _, crd := range crds {
		for _, version := range crd.Spec.Versions {
			gvk := schema.GroupVersionKind{
				Group:   crd.Spec.Group,
				Kind:    crd.Spec.Names.Kind,
				Version: version.Name,
			}

			terraform := crd.Labels[k8s.TF2CRDLabel] == "true"
			dcl := crd.Labels[k8s.DCL2CRDLabel] == "true"

			if !terraform && !dcl {
				continue // Skip direct GVKs
			}

			gvkEntry := `
	{
		Group:   "%s",
		Version: "%s",
		Kind:    "%s",
	}: {
		Terraform: %v,
		DCL:       %v,
	},`
			out += fmt.Sprintf(gvkEntry, gvk.Group, gvk.Version, gvk.Kind, terraform, dcl)
		}
	}

	out += `}`

	outFormatted, err := format.Source([]byte(out))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting output file: %s\n", err)
		os.Exit(1)
	}

	outputFile := filepath.Join(outputDir, "gvks_generated.go")
	fmt.Fprintf(os.Stderr, "Writing output to %s\n", outputFile)
	if err := os.WriteFile(outputFile, outFormatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %s\n", err)
		os.Exit(1)
	}
}
