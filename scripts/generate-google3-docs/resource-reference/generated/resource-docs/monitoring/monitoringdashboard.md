{# AUTOGENERATED. DO NOT EDIT. #}

{% extends "config-connector/_base.html" %}

{% block page_title %}MonitoringDashboard{% endblock %}
{% block body %}


<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>{{gcp_name_short}} Service Name</td>
<td>Cloud Monitoring</td>
</tr>
<tr>
<td>{{gcp_name_short}} Service Documentation</td>
<td><a href="/monitoring/dashboards/">/monitoring/dashboards/</a></td>
</tr>
<tr>
<td>{{gcp_name_short}} REST Resource Name</td>
<td>v3.projects.dashboards</td>
</tr>
<tr>
<td>{{gcp_name_short}} REST Resource Documentation</td>
<td><a href="/monitoring/api/ref_v3/rest/v1/projects.dashboards/">monitoring/api/ref_v3/rest/v1/projects.dashboards/</a></td>
</tr>
<tr>
<td>{{product_name_short}} Resource Short Names</td>
<td>gcpmonitoringdashboard<br>gcpmonitoringdashboards<br>monitoringdashboard</td>
</tr>
<tr>
<td>{{product_name_short}} Service Name</td>
<td>monitoring.googleapis.com</td>
</tr>
<tr>
<td>{{product_name_short}} Resource Fully Qualified Name</td>
<td>monitoringdashboards.monitoring.cnrm.cloud.google.com</td>
</tr>

<tr>
    <td>Can Be Referenced by IAMPolicy/IAMPolicyMember</td>
    <td>No</td>
</tr>


<tr>
<td>{{product_name_short}} Default Average Reconcile Interval In Seconds</td>
<td>600</td>
</tr>
</tbody>
</table>

## Custom Resource Definition Properties



### Spec
#### Schema
```yaml
columnLayout:
  columns:
  - weight: integer
    widgets:
    - alertChart:
        alertPolicyRef:
          external: string
          name: string
          namespace: string
      blank: {}
      collapsibleGroup:
        collapsed: boolean
      errorReportingPanel:
        projectRefs:
        - external: string
          kind: string
          name: string
          namespace: string
        services:
        - string
        versions:
        - string
      id: string
      incidentList:
        monitoredResources:
        - labels:
            string: string
          type: string
        policyRefs:
        - external: string
          name: string
          namespace: string
      logsPanel:
        filter: string
        resourceNames:
        - external: string
          kind: string
          name: string
          namespace: string
      pieChart:
        chartType: string
        dataSets:
        - minAlignmentPeriod: string
          sliceNameTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        showLabels: boolean
      scorecard:
        blankView: {}
        gaugeView:
          lowerBound: float
          upperBound: float
        sparkChartView:
          minAlignmentPeriod: string
          sparkChartType: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      sectionHeader:
        dividerBelow: boolean
        subtitle: string
      singleViewGroup: {}
      text:
        content: string
        format: string
        style:
          backgroundColor: string
          fontSize: string
          horizontalAlignment: string
          padding: string
          pointerLocation: string
          textColor: string
          verticalAlignment: string
      timeSeriesTable:
        columnSettings:
        - column: string
          visible: boolean
        dataSets:
        - minAlignmentPeriod: string
          tableDisplayOptions:
            shownColumns:
            - string
          tableTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        metricVisualization: string
      title: string
      xyChart:
        chartOptions:
          mode: string
        dataSets:
        - legendTemplate: string
          minAlignmentPeriod: string
          plotType: string
          targetAxis: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeshiftDuration: string
        xAxis:
          label: string
          scale: string
        y2Axis:
          label: string
          scale: string
        yAxis:
          label: string
          scale: string
dashboardFilters:
- filterType: string
  labelKey: string
  stringValue: string
  templateVariable: string
displayName: string
gridLayout:
  columns: integer
  widgets:
  - alertChart:
      alertPolicyRef:
        external: string
        name: string
        namespace: string
    blank: {}
    collapsibleGroup:
      collapsed: boolean
    errorReportingPanel:
      projectRefs:
      - external: string
        kind: string
        name: string
        namespace: string
      services:
      - string
      versions:
      - string
    id: string
    incidentList:
      monitoredResources:
      - labels:
          string: string
        type: string
      policyRefs:
      - external: string
        name: string
        namespace: string
    logsPanel:
      filter: string
      resourceNames:
      - external: string
        kind: string
        name: string
        namespace: string
    pieChart:
      chartType: string
      dataSets:
      - minAlignmentPeriod: string
        sliceNameTemplate: string
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      showLabels: boolean
    scorecard:
      blankView: {}
      gaugeView:
        lowerBound: float
        upperBound: float
      sparkChartView:
        minAlignmentPeriod: string
        sparkChartType: string
      thresholds:
      - color: string
        direction: string
        label: string
        targetAxis: string
        value: float
      timeSeriesQuery:
        outputFullDuration: boolean
        prometheusQuery: string
        timeSeriesFilter:
          aggregation:
            alignmentPeriod: string
            crossSeriesReducer: string
            groupByFields:
            - string
            perSeriesAligner: string
          filter: string
          pickTimeSeriesFilter:
            direction: string
            numTimeSeries: integer
            rankingMethod: string
          secondaryAggregation:
            alignmentPeriod: string
            crossSeriesReducer: string
            groupByFields:
            - string
            perSeriesAligner: string
        timeSeriesFilterRatio:
          denominator:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
          numerator:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
          pickTimeSeriesFilter:
            direction: string
            numTimeSeries: integer
            rankingMethod: string
          secondaryAggregation:
            alignmentPeriod: string
            crossSeriesReducer: string
            groupByFields:
            - string
            perSeriesAligner: string
        timeSeriesQueryLanguage: string
        unitOverride: string
    sectionHeader:
      dividerBelow: boolean
      subtitle: string
    singleViewGroup: {}
    text:
      content: string
      format: string
      style:
        backgroundColor: string
        fontSize: string
        horizontalAlignment: string
        padding: string
        pointerLocation: string
        textColor: string
        verticalAlignment: string
    timeSeriesTable:
      columnSettings:
      - column: string
        visible: boolean
      dataSets:
      - minAlignmentPeriod: string
        tableDisplayOptions:
          shownColumns:
          - string
        tableTemplate: string
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      metricVisualization: string
    title: string
    xyChart:
      chartOptions:
        mode: string
      dataSets:
      - legendTemplate: string
        minAlignmentPeriod: string
        plotType: string
        targetAxis: string
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      thresholds:
      - color: string
        direction: string
        label: string
        targetAxis: string
        value: float
      timeshiftDuration: string
      xAxis:
        label: string
        scale: string
      y2Axis:
        label: string
        scale: string
      yAxis:
        label: string
        scale: string
mosaicLayout:
  columns: integer
  tiles:
  - height: integer
    widget:
      alertChart:
        alertPolicyRef:
          external: string
          name: string
          namespace: string
      blank: {}
      collapsibleGroup:
        collapsed: boolean
      errorReportingPanel:
        projectRefs:
        - external: string
          kind: string
          name: string
          namespace: string
        services:
        - string
        versions:
        - string
      id: string
      incidentList:
        monitoredResources:
        - labels:
            string: string
          type: string
        policyRefs:
        - external: string
          name: string
          namespace: string
      logsPanel:
        filter: string
        resourceNames:
        - external: string
          kind: string
          name: string
          namespace: string
      pieChart:
        chartType: string
        dataSets:
        - minAlignmentPeriod: string
          sliceNameTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        showLabels: boolean
      scorecard:
        blankView: {}
        gaugeView:
          lowerBound: float
          upperBound: float
        sparkChartView:
          minAlignmentPeriod: string
          sparkChartType: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      sectionHeader:
        dividerBelow: boolean
        subtitle: string
      singleViewGroup: {}
      text:
        content: string
        format: string
        style:
          backgroundColor: string
          fontSize: string
          horizontalAlignment: string
          padding: string
          pointerLocation: string
          textColor: string
          verticalAlignment: string
      timeSeriesTable:
        columnSettings:
        - column: string
          visible: boolean
        dataSets:
        - minAlignmentPeriod: string
          tableDisplayOptions:
            shownColumns:
            - string
          tableTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        metricVisualization: string
      title: string
      xyChart:
        chartOptions:
          mode: string
        dataSets:
        - legendTemplate: string
          minAlignmentPeriod: string
          plotType: string
          targetAxis: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeshiftDuration: string
        xAxis:
          label: string
          scale: string
        y2Axis:
          label: string
          scale: string
        yAxis:
          label: string
          scale: string
    width: integer
    xPos: integer
    yPos: integer
projectRef:
  external: string
  kind: string
  name: string
  namespace: string
resourceID: string
rowLayout:
  rows:
  - weight: integer
    widgets:
    - alertChart:
        alertPolicyRef:
          external: string
          name: string
          namespace: string
      blank: {}
      collapsibleGroup:
        collapsed: boolean
      errorReportingPanel:
        projectRefs:
        - external: string
          kind: string
          name: string
          namespace: string
        services:
        - string
        versions:
        - string
      id: string
      incidentList:
        monitoredResources:
        - labels:
            string: string
          type: string
        policyRefs:
        - external: string
          name: string
          namespace: string
      logsPanel:
        filter: string
        resourceNames:
        - external: string
          kind: string
          name: string
          namespace: string
      pieChart:
        chartType: string
        dataSets:
        - minAlignmentPeriod: string
          sliceNameTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        showLabels: boolean
      scorecard:
        blankView: {}
        gaugeView:
          lowerBound: float
          upperBound: float
        sparkChartView:
          minAlignmentPeriod: string
          sparkChartType: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeSeriesQuery:
          outputFullDuration: boolean
          prometheusQuery: string
          timeSeriesFilter:
            aggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
            filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesFilterRatio:
            denominator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            numerator:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
            pickTimeSeriesFilter:
              direction: string
              numTimeSeries: integer
              rankingMethod: string
            secondaryAggregation:
              alignmentPeriod: string
              crossSeriesReducer: string
              groupByFields:
              - string
              perSeriesAligner: string
          timeSeriesQueryLanguage: string
          unitOverride: string
      sectionHeader:
        dividerBelow: boolean
        subtitle: string
      singleViewGroup: {}
      text:
        content: string
        format: string
        style:
          backgroundColor: string
          fontSize: string
          horizontalAlignment: string
          padding: string
          pointerLocation: string
          textColor: string
          verticalAlignment: string
      timeSeriesTable:
        columnSettings:
        - column: string
          visible: boolean
        dataSets:
        - minAlignmentPeriod: string
          tableDisplayOptions:
            shownColumns:
            - string
          tableTemplate: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        metricVisualization: string
      title: string
      xyChart:
        chartOptions:
          mode: string
        dataSets:
        - legendTemplate: string
          minAlignmentPeriod: string
          plotType: string
          targetAxis: string
          timeSeriesQuery:
            outputFullDuration: boolean
            prometheusQuery: string
            timeSeriesFilter:
              aggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
              filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesFilterRatio:
              denominator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              numerator:
                aggregation:
                  alignmentPeriod: string
                  crossSeriesReducer: string
                  groupByFields:
                  - string
                  perSeriesAligner: string
                filter: string
              pickTimeSeriesFilter:
                direction: string
                numTimeSeries: integer
                rankingMethod: string
              secondaryAggregation:
                alignmentPeriod: string
                crossSeriesReducer: string
                groupByFields:
                - string
                perSeriesAligner: string
            timeSeriesQueryLanguage: string
            unitOverride: string
        thresholds:
        - color: string
          direction: string
          label: string
          targetAxis: string
          value: float
        timeshiftDuration: string
        xAxis:
          label: string
          scale: string
        y2Axis:
          label: string
          scale: string
        yAxis:
          label: string
          scale: string
```

<table class="properties responsive">
<thead>
    <tr>
        <th colspan="2">Fields</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td>
            <p><code>columnLayout</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The content is divided into equally spaced columns and the widgets are arranged vertically.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The columns of content to display.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].weight</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The display widgets arranged vertically in this column.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].alertChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of alert policy data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].alertChart.alertPolicyRef</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. A reference to the MonitoringAlertPolicy.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].alertChart.alertPolicyRef.external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].alertChart.alertPolicyRef.name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].alertChart.alertPolicyRef.namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].blank</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A blank space.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].collapsibleGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].collapsibleGroup.collapsed</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}The collapsed state of the widget on first page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays a list of error groups.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The projects from which to gather errors.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The Project that this resource belongs to.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `projectID` field of a project, when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The kind of the Project resource; optional but must be `Project` if provided.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.projectRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.services</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to `version`, which can be changed whenever new code is deployed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.services[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.versions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].errorReportingPanel.versions[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].id</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows list of incidents.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.monitoredResources</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The monitored resource for which incidents are listed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.monitoredResources[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.monitoredResources[].labels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">map (key: string, value: string)</code></p>
            <p>{% verbatim %}Required. Values for all of the labels listed in the associated monitored resource descriptor.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.monitoredResources[].type</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The monitored resource type. This field must match the `type` field of a [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.policyRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. A list of alert policies to filter the incident list by.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.policyRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.policyRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.policyRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].incidentList.policyRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows a stream of logs.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.filter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A filter that chooses which log entries to return.  See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The names of logging resources to collect logs for.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The external name of the referenced resource{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Kind of the referent.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].logsPanel.resourceNames[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays timeseries data as a pie chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.chartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. Indicates the visualization type for the PieChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The queries for the chart's data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].sliceNameTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template for the name of the slice.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. The query for the PieChart. See, `google.monitoring.dashboard.v1.TimeSeriesQuery`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].pieChart.showLabels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. Indicates whether or not the pie chart should show slices' labels{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A scorecard summarizing time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.blankView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the `Scorecard` to show only the value, with no indicator to its value relative to its thresholds.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.gaugeView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a gauge chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.gaugeView.lowerBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.gaugeView.upperBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.sparkChartView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a spark chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.sparkChartView.minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.sparkChartView.sparkChartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The type of sparkchart to show in this chartView.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The thresholds used to determine the state of the scorecard given the time series' current value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].scorecard.timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].sectionHeader</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that defines a section header for easier navigation of the dashboard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].sectionHeader.dividerBelow</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Whether to insert a divider below the section in the table of contents{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].sectionHeader.subtitle</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The subtitle of the section{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].singleViewGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets by using a dropdown menu.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A raw string or markdown displaying textual content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.content</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text content to be displayed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.format</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How the text content is formatted.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}How the text is styled{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.backgroundColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The background color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.fontSize</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Font sizes for both the title and content. The title will still be larger relative to the content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.horizontalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The horizontal alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.padding</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The amount of padding around the widget{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.pointerLocation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The pointer location for this widget (also sometimes called a "tail"){% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.textColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].text.style.verticalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The vertical alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays time series data in a tabular format.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.columnSettings</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The list of the persistent column settings for the table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.columnSettings[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.columnSettings[].column</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The id of the column.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.columnSettings[].visible</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Required. Whether the column should be visible on page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Optional. Table display options for configuring how the table is rendered.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].tableTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].timeSeriesTable.metricVisualization</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. Store rendering strategy{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].title</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The title of the widget.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.chartOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Display options for the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.chartOptions.mode</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The chart mode.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].legendTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].plotType</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How this data should be plotted on the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The target axis to use for plotting the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Threshold lines drawn horizontally across the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.timeshiftDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The duration used to display a comparison chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.xAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the x-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.xAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.xAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.y2Axis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y2-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.y2Axis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.y2Axis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.yAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.yAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>columnLayout.columns[].widgets[].xyChart.yAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Filters to reduce the amount of data charted based on the filter criteria.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters[].filterType</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The specified filter type{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters[].labelKey</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The key for the label{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters[].stringValue</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A variable-length string value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>dashboardFilters[].templateVariable</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>displayName</code></p>
            <p><i>Required</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The mutable, human-readable name.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.columns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The informational elements that are arranged into the columns row-first.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].alertChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of alert policy data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].alertChart.alertPolicyRef</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. A reference to the MonitoringAlertPolicy.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].alertChart.alertPolicyRef.external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].alertChart.alertPolicyRef.name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].alertChart.alertPolicyRef.namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].blank</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A blank space.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].collapsibleGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].collapsibleGroup.collapsed</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}The collapsed state of the widget on first page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays a list of error groups.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The projects from which to gather errors.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The Project that this resource belongs to.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `projectID` field of a project, when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The kind of the Project resource; optional but must be `Project` if provided.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.projectRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.services</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to `version`, which can be changed whenever new code is deployed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.services[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.versions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].errorReportingPanel.versions[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].id</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows list of incidents.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.monitoredResources</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The monitored resource for which incidents are listed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.monitoredResources[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.monitoredResources[].labels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">map (key: string, value: string)</code></p>
            <p>{% verbatim %}Required. Values for all of the labels listed in the associated monitored resource descriptor.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.monitoredResources[].type</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The monitored resource type. This field must match the `type` field of a [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.policyRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. A list of alert policies to filter the incident list by.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.policyRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.policyRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.policyRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].incidentList.policyRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows a stream of logs.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.filter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A filter that chooses which log entries to return.  See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The names of logging resources to collect logs for.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The external name of the referenced resource{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Kind of the referent.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].logsPanel.resourceNames[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays timeseries data as a pie chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.chartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. Indicates the visualization type for the PieChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The queries for the chart's data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].sliceNameTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template for the name of the slice.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. The query for the PieChart. See, `google.monitoring.dashboard.v1.TimeSeriesQuery`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].pieChart.showLabels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. Indicates whether or not the pie chart should show slices' labels{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A scorecard summarizing time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.blankView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the `Scorecard` to show only the value, with no indicator to its value relative to its thresholds.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.gaugeView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a gauge chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.gaugeView.lowerBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.gaugeView.upperBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.sparkChartView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a spark chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.sparkChartView.minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.sparkChartView.sparkChartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The type of sparkchart to show in this chartView.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The thresholds used to determine the state of the scorecard given the time series' current value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].scorecard.timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].sectionHeader</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that defines a section header for easier navigation of the dashboard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].sectionHeader.dividerBelow</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Whether to insert a divider below the section in the table of contents{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].sectionHeader.subtitle</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The subtitle of the section{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].singleViewGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets by using a dropdown menu.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A raw string or markdown displaying textual content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.content</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text content to be displayed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.format</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How the text content is formatted.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}How the text is styled{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.backgroundColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The background color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.fontSize</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Font sizes for both the title and content. The title will still be larger relative to the content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.horizontalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The horizontal alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.padding</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The amount of padding around the widget{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.pointerLocation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The pointer location for this widget (also sometimes called a "tail"){% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.textColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].text.style.verticalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The vertical alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays time series data in a tabular format.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.columnSettings</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The list of the persistent column settings for the table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.columnSettings[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.columnSettings[].column</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The id of the column.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.columnSettings[].visible</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Required. Whether the column should be visible on page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].tableDisplayOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Optional. Table display options for configuring how the table is rendered.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].tableTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].timeSeriesTable.metricVisualization</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. Store rendering strategy{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].title</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The title of the widget.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.chartOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Display options for the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.chartOptions.mode</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The chart mode.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].legendTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].plotType</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How this data should be plotted on the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The target axis to use for plotting the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Threshold lines drawn horizontally across the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.timeshiftDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The duration used to display a comparison chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.xAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the x-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.xAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.xAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.y2Axis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y2-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.y2Axis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.y2Axis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.yAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.yAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>gridLayout.widgets[].xyChart.yAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.columns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The number of columns in the mosaic grid. The number of columns must be between 1 and 12, inclusive.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The tiles to display.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].height</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The informational widget contained in the tile. For example an `XyChart`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.alertChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of alert policy data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.alertChart.alertPolicyRef</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. A reference to the MonitoringAlertPolicy.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.alertChart.alertPolicyRef.external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.alertChart.alertPolicyRef.name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.alertChart.alertPolicyRef.namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.blank</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A blank space.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.collapsibleGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.collapsibleGroup.collapsed</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}The collapsed state of the widget on first page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays a list of error groups.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The projects from which to gather errors.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The Project that this resource belongs to.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `projectID` field of a project, when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The kind of the Project resource; optional but must be `Project` if provided.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.projectRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.services</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to `version`, which can be changed whenever new code is deployed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.services[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.versions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.errorReportingPanel.versions[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.id</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows list of incidents.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.monitoredResources</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The monitored resource for which incidents are listed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.monitoredResources[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.monitoredResources[].labels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">map (key: string, value: string)</code></p>
            <p>{% verbatim %}Required. Values for all of the labels listed in the associated monitored resource descriptor.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.monitoredResources[].type</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The monitored resource type. This field must match the `type` field of a [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.policyRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. A list of alert policies to filter the incident list by.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.policyRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.policyRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.policyRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.incidentList.policyRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows a stream of logs.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.filter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A filter that chooses which log entries to return.  See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The names of logging resources to collect logs for.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The external name of the referenced resource{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Kind of the referent.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.logsPanel.resourceNames[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays timeseries data as a pie chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.chartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. Indicates the visualization type for the PieChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The queries for the chart's data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].sliceNameTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template for the name of the slice.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. The query for the PieChart. See, `google.monitoring.dashboard.v1.TimeSeriesQuery`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.pieChart.showLabels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. Indicates whether or not the pie chart should show slices' labels{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A scorecard summarizing time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.blankView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the `Scorecard` to show only the value, with no indicator to its value relative to its thresholds.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.gaugeView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a gauge chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.gaugeView.lowerBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.gaugeView.upperBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.sparkChartView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a spark chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.sparkChartView.minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.sparkChartView.sparkChartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The type of sparkchart to show in this chartView.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The thresholds used to determine the state of the scorecard given the time series' current value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.scorecard.timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.sectionHeader</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that defines a section header for easier navigation of the dashboard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.sectionHeader.dividerBelow</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Whether to insert a divider below the section in the table of contents{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.sectionHeader.subtitle</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The subtitle of the section{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.singleViewGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets by using a dropdown menu.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A raw string or markdown displaying textual content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.content</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text content to be displayed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.format</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How the text content is formatted.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}How the text is styled{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.backgroundColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The background color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.fontSize</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Font sizes for both the title and content. The title will still be larger relative to the content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.horizontalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The horizontal alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.padding</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The amount of padding around the widget{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.pointerLocation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The pointer location for this widget (also sometimes called a "tail"){% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.textColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.text.style.verticalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The vertical alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays time series data in a tabular format.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.columnSettings</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The list of the persistent column settings for the table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.columnSettings[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.columnSettings[].column</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The id of the column.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.columnSettings[].visible</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Required. Whether the column should be visible on page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].tableDisplayOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Optional. Table display options for configuring how the table is rendered.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].tableTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.timeSeriesTable.metricVisualization</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. Store rendering strategy{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.title</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The title of the widget.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.chartOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Display options for the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.chartOptions.mode</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The chart mode.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].legendTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].plotType</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How this data should be plotted on the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The target axis to use for plotting the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Threshold lines drawn horizontally across the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.timeshiftDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The duration used to display a comparison chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.xAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the x-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.xAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.xAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.y2Axis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y2-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.y2Axis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.y2Axis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.yAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.yAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].widget.xyChart.yAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].width</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].xPos</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. `x_pos` cannot be negative.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>mosaicLayout.tiles[].yPos</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. `y_pos` cannot be negative.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>projectRef</code></p>
            <p><i>Required</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Immutable. The Project that this resource belongs to.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>projectRef.external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `projectID` field of a project, when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>projectRef.kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The kind of the Project resource; optional but must be `Project` if provided.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>projectRef.name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>projectRef.namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>resourceID</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Immutable. Optional. The name of the resource. Used for creation and acquisition.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The content is divided into equally spaced rows and the widgets are arranged horizontally.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The rows of content to display.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].weight</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The display widgets arranged horizontally in this row.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].alertChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of alert policy data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].alertChart.alertPolicyRef</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. A reference to the MonitoringAlertPolicy.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].alertChart.alertPolicyRef.external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].alertChart.alertPolicyRef.name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].alertChart.alertPolicyRef.namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].blank</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A blank space.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].collapsibleGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].collapsibleGroup.collapsed</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}The collapsed state of the widget on first page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays a list of error groups.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The projects from which to gather errors.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The Project that this resource belongs to.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `projectID` field of a project, when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The kind of the Project resource; optional but must be `Project` if provided.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.projectRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `Project` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.services</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to `version`, which can be changed whenever new code is deployed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.services[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.versions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].errorReportingPanel.versions[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].id</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows list of incidents.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.monitoredResources</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The monitored resource for which incidents are listed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.monitoredResources[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.monitoredResources[].labels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">map (key: string, value: string)</code></p>
            <p>{% verbatim %}Required. Values for all of the labels listed in the associated monitored resource descriptor.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.monitoredResources[].type</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The monitored resource type. This field must match the `type` field of a [MonitoredResourceDescriptor][google.api.MonitoredResourceDescriptor] object.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.policyRefs</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. A list of alert policies to filter the incident list by.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.policyRefs[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.policyRefs[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The MonitoringAlertPolicy link in the form "projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]", when not managed by Config Connector.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.policyRefs[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `name` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].incidentList.policyRefs[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `namespace` field of a `MonitoringAlertPolicy` resource.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that shows a stream of logs.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.filter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A filter that chooses which log entries to return.  See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries).{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The names of logging resources to collect logs for.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames[].external</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The external name of the referenced resource{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames[].kind</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Kind of the referent.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames[].name</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].logsPanel.resourceNames[].namespace</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays timeseries data as a pie chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.chartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. Indicates the visualization type for the PieChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The queries for the chart's data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].sliceNameTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template for the name of the slice.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. The query for the PieChart. See, `google.monitoring.dashboard.v1.TimeSeriesQuery`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].pieChart.showLabels</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. Indicates whether or not the pie chart should show slices' labels{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A scorecard summarizing time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.blankView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the `Scorecard` to show only the value, with no indicator to its value relative to its thresholds.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.gaugeView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a gauge chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.gaugeView.lowerBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.gaugeView.upperBound</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.sparkChartView</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Will cause the scorecard to show a spark chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.sparkChartView.minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.sparkChartView.sparkChartType</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The type of sparkchart to show in this chartView.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}The thresholds used to determine the state of the scorecard given the time series' current value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].scorecard.timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].sectionHeader</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that defines a section header for easier navigation of the dashboard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].sectionHeader.dividerBelow</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Whether to insert a divider below the section in the table of contents{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].sectionHeader.subtitle</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The subtitle of the section{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].singleViewGroup</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that groups the other widgets by using a dropdown menu.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A raw string or markdown displaying textual content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.content</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text content to be displayed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.format</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How the text content is formatted.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}How the text is styled{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.backgroundColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The background color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.fontSize</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Font sizes for both the title and content. The title will still be larger relative to the content.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.horizontalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The horizontal alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.padding</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The amount of padding around the widget{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.pointerLocation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The pointer location for this widget (also sometimes called a "tail"){% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.textColor</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The text color as a hex string. "#RRGGBB" or "#RGB"{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].text.style.verticalAlignment</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The vertical alignment of both the title and content{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A widget that displays time series data in a tabular format.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.columnSettings</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Optional. The list of the persistent column settings for the table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.columnSettings[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.columnSettings[].column</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The id of the column.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.columnSettings[].visible</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Required. Whether the column should be visible on page load.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this table.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Optional. Table display options for configuring how the table is rendered.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].tableDisplayOptions.shownColumns[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].tableTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Required. Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].timeSeriesTable.metricVisualization</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. Store rendering strategy{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].title</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The title of the widget.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}A chart of time series data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.chartOptions</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Display options for the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.chartOptions.mode</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The chart mode.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Required. The data displayed in this chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[]</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].legendTemplate</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A template string for naming `TimeSeries` in the resulting data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].minAlignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The lower bound on data point frequency for this data set.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].plotType</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How this data should be plotted on the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Optional. The target axis to use for plotting the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Fields for querying time series data from the Stackdriver metrics API.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.outputFullDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">boolean</code></p>
            <p>{% verbatim %}Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.prometheusQuery</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with PromQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Filter parameters to fetch time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after `aggregation` is applied.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilter.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Parameters to fetch a ratio between two time series filters.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The denominator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.denominator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The numerator of the ratio.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}By default, the raw time series data is returned.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.aggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.numerator.filter</code></p>
            <p><i>Required*</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Ranking based time series filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}How to use the ranking to select time series that pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.numTimeSeries</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}How many time series to allow to pass through the filter.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.pickTimeSeriesFilter.rankingMethod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}Apply a second aggregation after the ratio is computed.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.alignmentPeriod</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.crossSeriesReducer</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (string)</code></p>
            <p>{% verbatim %}The set of fields to preserve when `cross_series_reducer` is specified.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.groupByFields[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesFilterRatio.secondaryAggregation.perSeriesAligner</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.timeSeriesQueryLanguage</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A query used to fetch time series with MQL.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.dataSets[].timeSeriesQuery.unitOverride</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Threshold lines drawn horizontally across the chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[]</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[].color</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The state color for this threshold. Color is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[].direction</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The direction for the current threshold. Direction is not allowed in a XyChart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[].label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}A label for the threshold.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[].targetAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.thresholds[].value</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">float</code></p>
            <p>{% verbatim %}The value of the threshold. The value should be defined in the native scale of the metric.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.timeshiftDuration</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The duration used to display a comparison chart.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.xAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the x-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.xAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.xAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.y2Axis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y2-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.y2Axis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.y2Axis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.yAxis</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}The properties applied to the y-axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.yAxis.label</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The label of the axis.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td>
            <p><code>rowLayout.rows[].widgets[].xyChart.yAxis.scale</code></p>
            <p><i>Optional</i></p>
        </td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}The axis scale. By default, a linear scale is used.{% endverbatim %}</p>
        </td>
    </tr>
</tbody>
</table>


<p>* Field is required when parent field is specified</p>


### Status
#### Schema
```yaml
conditions:
- lastTransitionTime: string
  message: string
  reason: string
  status: string
  type: string
etag: string
observedGeneration: integer
```

<table class="properties responsive">
<thead>
    <tr>
        <th colspan="2">Fields</th>
    </tr>
</thead>
<tbody>
    <tr>
        <td><code>conditions</code></td>
        <td>
            <p><code class="apitype">list (object)</code></p>
            <p>{% verbatim %}Conditions represent the latest available observations of the MonitoringDashboard's current state.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[]</code></td>
        <td>
            <p><code class="apitype">object</code></p>
            <p>{% verbatim %}{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[].lastTransitionTime</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Last time the condition transitioned from one status to another.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[].message</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Human-readable message indicating details about last transition.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[].reason</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Unique, one-word, CamelCase reason for the condition's last transition.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[].status</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Status is the status of the condition. Can be True, False, Unknown.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>conditions[].type</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}Type is the type of the condition.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>etag</code></td>
        <td>
            <p><code class="apitype">string</code></p>
            <p>{% verbatim %}\`etag\` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other.{% endverbatim %}</p>
        </td>
    </tr>
    <tr>
        <td><code>observedGeneration</code></td>
        <td>
            <p><code class="apitype">integer</code></p>
            <p>{% verbatim %}ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.{% endverbatim %}</p>
        </td>
    </tr>
</tbody>
</table>

## Sample YAML(s)

### Typical Use Case
```yaml
# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: monitoring.cnrm.cloud.google.com/v1beta1
kind: MonitoringDashboard
metadata:
  name: monitoringdashboard-sample
spec:
  projectRef:
    # Replace ${PROJECT_ID?} with your project ID
    external: "projects/${PROJECT_ID?}"
  displayName: "monitoringdashboard-sample"
  columnLayout:
    columns:
    - weight: 2
      widgets:
      - title: "Widget 1"
        xyChart:
          dataSets:
          - timeSeriesQuery:
              timeSeriesFilter:
                filter: metric.type="agent.googleapis.com/nginx/connections/accepted_count"
                aggregation:
                  perSeriesAligner: "ALIGN_RATE"
              unitOverride: "1"
            plotType: LINE
          timeshiftDuration: 0s
          yAxis:
            label: y1Axis
            scale: LINEAR
      - text:
          content: "Widget 2"
          format: "MARKDOWN"
      - title: "Widget 3"
        xyChart:
          dataSets:
          - timeSeriesQuery:
              timeSeriesFilter:
                filter: metric.type="agent.googleapis.com/nginx/connections/accepted_count"
                aggregation:
                  perSeriesAligner: ALIGN_RATE
              unitOverride: "1"
            plotType: "STACKED_BAR"
          timeshiftDuration: 0s
          yAxis:
            label: y1Axis
            scale: LINEAR
      - title: "Widget 4"
        logsPanel:
          filter: metric.type="agent.googleapis.com/nginx/connections/accepted_count"
          resourceNames:
            # Replace ${PROJECT_ID?} with the ID of the project you wish to monitor
            - external: "projects/${PROJECT_ID?}"
```


Note: If you have any trouble with instantiating the resource, refer to <a href="/config-connector/docs/troubleshooting">Troubleshoot Config Connector</a>.

{% endblock %}