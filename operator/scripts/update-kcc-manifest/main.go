// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"

	"sigs.k8s.io/kubebuilder-declarative-pattern/pkg/patterns/addon/pkg/loaders"

	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/k8s"
	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/pkg/test/util/paths"
	"github.com/GoogleCloudPlatform/k8s-config-connector/operator/scripts/utils"
	"github.com/blang/semver/v4"
)

const (
	dirMode        = os.FileMode(0755) //drwxr-x---
	fileMode       = os.FileMode(0644) // -rw-r--r--
	gcsPathTmpl    = "gs://cnrm/%v/release-bundle.tar.gz"
	baseDir        = "scripts/update-kcc-manifest"
	channelDir     = "channels/packages/configconnector"
	managerPatch   = "manager_sidecar_patch.yaml"
	recorderPatch  = "recorder_sidecar_patch.yaml"
	finalizerPatch = "finalizer_patch.yaml"

	autopilotChannelDir    = "autopilot-channels/packages/configconnector"
	autopilotRecorderPatch = "recorder_remove_hostport_patch.yaml"
)

var (
	version string
)

// Download the latest KCC manifest, kustomize and upload it to the stable channel
// Usage: go run scripts/update-kcc-manifest/main.go --version latest
// For debug/testing you can run
// `go run scripts/update-kcc-manifest/main.go --version local`
// This will attempt to read a release-bundle.tar.gz from root generated by
// `./operator/scripts/release.sh -d`
func main() {
	ctx := context.TODO()

	flag.StringVar(&version, "version", "latest", "Version of the KCC core to download.")
	flag.Parse()

	// download the KCC manifest
	operatorSrcRoot := paths.GetOperatorSrcRootOrLogFatal()
	log.Printf("Operator source root is set to %s.\r\n", operatorSrcRoot)
	outputDir := path.Join(operatorSrcRoot, baseDir, "kcc")
	if err := os.Mkdir(outputDir, dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir %v: %w", outputDir, err))
	}
	if version == "local" {
		tarballPath := path.Join("..", "release-bundle.tar.gz")
		log.Printf("Extracting bundle resource from local %s to %s.\r\n", tarballPath, outputDir)
		if err := utils.ExtractTarball(tarballPath, outputDir); err != nil {
			log.Fatal(fmt.Errorf("error extracting tarball: %w", err))
		}
	} else {
		gcsPath := fmt.Sprintf(gcsPathTmpl, version)
		log.Printf("GCS Path is set to %s.\r\n", gcsPath)
		if err := utils.DownloadAndExtractTarballAt(gcsPath, outputDir); err != nil {
			log.Fatal(fmt.Errorf("error downloading and extracting the tarball %v: %w", gcsPath, err))
		}
	}

	kustomizeBuild(operatorSrcRoot)

	// swap container registry
	wiSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-workload-identity", "0-cnrm-system.yaml")
	gcpSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-gcp-identity", "0-cnrm-system.yaml")
	namespacedSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-namespaced", "0-cnrm-system.yaml")

	autopilotWiSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-workload-identity", "0-cnrm-system.yaml")
	autopilotGcpSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-gcp-identity", "0-cnrm-system.yaml")
	autopilotNamespacedSystemManifest := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-namespaced", "0-cnrm-system.yaml")

	pnc := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-namespaced", "per-namespace-components.yaml")
	manifests := []string{wiSystemManifest, gcpSystemManifest, namespacedSystemManifest, pnc}
	for _, manifest := range manifests {
		if err := swapContainerRegistry(manifest); err != nil {
			log.Fatal(fmt.Errorf("error swapping container registry: %w", err))
		}
	}
	autopilotPnc := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-namespaced", "per-namespace-components.yaml")
	manifests = []string{autopilotWiSystemManifest, autopilotGcpSystemManifest, autopilotNamespacedSystemManifest, autopilotPnc}
	for _, manifest := range manifests {
		if err := swapContainerRegistry(manifest); err != nil {
			log.Fatal(fmt.Errorf("error swapping container registry: %w", err))
		}
	}

	// upload the new manifest under channels dir
	manifestFile := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-namespaced", "0-cnrm-system.yaml")
	version, err := extractVersionFromManifest(manifestFile)
	if err != nil {
		log.Fatal(fmt.Errorf("error extracting version from manifest %v: %w", manifestFile, err))
	}
	manifestDir := path.Join(operatorSrcRoot, channelDir, version)
	if err := os.Mkdir(manifestDir, dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir %v: %w", manifestDir, err))
	}
	autopilotManifestDir := path.Join(operatorSrcRoot, autopilotChannelDir, version)
	if err := os.Mkdir(autopilotManifestDir, dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir %v: %w", autopilotManifestDir, err))
	}

	// copy crds.yaml
	crds := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-namespaced", "crds.yaml")
	destCRDs := path.Join(manifestDir, "crds.yaml")
	if err := utils.Copy(crds, destCRDs); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", crds, destCRDs, err))
	}
	destCRDs = path.Join(autopilotManifestDir, "crds.yaml")
	if err := utils.Copy(crds, destCRDs); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", crds, destCRDs, err))
	}

	// create the cluster dir
	if err := os.Mkdir(path.Join(manifestDir, "cluster"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}
	if err := os.Mkdir(path.Join(autopilotManifestDir, "cluster"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}

	// copy install-bundle-workload-identity/0-cnrm-system.yaml
	if err := os.Mkdir(path.Join(manifestDir, "cluster", "workload-identity"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}
	destWiSystemManifest := path.Join(manifestDir, "cluster", "workload-identity", "0-cnrm-system.yaml")
	if err := utils.Copy(wiSystemManifest, destWiSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", wiSystemManifest, destWiSystemManifest, err))
	}
	if err := os.Mkdir(path.Join(autopilotManifestDir, "cluster", "workload-identity"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}
	destWiSystemManifest = path.Join(autopilotManifestDir, "cluster", "workload-identity", "0-cnrm-system.yaml")
	if err := utils.Copy(autopilotWiSystemManifest, destWiSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", wiSystemManifest, destWiSystemManifest, err))
	}

	// copy install-bundle-gcp-identity/0-cnrm-system.yaml
	if err := os.Mkdir(path.Join(manifestDir, "cluster", "gcp-identity"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}
	destGcpSystemManifest := path.Join(manifestDir, "cluster", "gcp-identity", "0-cnrm-system.yaml")
	if err := utils.Copy(gcpSystemManifest, destGcpSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", wiSystemManifest, destWiSystemManifest, err))
	}
	if err := os.Mkdir(path.Join(autopilotManifestDir, "cluster", "gcp-identity"), dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir: %w", err))
	}
	destGcpSystemManifest = path.Join(autopilotManifestDir, "cluster", "gcp-identity", "0-cnrm-system.yaml")
	if err := utils.Copy(autopilotGcpSystemManifest, destGcpSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", wiSystemManifest, destWiSystemManifest, err))
	}

	// copy install-bundle-namespaced/0-cnrm-system.yaml and install-bundle-namespaced/per-namespace-components.yaml
	namespacedDir := path.Join(manifestDir, "namespaced")
	if err := os.Mkdir(namespacedDir, dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir %v: %w", namespacedDir, err))
	}
	destNamespacedSystemManifest := path.Join(manifestDir, "namespaced", "0-cnrm-system.yaml")
	if err := utils.Copy(namespacedSystemManifest, destNamespacedSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", namespacedSystemManifest, destNamespacedSystemManifest, err))
	}
	destPnc := path.Join(manifestDir, "namespaced", "per-namespace-components.yaml")
	if err := utils.Copy(pnc, destPnc); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", pnc, destPnc, err))
	}
	namespacedDir = path.Join(autopilotManifestDir, "namespaced")
	if err := os.Mkdir(namespacedDir, dirMode); err != nil && !os.IsExist(err) {
		log.Fatal(fmt.Errorf("error creating dir %v: %w", namespacedDir, err))
	}
	destNamespacedSystemManifest = path.Join(autopilotManifestDir, "namespaced", "0-cnrm-system.yaml")
	if err := utils.Copy(autopilotNamespacedSystemManifest, destNamespacedSystemManifest); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", autopilotNamespacedSystemManifest, destNamespacedSystemManifest, err))
	}
	destPnc = path.Join(autopilotManifestDir, "namespaced", "per-namespace-components.yaml")
	if err := utils.Copy(autopilotPnc, destPnc); err != nil {
		log.Fatal(fmt.Errorf("error copying %v to %v: %w", autopilotPnc, destPnc, err))
	}

	if err := os.RemoveAll(outputDir); err != nil {
		log.Fatal(fmt.Errorf("error deleting dir %v: %w", outputDir, err))
	}

	// update the operator version for default kustomization
	kustomizationFilePath := path.Join(operatorSrcRoot, "config", "default", "kustomization.yaml")
	b, err := ioutil.ReadFile(kustomizationFilePath)
	if err != nil {
		log.Fatal(fmt.Errorf("error reading %v: %w", kustomizationFilePath, err))
	}
	kustomization := string(b)
	m := regexp.MustCompile("cnrm.cloud.google.com/operator-version: (\".*\")")
	kustomization = m.ReplaceAllString(kustomization, fmt.Sprintf("cnrm.cloud.google.com/operator-version: \"%v\"", version))
	if err := ioutil.WriteFile(kustomizationFilePath, []byte(kustomization), fileMode); err != nil {
		log.Fatalf("error updating file %v", kustomizationFilePath)
	}
	log.Printf("successfully updated the version annotation in %v for default kustomization\n", kustomizationFilePath)

	// update the operator version for autopilot kustomization
	kustomizationFilePath = path.Join(operatorSrcRoot, "config", "autopilot", "kustomization.yaml")
	b, err = ioutil.ReadFile(kustomizationFilePath)
	if err != nil {
		log.Fatal(fmt.Errorf("error reading %v: %w", kustomizationFilePath, err))
	}
	kustomization = string(b)
	m = regexp.MustCompile("cnrm.cloud.google.com/operator-version: (\".*\")")
	kustomization = m.ReplaceAllString(kustomization, fmt.Sprintf("cnrm.cloud.google.com/operator-version: \"%v\"", version))
	if err := ioutil.WriteFile(kustomizationFilePath, []byte(kustomization), fileMode); err != nil {
		log.Fatalf("error updating file %v", kustomizationFilePath)
	}
	log.Printf("successfully updated the version annotation in %v for autopilot kustomization\n", kustomizationFilePath)

	//Update the stable version
	r := loaders.NewFSRepository(path.Join(operatorSrcRoot, loaders.FlagChannel))
	channel, err := r.LoadChannel(ctx, k8s.StableChannel)
	if err != nil {
		log.Fatal(fmt.Errorf("error loading %v channel: %w", k8s.StableChannel, err))
	}
	currentVersion, err := channel.Latest(ctx, "configconnector")
	if err != nil {
		log.Fatal(fmt.Errorf("error resolving the current version: %w", err))
	}
	/*
		if currentVersion.Version == version {
			log.Printf("the current KCC version is the same as the latest version %v\n", version)
			return
		}*/
	stableFilePath := path.Join(operatorSrcRoot, "channels", "stable")
	b, err = ioutil.ReadFile(stableFilePath)
	if err != nil {
		log.Fatal(fmt.Errorf("error reading %v: %w", stableFilePath, err))
	}
	stable := string(b)
	stable = strings.ReplaceAll(stable, fmt.Sprintf("- version: %v", currentVersion.Version), fmt.Sprintf("- version: %v", version))
	if err := ioutil.WriteFile(stableFilePath, []byte(stable), fileMode); err != nil {
		log.Fatalf("error updating file %v", stableFilePath)
	}
	stableFilePath = path.Join(operatorSrcRoot, "autopilot-channels", "stable")
	b, err = ioutil.ReadFile(stableFilePath)
	if err != nil {
		log.Fatal(fmt.Errorf("error reading %v: %w", stableFilePath, err))
	}
	stable = string(b)
	stable = strings.ReplaceAll(stable, fmt.Sprintf("- version: %v", currentVersion.Version), fmt.Sprintf("- version: %v", version))
	if err := ioutil.WriteFile(stableFilePath, []byte(stable), fileMode); err != nil {
		log.Fatalf("error updating file %v", stableFilePath)
	}

	channelDir := path.Join(operatorSrcRoot, "channels", "packages", "configconnector")
	if err := dropStalePackages(channelDir); err != nil {
		log.Fatalf("drop stale packages: %s", err)
	}
	autoPilotChannelDir := path.Join(operatorSrcRoot, "autopilot-channels", "packages", "configconnector")
	if err := dropStalePackages(autoPilotChannelDir); err != nil {
		log.Fatalf("drop stale packages: %s", err)
	}
}

func dropStalePackages(packagesPath string) error {
	dirEntries, _ := os.ReadDir(packagesPath)

	totalReleases := Releases{}
	for _, entry := range dirEntries {
		if entry.IsDir() {
			totalReleases = append(totalReleases, entry.Name())
		} else {
			log.Printf("found unknown file %s under %s\n", entry.Name(), packagesPath)
		}
	}

	// Support the latest 3 minor versions with their latest patch
	supported := totalReleases.StablePatchAtTopMinor(3)

	// Drop older versions
	for _, r := range totalReleases {
		shouldKeep := false
		for _, s := range supported {
			if r == s {
				shouldKeep = true
				break
			}
		}
		if shouldKeep {
			continue
		}
		staleManifestDir := path.Join(packagesPath, r)
		log.Printf("removing stale manifest %v", staleManifestDir)
		if err := os.RemoveAll(staleManifestDir); err != nil {
			log.Fatal(fmt.Errorf("error deleting dir %v: %w", staleManifestDir, err))
		}
	}
	return nil
}

type Releases []string

type minor int

type patches []int

// StablePatchAtTopMinor returns the latest `n` semver2 Minor releases with their latest semver2 Patch.
// For example, if the total releases are 1.121.2, 1.121.1, 1.121.0, 1.120.1, 1.120.0, 1.119.3, 1.119.2, 1.119.1, 1.119.0, 1.118.0, and n is 3, the top 3 stable versions are 1.121.2, 1.120.1, 1.119.3
func (r Releases) StablePatchAtTopMinor(n int) []string {
	minorPatchesMap := map[minor]patches{}
	totalMinors := []int{}
	for _, release := range r {
		v, err := semver.ParseTolerant(release)
		if err != nil {
			log.Printf("skipping unknown packageÂ version %q", release)
		}
		m := minor(v.Minor)
		if _, ok := minorPatchesMap[m]; ok {
			minorPatchesMap[m] = append(minorPatchesMap[m], int(v.Patch))
		} else {
			totalMinors = append(totalMinors, int(m))
			minorPatchesMap[m] = patches{int(v.Patch)}
		}
	}
	sort.Sort(sort.IntSlice(totalMinors))
	if len(totalMinors) > n {
		totalMinors = totalMinors[len(totalMinors)-n:]
	}
	supportedVersions := []string{}
	for _, m := range totalMinors {
		patches := minorPatchesMap[minor(m)]
		sort.Sort(sort.IntSlice(patches))
		v := semver.Version{Major: 1, Minor: uint64(m), Patch: uint64(patches[len(patches)-1])}
		supportedVersions = append(supportedVersions, v.String())
	}
	return supportedVersions

}

func kustomizeBuild(operatorSrcRoot string) {
	// workload-identity cluster mode
	buildPath := path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-workload-identity")
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_workload-identity.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
		log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
	}
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, managerPatch), path.Join(buildPath, managerPatch)); err != nil {
		log.Fatal(fmt.Errorf("error copying %v: %w", managerPatch, err))
	}
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, recorderPatch), path.Join(buildPath, recorderPatch)); err != nil {
		log.Fatal(fmt.Errorf("error copying %v: %w", recorderPatch, err))
	}
	output := path.Join(buildPath, "0-cnrm-system.yaml")
	if err := utils.KustomizeBuild(buildPath, output); err != nil {
		log.Fatal(fmt.Errorf("error running kustomize build: %w", err))
	}

	// autopilot workload-identity cluster mode
	buildPath = path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-workload-identity")
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_autopilot_workload-identity.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
		log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
	}
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, autopilotRecorderPatch), path.Join(buildPath, autopilotRecorderPatch)); err != nil {
		log.Fatal(fmt.Errorf("error copying %v: %w", autopilotRecorderPatch, err))
	}
	output = path.Join(buildPath, "0-cnrm-system.yaml")
	if err := utils.KustomizeBuild(buildPath, output); err != nil {
		log.Fatal(fmt.Errorf("error running kustomize build: %w", err))
	}

	// autopilot gcp-identity cluster mode
	buildPath = path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-gcp-identity")
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_autopilot_gcp-identity.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
		log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
	}
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, autopilotRecorderPatch), path.Join(buildPath, autopilotRecorderPatch)); err != nil {
		log.Fatal(fmt.Errorf("error copying %v: %w", autopilotRecorderPatch, err))
	}
	output = path.Join(buildPath, "0-cnrm-system.yaml")
	if err := utils.KustomizeBuild(buildPath, output); err != nil {
		log.Fatal(fmt.Errorf("error running kustomize build: %w", err))
	}

	// namespaced mode
	buildPath = path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-namespaced")
	buildNamespacedMode(operatorSrcRoot, buildPath, output, false)

	// autpilot namespaced mode
	buildPath = path.Join(operatorSrcRoot, baseDir, "kcc", "install-bundle-autopilot-namespaced")
	buildNamespacedMode(operatorSrcRoot, buildPath, output, true)
}

func buildNamespacedMode(operatorSrcRoot, buildPath, output string, autopilot bool) {
	if !autopilot {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, managerPatch), path.Join(buildPath, managerPatch)); err != nil {
			log.Fatal(fmt.Errorf("error copying %v: %w", managerPatch, err))
		}
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, recorderPatch), path.Join(buildPath, recorderPatch)); err != nil {
			log.Fatal(fmt.Errorf("error copying %v: %w", recorderPatch, err))
		}
	} else {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, autopilotRecorderPatch), path.Join(buildPath, autopilotRecorderPatch)); err != nil {
			log.Fatal(fmt.Errorf("error copying %v: %w", autopilotRecorderPatch, err))
		}
	}
	if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, finalizerPatch), path.Join(buildPath, finalizerPatch)); err != nil {
		log.Fatal(fmt.Errorf("error copying %v: %w", finalizerPatch, err))
	}
	if autopilot {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_autopilot_namespaced_0-cnrm-system.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
			log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
		}
	} else {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_namespaced_0-cnrm-system.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
			log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
		}
	}
	output = path.Join(buildPath, "0-cnrm-system.yaml")
	if err := utils.KustomizeBuild(buildPath, output); err != nil {
		log.Fatal(fmt.Errorf("error running kustomize build: %w", err))
	}
	if autopilot {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_autopilot_namespaced_per-namespace-components.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
			log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
		}
	} else {
		if err := utils.Copy(path.Join(operatorSrcRoot, baseDir, "kustomizations", "kustomization_namespaced_per-namespace-components.yaml"), path.Join(buildPath, "kustomization.yaml")); err != nil {
			log.Fatal(fmt.Errorf("error copying kustomization: %w", err))
		}
	}
	output = path.Join(buildPath, "per-namespace-components.yaml")
	if err := utils.KustomizeBuild(buildPath, output); err != nil {
		log.Fatal(fmt.Errorf("error running kustomize build: %w", err))
	}
}

// This step can be removed once we switch KCC core to also use gcr.io/gke-release container registry
func swapContainerRegistry(manifestPath string) error {
	content, err := ioutil.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf("error reading manifestPath: %w", err)
	}
	manifest := string(content)
	updatedManifest := strings.ReplaceAll(manifest, "gcr.io/cnrm-eap/", "gcr.io/gke-release/")
	fileMode := os.FileMode(0644) // -rw-r--r--
	return ioutil.WriteFile(manifestPath, []byte(updatedManifest), fileMode)
}

func extractVersionFromManifest(filePath string) (string, error) {
	objs, err := utils.ReadFileToUnstructs(filePath)
	if err != nil {
		return "", fmt.Errorf("error reading file %v and converting to unstructs: %w", filePath, err)
	}
	for _, obj := range objs {
		if obj.GetKind() == "Namespace" && obj.GetName() == k8s.CNRMSystemNamespace {
			for key, val := range obj.GetAnnotations() {
				if key == k8s.VersionAnnotation {
					return val, nil
				}
			}
		}
	}
	return "", fmt.Errorf("couldn't extract the version from the manifest %v", filePath)
}
