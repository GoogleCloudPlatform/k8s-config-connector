# How to Add a new CRD with a Mapper and Fuzzer

This document outlines the steps to add a new direct controller, starting from the API definitions and generating the necessary type definitions, mappers, and fuzzers.

## 1. Create or Update `generate.sh`

Navigate to the `apis/<service>/<version>/` directory (e.g., `apis/mynewservice/v1alpha1/`). Check if a `generate.sh` script already exists.

**If `generate.sh` does not exist**, create a new one. This script will automate the generation of types, mappers, and CRDs. Use `apis/bigtable/v1alpha1/generate.sh` as a template. Your script should look something like this:

```bash
#!/bin/bash
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -o errexit
set -o nounset
set -o pipefail

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd ${REPO_ROOT}/dev/tools/controllerbuilder

# Generate the KCC type structs from the GCP proto definitions
go run . generate-types \
  --service google.example.api.v1 \
  --api-version mynewservice.cnrm.cloud.google.com/v1alpha1  \
  --resource MyNewResource:MyNewResource

# Generate the mapper functions that convert between the KCC structs and the GCP proto structs
go run . generate-mapper \
  --service google.example.api.v1 \
  --api-version mynewservice.cnrm.cloud.google.com/v1alpha1

# Change back to the repo root
cd ${REPO_ROOT}

# Generate the CRD YAML from the type structs
dev/tasks/generate-crds

# Format the generated Go code
go run -mod=readonly golang.org/x/tools/cmd/goimports@latest -w pkg/controller/direct/mynewservice/
```

**If `generate.sh` already exists**, do not overwrite it. Instead, add a new `--resource` flag to the `go run . generate-types` command for the resource you are adding. For example:

```bash
# ...
go run . generate-types \
  --service google.example.api.v1 \
  --api-version mynewservice.cnrm.cloud.google.com/v1alpha1  \
  --resource MyExistingResource:MyExistingResource \
  --resource MyNewResource:MyNewResource # Add your new resource here
# ...
```

## 2. Initial Code Generation

Run the `generate.sh` script you just created.

```bash
./apis/mynewservice/v1alpha1/generate.sh
```

This will create two important files in your API directory:
*   `types.generated.go`: Contains the Go structs generated directly from the GCP protos. **DO NOT EDIT THIS FILE.**
*   `<resource>_types.go` (e.g., `mynewresource_types.go`): Contains the high-level KCC API structs. This is the file you will edit.

## 3. Define `Spec` and `ObservedState`

Open the `<resource>_types.go` file. Your goal is to define two main structs:

*   **`Spec`**: This struct should contain all the user-configurable fields for the resource.
*   **`ObservedState`**: This struct should contain fields that are output-only or informative, such as the resource's creation time, current state, etc.

Use the `// +kcc:proto=` tag to map the fields in your `Spec` and `ObservedState` structs to the corresponding fields in the auto-generated `types.generated.go` file.

Example:
```go
// in mynewresource_types.go

type MyNewResourceSpec struct {
	// The user-configurable display name.
	// +kcc:proto=display_name
	DisplayName *string `json:"displayName,omitempty"`

    // ... other spec fields
}

type MyNewResourceObservedState struct {
	// Output only. The time the resource was created.
	// +kcc:proto=create_time
	CreateTime *string `json:"createTime,omitempty"`

    // ... other observed state fields
}
```

## 4. Add Parent and Resource References

Next, you need to correctly configure the parent resource and any fields that reference other KCC resources.

1.  **Add Parent:** Add the parent resource field to the `Spec` struct. This is typically a reference to a `Project`, `Folder`, or `Organization`.
2.  **Add References:** Identify any fields in the `Spec` that should reference another KCC resource (e.g., a `KMSKey` or a `Network`). Change the type of these fields to the KCC reference format (e.g., `KMSKeyRef`).

For detailed instructions on how to format these references, see [How to Add Resource References](docs/ai/add-resource-references.md).

## 5. Re-run `generate.sh`

After modifying `<resource>_types.go` with the correct `Spec`, `ObservedState`, parent, and references, run `generate.sh` again. This will update the generated mapper files based on your changes.

## 6. Add a Round-trip Fuzzer

To ensure the mapping between the KCC API object and the GCP proto is correct, you must add a fuzzer.

1.  Create a new fuzzer file in the corresponding direct controller package: `pkg/controller/direct/<service>/<resource>_fuzzer.go`.
2.  Use `pkg/controller/direct/run/job_fuzzer.go` as an example.
3.  The fuzzer needs to know which fields to ignore during the round-trip comparison. Use `f.SpecFields.Insert()` and `f.StatusFields.Insert()` to specify fields that exist in the KCC object but not the GCP proto (like annotations). Use `f.UnimplementedFields.Insert()` for fields that are not yet mapped.

Example Fuzzer:
```go
// in pkg/controller/direct/mynewservice/mynewresource_fuzzer.go

// +tool:fuzz-gen
// proto.message: google.example.api.v1.MyNewResource
// api.group: mynewservice.cnrm.cloud.google.com

package mynewservice

import (
	pb "google.golang.org/genproto/googleapis/example/api/v1"
	"github.com/GoogleCloudPlatform/k8s-config-connector/pkg/fuzztesting"
)

func init() {
	fuzztesting.RegisterKRMFuzzer(myNewResourceFuzzer())
}

func myNewResourceFuzzer() fuzztesting.KRMFuzzer {
	f := fuzztesting.NewKRMTypedFuzzer(&pb.MyNewResource{},
		MyNewResourceSpec_FromProto, MyNewResourceSpec_ToProto,
		MyNewResourceObservedState_FromProto, MyNewResourceObservedState_ToProto,
	)

	// Fields that exist in KCC spec but not in the proto
	f.SpecFields.Insert(".annotations")

	// Fields that exist in KCC status but not in the proto
	f.StatusFields.Insert(".create_time")
	f.StatusFields.Insert(".uid")

	// Fields that are not yet implemented or have known issues
	f.Unimplemented_NotYetTriaged(".some_field")

	return f
}
```

## 7. Verify with Fuzzer Tests

Run the fuzzer round-tripper presubmit check to validate your changes. This test can take over 10 minutes, so run it only when you believe your mapper is complete.

```bash
dev/ci/presubmits/fuzz-roundtrippers
```

## 8. Handling Complex Mapper Logic

The auto-generated mapper may not be able to handle all fields correctly, especially complex ones. **Do not manually edit the `_mapper.generated.go` file.**

Instead, create a manual mapper file: `pkg/controller/direct/<service>/<resource>_mapper.go`.

In this file, define the specific functions that the auto-mapper struggles with. The generator is smart enough to find your manual implementations and use them instead of generating new ones. After creating or updating this file, re-run `generate.sh`.

## 9. Troubleshooting: "proto: not found" error

If the `generate.sh` script fails with an error like `failed to find the proto message ...: proto: not found`, it means the resource definition is missing from the version of the Google Cloud protos included in this project. The generator tools read from a single large compiled proto file located at `.build/googleapis.pb`. This error means the required message definition is not in that file.

To fix this, you need to update the source protos from the `googleapis` repository and re-compile them:

1.  **Find the latest `googleapis` commit:** The `googleapis/googleapis` repository does not use GitHub releases for versioning. You will need to find the latest commit hash from the `master` branch. You can do this by visiting the repository's page (`https://github.com/googleapis/googleapis`) or by running the following command:
    ```bash
    git ls-remote https://github.com/googleapis/googleapis.git HEAD
    ```
2.  **Update `git.versions`:** Open the file `apis/git.versions` and update the commit hash for the `https://github.com/googleapis/googleapis` entry with the new hash you found.
3.  **Regenerate the compiled protos:** Run the `make gen-proto` target. This command specifically executes the `dev/tools/controllerbuilder/generate-proto.sh` script, which will:
    *   Fetch the `googleapis` repository at the specific commit you defined in `git.versions` into the `.build/third_party/googleapis` directory.
    *   Re-compile all the necessary `.proto` files into the single descriptor file at `.build/googleapis.pb`.
    This process can take several minutes.
    *(Note: If `make gen-proto` is not available, running `make all` will also perform this step, but it will run many other tasks as well.)*
4.  **Re-run `generate.sh`:** Once the `.build/googleapis.pb` file has been regenerated, you can re-run the `generate.sh` script for your service. It should now be able to find the proto message.
