# Adding a New Direct Resource

This guide outlines the structured, three-PR process for adding a new Config Connector resource using the "direct" controller approach. This workflow is designed to be iterative, with clear verification steps at each stage.

## PR #1: Foundational API and Scaffolding

**Goal:** Establish the resource's core API contract, including the CRD, the mapping to its underlying proto fields, and initial test scaffolding.

### 1. Generate Initial CRD, MapperÂ and Fuzzer

This is the first step to create the basic building blocks from the GCP API definition.

*   **Gemini Prompt:**
    ```bash
    "Add generate.sh for apis/<service>/v1alpha1, look at examples in apis/bigquerybiglake/v1alpha1/generate.sh, then run the generate.sh."
    ```

    ```bash
    "Add a <resource>_fuzzer.go for <kind>, and put it under pkg/controller/direct/<service>/v1alpha1, look at examples in @pkg/controller/direct/bigquerybiglake/table_fuzzer.go.
    ```

*   **Human Verification:**
    1.  If a manual mapper file already exists, comment out its contents to avoid conflicts.
    2.  Verify that the autogenerated mapper is in-sync with the API definition.
    3.  Ensure the generated fuzz test passes (`dev/ci/presubmits/fuzz-roundtrippers`).

### 2. Manual API Adjustments (Bridging the Gaps)

This part of PR #1 requires significant developer expertise and highlights areas where automation is still evolving.

*   **Manual Developer Tasks:**
    1.  Move the `Spec` and `ObservedState` structs from the autogenerated `*_types.go` file to the primary API file (e.g., `biglakecatalog_types.go`) that generates the CRD.
    2.  Add the fields that represent the resource's parent (e.g., `ProjectRef`, `FolderRef`). Our framework uses interfaces to enforce parent structure, but this is not yet automatically verified.
    3.  Replace raw `string` fields that represent other GCP resources with a proper KCC reference struct (e.g., `parent.ProjectRef`), even if the corresponding KCC controller isn't implemented yet.

*   **Manual Verification Checklist:**
    *   **Gap:** Are all API fields compliant with KCC conventions? (e.g., `etag` should not be in `spec` as it's not declarative-friendly).
    *   **Gap:** Are all string-based resource fields correctly replaced with KCC references? The test framework does not currently catch this.
    *   **Gap:** Is the parent field using the correct, latest parent struct interface? The test framework does not verify this.
    *   **Gap:** Does the fuzzer test cover all fields? If fields are skipped as "unimplemented," is there a valid reason?

---

## PR #2: Implement MockGCP Server (Can be done in parallel)

**Goal:** Generate the mock GCP server used for isolated, hermetic testing of the controller. This PR can be worked on concurrently with PR #1.

*   **Gemini Prompt:**
    ```bash
    "Generate the mockgcp server for <resource> using the mock CRUD generator."
    ```
*   **Human Verification:**
    1.  The generated mock server code is complete.
    2.  The mock correctly implements the basic CRUD (Create, Read, Update, Delete) operations for the resource.

---

## PR #3: Add Controller and Fixture Tests

**Goal:** Implement the controller's core reconciliation logic and verify it with end-to-end fixture tests. This PR depends on the completion of PR #1 and PR #2.

### 1. Scaffold the Controller and Identity Logic

*   **Gemini Prompt:**
    ```bash
    "Add the direct controller for <resource>, following the guide in @docs/ai/add-direct-controller.md"
    ```
*   **Human Verification:**
    1.  The generated code is compilable and structurally correct.

### 2. Add Fixture Tests to Verify the Controller

*   **Prerequisites:** The mockgcp server (from PR #2) must exist and support the necessary CRUD operations.
*   **Gemini Prompt:**
    ```bash
    "Add fixture tests for the <resource> controller to verify Create, Read, Update, and Delete operations using the mockgcp server."
    ```
*   **Human Verification:**
    1.  All fixture tests pass.
    2.  The test cases cover the full lifecycle of the resource (create, update, delete).

---

## Handle Special Cases (As Needed)

Some resources require special handling for common patterns like labels or resource references. We are actively resolving and unifying the special handling. Meanwhile, new cases could be defined and added in this list 

#### Special Case: GCP Labels

*   **Gemini Prompt:**
    ```bash
    "Fix the labels for <resource>, following the guide in docs/ai/handle-labels-for-direct-resource.md."
    ```
*   **Human Verification:**
    1.  Ensure no `labels` field exists in the `spec`.
    2.  The fuzz test must use the `fuzz.SkipLabels()` function to bypass the label check.
    3.  The controller must use the proto and call `label.NewGCPLabelsFromK8sLabels`.
    *(Note: If `spec.labels` is intentionally supported, this may not be necessary.)*

#### Special Case: Identity & Reference Interfaces

*   **Identity Interface (`identity.Identity`)**
    *   **Gemini Prompt:**
        ```bash
        "Update apis/<service>/<resource>_identity.go to implement the identity.Identity interface. Use apis/bigquerybiglake/v1alpha1/catalog_identity.go as an example."
        ```
    *   **Human Verification:**
        1.  Confirm the code is compilable.
        2.  Verify the logic in the `FromExternal` function is correct.

*   **Reference Interface (`refs.Ref`)**
    *   **Gemini Prompt:**
        ```bash
        "Update apis/<service>/<resource>_reference.go to implement the refs.Ref interface instead of ExternalNormalizer. Use apis/bigquerybiglake/v1alpha1/catalog_reference.go as an example."
        ```
    *   **Human Verification:**
        1.  Confirm the code is compilable.
        2.  Verify the logic in the `FromExternal` function is correct.