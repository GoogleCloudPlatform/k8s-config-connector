// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: mockgcp/cloud/networksecurity/v1/service.proto

/*
Package networksecuritypb is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package networksecuritypb

import (
	"context"
	"io"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AddItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.AddItemsOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AddItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.AddItemsOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CloneItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.CloneItemsOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CloneItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.CloneItemsOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_address_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsAddressGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListOrganizationsLocationsAddressGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsAddressGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListOrganizationsLocationsAddressGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"address_group": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListReferencesOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListReferencesOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListReferencesOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListReferencesOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_address_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RemoveItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.RemoveItemsOrganizationsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RemoveItemsOrganizationsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.RemoveItemsOrganizationsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_firewall_endpoint": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsFirewallEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsFirewallEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateOrganizationsLocationsFirewallEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsFirewallEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsFirewallEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateOrganizationsLocationsFirewallEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsFirewallEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteOrganizationsLocationsFirewallEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsFirewallEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteOrganizationsLocationsFirewallEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsFirewallEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetOrganizationsLocationsFirewallEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsFirewallEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetOrganizationsLocationsFirewallEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsFirewallEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsFirewallEndpointsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListOrganizationsLocationsFirewallEndpoints(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsFirewallEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsFirewallEndpointsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListOrganizationsLocationsFirewallEndpoints(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_firewall_endpoint": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsFirewallEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsFirewallEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchOrganizationsLocationsFirewallEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsFirewallEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsFirewallEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsFirewallEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchOrganizationsLocationsFirewallEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_security_profile_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfileGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfileGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfileGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfileGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfileGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfileGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfileGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfileGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfileGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsSecurityProfileGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListOrganizationsLocationsSecurityProfileGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfileGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsSecurityProfileGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListOrganizationsLocationsSecurityProfileGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_security_profile_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfileGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfileGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfileGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsSecurityProfileGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfileGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchOrganizationsLocationsSecurityProfileGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_security_profile": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfilesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfile); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateOrganizationsLocationsSecurityProfile(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfilesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfile); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateOrganizationsLocationsSecurityProfile(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfilesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteOrganizationsLocationsSecurityProfile(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfilesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteOrganizationsLocationsSecurityProfile(ctx, &protoReq)
	return msg, metadata, err

}

func request_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfilesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetOrganizationsLocationsSecurityProfile(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfilesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetOrganizationsLocationsSecurityProfile(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfilesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsSecurityProfilesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListOrganizationsLocationsSecurityProfiles(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfilesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListOrganizationsLocationsSecurityProfilesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListOrganizationsLocationsSecurityProfiles(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0 = &utilities.DoubleArray{Encoding: map[string]int{"organizations_locations_security_profile": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, client OrganizationsLocationsSecurityProfilesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfile); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchOrganizationsLocationsSecurityProfile(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(ctx context.Context, marshaler runtime.Marshaler, server OrganizationsLocationsSecurityProfilesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchOrganizationsLocationsSecurityProfileRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.OrganizationsLocationsSecurityProfile); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchOrganizationsLocationsSecurityProfile(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServer_GetProjectsLocation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServer_GetProjectsLocation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServer_ListProjectsLocations_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServer_ListProjectsLocations_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServer_ListProjectsLocations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocations(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServer_ListProjectsLocations_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServer_ListProjectsLocations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocations(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AddItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.AddItemsProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AddItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.AddItemsProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CloneItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.CloneItemsProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CloneItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.CloneItemsProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_address_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAddressGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsAddressGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAddressGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsAddressGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"address_group": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListReferencesProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListReferencesProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListReferencesProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListReferencesProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_address_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAddressGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RemoveItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := client.RemoveItemsProjectsLocationsAddressGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAddressGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RemoveItemsProjectsLocationsAddressGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAddressGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["address_group"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "address_group")
	}

	protoReq.AddressGroup, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "address_group", err)
	}

	msg, err := server.RemoveItemsProjectsLocationsAddressGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_authorization_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthorizationPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthorizationPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsAuthorizationPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthorizationPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthorizationPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsAuthorizationPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthorizationPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsAuthorizationPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthorizationPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsAuthorizationPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthorizationPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsAuthorizationPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthorizationPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsAuthorizationPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthorizationPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAuthorizationPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsAuthorizationPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthorizationPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAuthorizationPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsAuthorizationPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_authorization_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthorizationPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthorizationPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsAuthorizationPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthorizationPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAuthorizationPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthorizationPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsAuthorizationPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_authz_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthzPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthzPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsAuthzPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthzPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthzPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsAuthzPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthzPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsAuthzPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthzPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsAuthzPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthzPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsAuthzPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthzPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsAuthzPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthzPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAuthzPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsAuthzPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthzPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsAuthzPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsAuthzPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_authz_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsAuthzPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthzPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsAuthzPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsAuthzPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsAuthzPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsAuthzPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsAuthzPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_client_tls_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsClientTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsClientTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsClientTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsClientTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsClientTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsClientTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsClientTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsClientTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsClientTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsClientTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsClientTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsClientTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsClientTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsClientTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsClientTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsClientTlsPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsClientTlsPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsClientTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsClientTlsPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsClientTlsPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_client_tls_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsClientTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsClientTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsClientTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsClientTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsClientTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsClientTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsClientTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_firewall_endpoint_association": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsFirewallEndpointAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsFirewallEndpointAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsFirewallEndpointAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsFirewallEndpointAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsFirewallEndpointAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsFirewallEndpointAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsFirewallEndpointAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsFirewallEndpointAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsFirewallEndpointAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsFirewallEndpointAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsFirewallEndpointAssociations(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsFirewallEndpointAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsFirewallEndpointAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsFirewallEndpointAssociations(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_firewall_endpoint_association": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsFirewallEndpointAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsFirewallEndpointAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsFirewallEndpointAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsFirewallEndpointAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsFirewallEndpointAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsFirewallEndpointAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_gateway_security_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGatewaySecurityPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGatewaySecurityPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGatewaySecurityPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGatewaySecurityPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_gateway_security_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGatewaySecurityPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsGatewaySecurityPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_gateway_security_policies_rule": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPoliciesRule); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPoliciesRule); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGatewaySecurityPoliciesRulesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGatewaySecurityPoliciesRules(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGatewaySecurityPoliciesRulesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGatewaySecurityPoliciesRules(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_gateway_security_policies_rule": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPoliciesRule); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGatewaySecurityPoliciesRuleRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGatewaySecurityPoliciesRule); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsGatewaySecurityPoliciesRule(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_deployment_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptDeploymentGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsInterceptDeploymentGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptDeploymentGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsInterceptDeploymentGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_deployment_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsInterceptDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_deployment": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsInterceptDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsInterceptDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsInterceptDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsInterceptDeployment(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsInterceptDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsInterceptDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptDeploymentsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsInterceptDeployments(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptDeploymentsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsInterceptDeployments(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_deployment": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsInterceptDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsInterceptDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_endpoint_group_association": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptEndpointGroupAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsInterceptEndpointGroupAssociations(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptEndpointGroupAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsInterceptEndpointGroupAssociations(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_endpoint_group_association": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsInterceptEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_endpoint_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsInterceptEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsInterceptEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsInterceptEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsInterceptEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsInterceptEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsInterceptEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptEndpointGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsInterceptEndpointGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInterceptEndpointGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsInterceptEndpointGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_intercept_endpoint_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInterceptEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsInterceptEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInterceptEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInterceptEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInterceptEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsInterceptEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_deployment_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringDeploymentGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsMirroringDeploymentGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringDeploymentGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsMirroringDeploymentGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_deployment_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringDeploymentGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeploymentGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsMirroringDeploymentGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_deployment": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsMirroringDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsMirroringDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsMirroringDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsMirroringDeployment(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsMirroringDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsMirroringDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringDeploymentsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsMirroringDeployments(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringDeploymentsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsMirroringDeployments(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_deployment": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringDeploymentsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsMirroringDeployment(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringDeploymentsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringDeploymentRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringDeployment); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsMirroringDeployment(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_endpoint_group_association": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringEndpointGroupAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsMirroringEndpointGroupAssociations(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringEndpointGroupAssociationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsMirroringEndpointGroupAssociations(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_endpoint_group_association": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringEndpointGroupAssociationRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroupAssociation); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsMirroringEndpointGroupAssociation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_endpoint_group": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsMirroringEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsMirroringEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsMirroringEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsMirroringEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsMirroringEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsMirroringEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringEndpointGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsMirroringEndpointGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsMirroringEndpointGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsMirroringEndpointGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_mirroring_endpoint_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsMirroringEndpointGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsMirroringEndpointGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsMirroringEndpointGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsMirroringEndpointGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsMirroringEndpointGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsMirroringEndpointGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_server_tls_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServerTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsServerTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServerTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsServerTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsServerTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsServerTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsServerTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsServerTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServerTlsPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsServerTlsPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServerTlsPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsServerTlsPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_server_tls_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerTlsPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServerTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsServerTlsPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerTlsPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServerTlsPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServerTlsPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsServerTlsPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_tls_inspection_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsTlsInspectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsTlsInspectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsTlsInspectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsTlsInspectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsTlsInspectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsTlsInspectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsTlsInspectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsTlsInspectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsTlsInspectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsTlsInspectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsTlsInspectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsTlsInspectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsTlsInspectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsTlsInspectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsTlsInspectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsTlsInspectionPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsTlsInspectionPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsTlsInspectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsTlsInspectionPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsTlsInspectionPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_tls_inspection_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsTlsInspectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsTlsInspectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsTlsInspectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsTlsInspectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsTlsInspectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsTlsInspectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsTlsInspectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_url_list": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsUrlListsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsUrlList); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsUrlList(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsUrlListsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsUrlList); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsUrlList(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsUrlListsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.DeleteProjectsLocationsUrlList(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsUrlListsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.DeleteProjectsLocationsUrlList(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsUrlListsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsUrlList(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsUrlListsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsUrlList(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsUrlListsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsUrlListsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsUrlLists(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsUrlListsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsUrlListsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsUrlLists(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_url_list": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsUrlListsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsUrlList); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsUrlList(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsUrlListsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsUrlListRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsUrlList); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.StringP(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsUrlList(ctx, &protoReq)
	return msg, metadata, err

}

// RegisterOrganizationsLocationsAddressGroupsServerHandlerServer registers the http handlers for service OrganizationsLocationsAddressGroupsServer to "mux".
// UnaryRPC     :call OrganizationsLocationsAddressGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrganizationsLocationsAddressGroupsServerHandlerFromEndpoint instead.
func RegisterOrganizationsLocationsAddressGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrganizationsLocationsAddressGroupsServerServer) error {

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/AddItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:addItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/CloneItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:cloneItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/CreateOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/DeleteOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/GetOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/ListOrganizationsLocationsAddressGroups", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/ListReferencesOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:listReferences"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/PatchOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/RemoveItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:removeItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterOrganizationsLocationsFirewallEndpointsServerHandlerServer registers the http handlers for service OrganizationsLocationsFirewallEndpointsServer to "mux".
// UnaryRPC     :call OrganizationsLocationsFirewallEndpointsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrganizationsLocationsFirewallEndpointsServerHandlerFromEndpoint instead.
func RegisterOrganizationsLocationsFirewallEndpointsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrganizationsLocationsFirewallEndpointsServerServer) error {

	mux.Handle("POST", pattern_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/CreateOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/firewallEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/DeleteOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/GetOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/ListOrganizationsLocationsFirewallEndpoints", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/firewallEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/PatchOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerServer registers the http handlers for service OrganizationsLocationsSecurityProfileGroupsServer to "mux".
// UnaryRPC     :call OrganizationsLocationsSecurityProfileGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerFromEndpoint instead.
func RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrganizationsLocationsSecurityProfileGroupsServerServer) error {

	mux.Handle("POST", pattern_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/CreateOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfileGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/DeleteOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/GetOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/ListOrganizationsLocationsSecurityProfileGroups", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfileGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/PatchOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterOrganizationsLocationsSecurityProfilesServerHandlerServer registers the http handlers for service OrganizationsLocationsSecurityProfilesServer to "mux".
// UnaryRPC     :call OrganizationsLocationsSecurityProfilesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterOrganizationsLocationsSecurityProfilesServerHandlerFromEndpoint instead.
func RegisterOrganizationsLocationsSecurityProfilesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server OrganizationsLocationsSecurityProfilesServerServer) error {

	mux.Handle("POST", pattern_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/CreateOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfiles"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/DeleteOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/GetOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/ListOrganizationsLocationsSecurityProfiles", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfiles"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/PatchOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServerHandlerServer registers the http handlers for service ProjectsLocationsServer to "mux".
// UnaryRPC     :call ProjectsLocationsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServerServer) error {

	mux.Handle("GET", pattern_ProjectsLocationsServer_GetProjectsLocation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServer/GetProjectsLocation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServer_ListProjectsLocations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServer/ListProjectsLocations", runtime.WithHTTPPathPattern("/v1/{name=projects/*}/locations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsAddressGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsAddressGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsAddressGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsAddressGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsAddressGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsAddressGroupsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/AddItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:addItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/CloneItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:cloneItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/CreateProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/DeleteProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/GetProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/ListProjectsLocationsAddressGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/ListReferencesProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:listReferences"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/PatchProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/RemoveItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:removeItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsAuthorizationPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsAuthorizationPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsAuthorizationPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsAuthorizationPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsAuthorizationPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsAuthorizationPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/CreateProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authorizationPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/DeleteProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/GetProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/ListProjectsLocationsAuthorizationPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authorizationPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/PatchProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsAuthzPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsAuthzPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsAuthzPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsAuthzPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsAuthzPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsAuthzPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/CreateProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authzPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/DeleteProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/GetProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/ListProjectsLocationsAuthzPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authzPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/PatchProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsClientTlsPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsClientTlsPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsClientTlsPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsClientTlsPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsClientTlsPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsClientTlsPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/CreateProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/clientTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/DeleteProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/GetProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/ListProjectsLocationsClientTlsPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/clientTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/PatchProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerServer registers the http handlers for service ProjectsLocationsFirewallEndpointAssociationsServer to "mux".
// UnaryRPC     :call ProjectsLocationsFirewallEndpointAssociationsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsFirewallEndpointAssociationsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/CreateProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/firewallEndpointAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/DeleteProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/GetProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/ListProjectsLocationsFirewallEndpointAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/firewallEndpointAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/PatchProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsGatewaySecurityPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGatewaySecurityPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/CreateProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/gatewaySecurityPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/DeleteProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/GetProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/ListProjectsLocationsGatewaySecurityPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/gatewaySecurityPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/PatchProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerServer registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesRulesServer to "mux".
// UnaryRPC     :call ProjectsLocationsGatewaySecurityPoliciesRulesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGatewaySecurityPoliciesRulesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/CreateProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*/gatewaySecurityPolicies/*}/rules"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/DeleteProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/GetProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/ListProjectsLocationsGatewaySecurityPoliciesRules", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*/gatewaySecurityPolicies/*}/rules"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/PatchProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsInterceptDeploymentGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsInterceptDeploymentGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsInterceptDeploymentGroupsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/CreateProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/DeleteProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/GetProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/ListProjectsLocationsInterceptDeploymentGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/PatchProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsInterceptDeploymentsServerHandlerServer registers the http handlers for service ProjectsLocationsInterceptDeploymentsServer to "mux".
// UnaryRPC     :call ProjectsLocationsInterceptDeploymentsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsInterceptDeploymentsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsInterceptDeploymentsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsInterceptDeploymentsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/CreateProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/DeleteProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/GetProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/ListProjectsLocationsInterceptDeployments", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/PatchProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerServer registers the http handlers for service ProjectsLocationsInterceptEndpointGroupAssociationsServer to "mux".
// UnaryRPC     :call ProjectsLocationsInterceptEndpointGroupAssociationsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsInterceptEndpointGroupAssociationsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/CreateProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/DeleteProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/GetProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/ListProjectsLocationsInterceptEndpointGroupAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/PatchProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsInterceptEndpointGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsInterceptEndpointGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsInterceptEndpointGroupsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/CreateProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/DeleteProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/GetProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/ListProjectsLocationsInterceptEndpointGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/PatchProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsMirroringDeploymentGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsMirroringDeploymentGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsMirroringDeploymentGroupsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/CreateProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/DeleteProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/GetProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/ListProjectsLocationsMirroringDeploymentGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/PatchProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsMirroringDeploymentsServerHandlerServer registers the http handlers for service ProjectsLocationsMirroringDeploymentsServer to "mux".
// UnaryRPC     :call ProjectsLocationsMirroringDeploymentsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsMirroringDeploymentsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsMirroringDeploymentsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsMirroringDeploymentsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/CreateProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/DeleteProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/GetProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/ListProjectsLocationsMirroringDeployments", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/PatchProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerServer registers the http handlers for service ProjectsLocationsMirroringEndpointGroupAssociationsServer to "mux".
// UnaryRPC     :call ProjectsLocationsMirroringEndpointGroupAssociationsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsMirroringEndpointGroupAssociationsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/CreateProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/DeleteProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/GetProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/ListProjectsLocationsMirroringEndpointGroupAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/PatchProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsMirroringEndpointGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsMirroringEndpointGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsMirroringEndpointGroupsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/CreateProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/DeleteProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/GetProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/ListProjectsLocationsMirroringEndpointGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/PatchProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServerTlsPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsServerTlsPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsServerTlsPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServerTlsPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServerTlsPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServerTlsPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/CreateProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serverTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/DeleteProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/GetProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/ListProjectsLocationsServerTlsPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serverTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/PatchProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsTlsInspectionPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsTlsInspectionPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsTlsInspectionPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/CreateProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/tlsInspectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/DeleteProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/GetProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/ListProjectsLocationsTlsInspectionPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/tlsInspectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/PatchProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsUrlListsServerHandlerServer registers the http handlers for service ProjectsLocationsUrlListsServer to "mux".
// UnaryRPC     :call ProjectsLocationsUrlListsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsUrlListsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsUrlListsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsUrlListsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/CreateProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/urlLists"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/DeleteProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/GetProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/ListProjectsLocationsUrlLists", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/urlLists"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/PatchProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterOrganizationsLocationsAddressGroupsServerHandlerFromEndpoint is same as RegisterOrganizationsLocationsAddressGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrganizationsLocationsAddressGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterOrganizationsLocationsAddressGroupsServerHandler(ctx, mux, conn)
}

// RegisterOrganizationsLocationsAddressGroupsServerHandler registers the http handlers for service OrganizationsLocationsAddressGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrganizationsLocationsAddressGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterOrganizationsLocationsAddressGroupsServerHandlerClient(ctx, mux, NewOrganizationsLocationsAddressGroupsServerClient(conn))
}

// RegisterOrganizationsLocationsAddressGroupsServerHandlerClient registers the http handlers for service OrganizationsLocationsAddressGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrganizationsLocationsAddressGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrganizationsLocationsAddressGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrganizationsLocationsAddressGroupsServerClient" to call the correct interceptors.
func RegisterOrganizationsLocationsAddressGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrganizationsLocationsAddressGroupsServerClient) error {

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/AddItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:addItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/CloneItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:cloneItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/CreateOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/DeleteOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/GetOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/ListOrganizationsLocationsAddressGroups", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/ListReferencesOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:listReferences"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/PatchOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsAddressGroupsServer/RemoveItemsOrganizationsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:removeItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "addItems"))

	pattern_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "cloneItems"))

	pattern_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "addressGroups"}, ""))

	pattern_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "addressGroups", "name"}, ""))

	pattern_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "addressGroups", "name"}, ""))

	pattern_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "addressGroups"}, ""))

	pattern_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "listReferences"))

	pattern_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "addressGroups", "name"}, ""))

	pattern_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "removeItems"))
)

var (
	forward_OrganizationsLocationsAddressGroupsServer_AddItemsOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_CloneItemsOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_CreateOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_DeleteOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_GetOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_ListOrganizationsLocationsAddressGroups_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_ListReferencesOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_PatchOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsAddressGroupsServer_RemoveItemsOrganizationsLocationsAddressGroup_0 = runtime.ForwardResponseMessage
)

// RegisterOrganizationsLocationsFirewallEndpointsServerHandlerFromEndpoint is same as RegisterOrganizationsLocationsFirewallEndpointsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrganizationsLocationsFirewallEndpointsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterOrganizationsLocationsFirewallEndpointsServerHandler(ctx, mux, conn)
}

// RegisterOrganizationsLocationsFirewallEndpointsServerHandler registers the http handlers for service OrganizationsLocationsFirewallEndpointsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrganizationsLocationsFirewallEndpointsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterOrganizationsLocationsFirewallEndpointsServerHandlerClient(ctx, mux, NewOrganizationsLocationsFirewallEndpointsServerClient(conn))
}

// RegisterOrganizationsLocationsFirewallEndpointsServerHandlerClient registers the http handlers for service OrganizationsLocationsFirewallEndpointsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrganizationsLocationsFirewallEndpointsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrganizationsLocationsFirewallEndpointsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrganizationsLocationsFirewallEndpointsServerClient" to call the correct interceptors.
func RegisterOrganizationsLocationsFirewallEndpointsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrganizationsLocationsFirewallEndpointsServerClient) error {

	mux.Handle("POST", pattern_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/CreateOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/firewallEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/DeleteOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/GetOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/ListOrganizationsLocationsFirewallEndpoints", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/firewallEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsFirewallEndpointsServer/PatchOrganizationsLocationsFirewallEndpoint", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/firewallEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "firewallEndpoints"}, ""))

	pattern_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "firewallEndpoints", "name"}, ""))

	pattern_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "firewallEndpoints", "name"}, ""))

	pattern_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "firewallEndpoints"}, ""))

	pattern_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "firewallEndpoints", "name"}, ""))
)

var (
	forward_OrganizationsLocationsFirewallEndpointsServer_CreateOrganizationsLocationsFirewallEndpoint_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsFirewallEndpointsServer_DeleteOrganizationsLocationsFirewallEndpoint_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsFirewallEndpointsServer_GetOrganizationsLocationsFirewallEndpoint_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsFirewallEndpointsServer_ListOrganizationsLocationsFirewallEndpoints_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsFirewallEndpointsServer_PatchOrganizationsLocationsFirewallEndpoint_0 = runtime.ForwardResponseMessage
)

// RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerFromEndpoint is same as RegisterOrganizationsLocationsSecurityProfileGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterOrganizationsLocationsSecurityProfileGroupsServerHandler(ctx, mux, conn)
}

// RegisterOrganizationsLocationsSecurityProfileGroupsServerHandler registers the http handlers for service OrganizationsLocationsSecurityProfileGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrganizationsLocationsSecurityProfileGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerClient(ctx, mux, NewOrganizationsLocationsSecurityProfileGroupsServerClient(conn))
}

// RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerClient registers the http handlers for service OrganizationsLocationsSecurityProfileGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrganizationsLocationsSecurityProfileGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrganizationsLocationsSecurityProfileGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrganizationsLocationsSecurityProfileGroupsServerClient" to call the correct interceptors.
func RegisterOrganizationsLocationsSecurityProfileGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrganizationsLocationsSecurityProfileGroupsServerClient) error {

	mux.Handle("POST", pattern_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/CreateOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfileGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/DeleteOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/GetOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/ListOrganizationsLocationsSecurityProfileGroups", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfileGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfileGroupsServer/PatchOrganizationsLocationsSecurityProfileGroup", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfileGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "securityProfileGroups"}, ""))

	pattern_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfileGroups", "name"}, ""))

	pattern_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfileGroups", "name"}, ""))

	pattern_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "securityProfileGroups"}, ""))

	pattern_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfileGroups", "name"}, ""))
)

var (
	forward_OrganizationsLocationsSecurityProfileGroupsServer_CreateOrganizationsLocationsSecurityProfileGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfileGroupsServer_DeleteOrganizationsLocationsSecurityProfileGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfileGroupsServer_GetOrganizationsLocationsSecurityProfileGroup_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfileGroupsServer_ListOrganizationsLocationsSecurityProfileGroups_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfileGroupsServer_PatchOrganizationsLocationsSecurityProfileGroup_0 = runtime.ForwardResponseMessage
)

// RegisterOrganizationsLocationsSecurityProfilesServerHandlerFromEndpoint is same as RegisterOrganizationsLocationsSecurityProfilesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterOrganizationsLocationsSecurityProfilesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterOrganizationsLocationsSecurityProfilesServerHandler(ctx, mux, conn)
}

// RegisterOrganizationsLocationsSecurityProfilesServerHandler registers the http handlers for service OrganizationsLocationsSecurityProfilesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterOrganizationsLocationsSecurityProfilesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterOrganizationsLocationsSecurityProfilesServerHandlerClient(ctx, mux, NewOrganizationsLocationsSecurityProfilesServerClient(conn))
}

// RegisterOrganizationsLocationsSecurityProfilesServerHandlerClient registers the http handlers for service OrganizationsLocationsSecurityProfilesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "OrganizationsLocationsSecurityProfilesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "OrganizationsLocationsSecurityProfilesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "OrganizationsLocationsSecurityProfilesServerClient" to call the correct interceptors.
func RegisterOrganizationsLocationsSecurityProfilesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client OrganizationsLocationsSecurityProfilesServerClient) error {

	mux.Handle("POST", pattern_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/CreateOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfiles"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/DeleteOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/GetOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/ListOrganizationsLocationsSecurityProfiles", runtime.WithHTTPPathPattern("/v1/{parent=organizations/*/locations/*}/securityProfiles"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.OrganizationsLocationsSecurityProfilesServer/PatchOrganizationsLocationsSecurityProfile", runtime.WithHTTPPathPattern("/v1/{name=organizations/*/locations/*/securityProfiles/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "securityProfiles"}, ""))

	pattern_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfiles", "name"}, ""))

	pattern_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfiles", "name"}, ""))

	pattern_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "organizations", "locations", "parent", "securityProfiles"}, ""))

	pattern_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "organizations", "locations", "securityProfiles", "name"}, ""))
)

var (
	forward_OrganizationsLocationsSecurityProfilesServer_CreateOrganizationsLocationsSecurityProfile_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfilesServer_DeleteOrganizationsLocationsSecurityProfile_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfilesServer_GetOrganizationsLocationsSecurityProfile_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfilesServer_ListOrganizationsLocationsSecurityProfiles_0 = runtime.ForwardResponseMessage

	forward_OrganizationsLocationsSecurityProfilesServer_PatchOrganizationsLocationsSecurityProfile_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServerHandlerFromEndpoint is same as RegisterProjectsLocationsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServerHandler registers the http handlers for service ProjectsLocationsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServerHandlerClient(ctx, mux, NewProjectsLocationsServerClient(conn))
}

// RegisterProjectsLocationsServerHandlerClient registers the http handlers for service ProjectsLocationsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServerClient) error {

	mux.Handle("GET", pattern_ProjectsLocationsServer_GetProjectsLocation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServer/GetProjectsLocation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServer_ListProjectsLocations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServer/ListProjectsLocations", runtime.WithHTTPPathPattern("/v1/{name=projects/*}/locations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServer_GetProjectsLocation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3}, []string{"v1", "projects", "locations", "name"}, ""))

	pattern_ProjectsLocationsServer_ListProjectsLocations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 2, 5, 2, 2, 3}, []string{"v1", "projects", "name", "locations"}, ""))
)

var (
	forward_ProjectsLocationsServer_GetProjectsLocation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServer_ListProjectsLocations_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsAddressGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsAddressGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsAddressGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsAddressGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsAddressGroupsServerHandler registers the http handlers for service ProjectsLocationsAddressGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsAddressGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsAddressGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsAddressGroupsServerClient(conn))
}

// RegisterProjectsLocationsAddressGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsAddressGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsAddressGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsAddressGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsAddressGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsAddressGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsAddressGroupsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/AddItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:addItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/CloneItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:cloneItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/CreateProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/DeleteProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/GetProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/ListProjectsLocationsAddressGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/addressGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/ListReferencesProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:listReferences"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/PatchProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/addressGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAddressGroupsServer/RemoveItemsProjectsLocationsAddressGroup", runtime.WithHTTPPathPattern("/v1/{address_group=*}:removeItems"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "addItems"))

	pattern_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "cloneItems"))

	pattern_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "addressGroups"}, ""))

	pattern_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "addressGroups", "name"}, ""))

	pattern_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "addressGroups", "name"}, ""))

	pattern_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "addressGroups"}, ""))

	pattern_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "listReferences"))

	pattern_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "addressGroups", "name"}, ""))

	pattern_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1}, []string{"v1", "address_group"}, "removeItems"))
)

var (
	forward_ProjectsLocationsAddressGroupsServer_AddItemsProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_CloneItemsProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_CreateProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_DeleteProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_GetProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_ListProjectsLocationsAddressGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_ListReferencesProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_PatchProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAddressGroupsServer_RemoveItemsProjectsLocationsAddressGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsAuthorizationPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsAuthorizationPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsAuthorizationPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsAuthorizationPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsAuthorizationPoliciesServerHandler registers the http handlers for service ProjectsLocationsAuthorizationPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsAuthorizationPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsAuthorizationPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsAuthorizationPoliciesServerClient(conn))
}

// RegisterProjectsLocationsAuthorizationPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsAuthorizationPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsAuthorizationPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsAuthorizationPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsAuthorizationPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsAuthorizationPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsAuthorizationPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/CreateProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authorizationPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/DeleteProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/GetProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/ListProjectsLocationsAuthorizationPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authorizationPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthorizationPoliciesServer/PatchProjectsLocationsAuthorizationPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authorizationPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "authorizationPolicies"}, ""))

	pattern_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authorizationPolicies", "name"}, ""))

	pattern_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authorizationPolicies", "name"}, ""))

	pattern_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "authorizationPolicies"}, ""))

	pattern_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authorizationPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsAuthorizationPoliciesServer_CreateProjectsLocationsAuthorizationPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthorizationPoliciesServer_DeleteProjectsLocationsAuthorizationPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthorizationPoliciesServer_GetProjectsLocationsAuthorizationPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthorizationPoliciesServer_ListProjectsLocationsAuthorizationPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthorizationPoliciesServer_PatchProjectsLocationsAuthorizationPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsAuthzPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsAuthzPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsAuthzPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsAuthzPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsAuthzPoliciesServerHandler registers the http handlers for service ProjectsLocationsAuthzPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsAuthzPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsAuthzPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsAuthzPoliciesServerClient(conn))
}

// RegisterProjectsLocationsAuthzPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsAuthzPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsAuthzPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsAuthzPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsAuthzPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsAuthzPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsAuthzPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/CreateProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authzPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/DeleteProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/GetProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/ListProjectsLocationsAuthzPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/authzPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsAuthzPoliciesServer/PatchProjectsLocationsAuthzPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/authzPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "authzPolicies"}, ""))

	pattern_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authzPolicies", "name"}, ""))

	pattern_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authzPolicies", "name"}, ""))

	pattern_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "authzPolicies"}, ""))

	pattern_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "authzPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsAuthzPoliciesServer_CreateProjectsLocationsAuthzPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthzPoliciesServer_DeleteProjectsLocationsAuthzPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthzPoliciesServer_GetProjectsLocationsAuthzPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthzPoliciesServer_ListProjectsLocationsAuthzPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsAuthzPoliciesServer_PatchProjectsLocationsAuthzPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsClientTlsPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsClientTlsPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsClientTlsPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsClientTlsPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsClientTlsPoliciesServerHandler registers the http handlers for service ProjectsLocationsClientTlsPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsClientTlsPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsClientTlsPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsClientTlsPoliciesServerClient(conn))
}

// RegisterProjectsLocationsClientTlsPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsClientTlsPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsClientTlsPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsClientTlsPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsClientTlsPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsClientTlsPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsClientTlsPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/CreateProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/clientTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/DeleteProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/GetProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/ListProjectsLocationsClientTlsPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/clientTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsClientTlsPoliciesServer/PatchProjectsLocationsClientTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/clientTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "clientTlsPolicies"}, ""))

	pattern_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "clientTlsPolicies", "name"}, ""))

	pattern_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "clientTlsPolicies", "name"}, ""))

	pattern_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "clientTlsPolicies"}, ""))

	pattern_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "clientTlsPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsClientTlsPoliciesServer_CreateProjectsLocationsClientTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsClientTlsPoliciesServer_DeleteProjectsLocationsClientTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsClientTlsPoliciesServer_GetProjectsLocationsClientTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsClientTlsPoliciesServer_ListProjectsLocationsClientTlsPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsClientTlsPoliciesServer_PatchProjectsLocationsClientTlsPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerFromEndpoint is same as RegisterProjectsLocationsFirewallEndpointAssociationsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsFirewallEndpointAssociationsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsFirewallEndpointAssociationsServerHandler registers the http handlers for service ProjectsLocationsFirewallEndpointAssociationsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsFirewallEndpointAssociationsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerClient(ctx, mux, NewProjectsLocationsFirewallEndpointAssociationsServerClient(conn))
}

// RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerClient registers the http handlers for service ProjectsLocationsFirewallEndpointAssociationsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsFirewallEndpointAssociationsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsFirewallEndpointAssociationsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsFirewallEndpointAssociationsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsFirewallEndpointAssociationsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsFirewallEndpointAssociationsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/CreateProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/firewallEndpointAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/DeleteProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/GetProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/ListProjectsLocationsFirewallEndpointAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/firewallEndpointAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsFirewallEndpointAssociationsServer/PatchProjectsLocationsFirewallEndpointAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/firewallEndpointAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "firewallEndpointAssociations"}, ""))

	pattern_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "firewallEndpointAssociations", "name"}, ""))

	pattern_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "firewallEndpointAssociations", "name"}, ""))

	pattern_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "firewallEndpointAssociations"}, ""))

	pattern_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "firewallEndpointAssociations", "name"}, ""))
)

var (
	forward_ProjectsLocationsFirewallEndpointAssociationsServer_CreateProjectsLocationsFirewallEndpointAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsFirewallEndpointAssociationsServer_DeleteProjectsLocationsFirewallEndpointAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsFirewallEndpointAssociationsServer_GetProjectsLocationsFirewallEndpointAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsFirewallEndpointAssociationsServer_ListProjectsLocationsFirewallEndpointAssociations_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsFirewallEndpointAssociationsServer_PatchProjectsLocationsFirewallEndpointAssociation_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsGatewaySecurityPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGatewaySecurityPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGatewaySecurityPoliciesServerHandler registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGatewaySecurityPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsGatewaySecurityPoliciesServerClient(conn))
}

// RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGatewaySecurityPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGatewaySecurityPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGatewaySecurityPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGatewaySecurityPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGatewaySecurityPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/CreateProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/gatewaySecurityPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/DeleteProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/GetProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/ListProjectsLocationsGatewaySecurityPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/gatewaySecurityPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesServer/PatchProjectsLocationsGatewaySecurityPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "gatewaySecurityPolicies"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "name"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "name"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "gatewaySecurityPolicies"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsGatewaySecurityPoliciesServer_CreateProjectsLocationsGatewaySecurityPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesServer_DeleteProjectsLocationsGatewaySecurityPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesServer_GetProjectsLocationsGatewaySecurityPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesServer_ListProjectsLocationsGatewaySecurityPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesServer_PatchProjectsLocationsGatewaySecurityPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerFromEndpoint is same as RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandler registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesRulesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerClient(ctx, mux, NewProjectsLocationsGatewaySecurityPoliciesRulesServerClient(conn))
}

// RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerClient registers the http handlers for service ProjectsLocationsGatewaySecurityPoliciesRulesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGatewaySecurityPoliciesRulesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGatewaySecurityPoliciesRulesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGatewaySecurityPoliciesRulesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGatewaySecurityPoliciesRulesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGatewaySecurityPoliciesRulesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/CreateProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*/gatewaySecurityPolicies/*}/rules"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/DeleteProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/GetProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/ListProjectsLocationsGatewaySecurityPoliciesRules", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*/gatewaySecurityPolicies/*}/rules"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsGatewaySecurityPoliciesRulesServer/PatchProjectsLocationsGatewaySecurityPoliciesRule", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/gatewaySecurityPolicies/*/rules/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "parent", "rules"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 2, 4, 1, 0, 4, 8, 5, 5}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "rules", "name"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 2, 4, 1, 0, 4, 8, 5, 5}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "rules", "name"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "parent", "rules"}, ""))

	pattern_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 2, 4, 1, 0, 4, 8, 5, 5}, []string{"v1", "projects", "locations", "gatewaySecurityPolicies", "rules", "name"}, ""))
)

var (
	forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_CreateProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_DeleteProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_GetProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_ListProjectsLocationsGatewaySecurityPoliciesRules_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGatewaySecurityPoliciesRulesServer_PatchProjectsLocationsGatewaySecurityPoliciesRule_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsInterceptDeploymentGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsInterceptDeploymentGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsInterceptDeploymentGroupsServerHandler registers the http handlers for service ProjectsLocationsInterceptDeploymentGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsInterceptDeploymentGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsInterceptDeploymentGroupsServerClient(conn))
}

// RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsInterceptDeploymentGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsInterceptDeploymentGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsInterceptDeploymentGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsInterceptDeploymentGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsInterceptDeploymentGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsInterceptDeploymentGroupsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/CreateProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/DeleteProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/GetProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/ListProjectsLocationsInterceptDeploymentGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentGroupsServer/PatchProjectsLocationsInterceptDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptDeploymentGroups"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeploymentGroups", "name"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeploymentGroups", "name"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptDeploymentGroups"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeploymentGroups", "name"}, ""))
)

var (
	forward_ProjectsLocationsInterceptDeploymentGroupsServer_CreateProjectsLocationsInterceptDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentGroupsServer_DeleteProjectsLocationsInterceptDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentGroupsServer_GetProjectsLocationsInterceptDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentGroupsServer_ListProjectsLocationsInterceptDeploymentGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentGroupsServer_PatchProjectsLocationsInterceptDeploymentGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsInterceptDeploymentsServerHandlerFromEndpoint is same as RegisterProjectsLocationsInterceptDeploymentsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsInterceptDeploymentsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsInterceptDeploymentsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsInterceptDeploymentsServerHandler registers the http handlers for service ProjectsLocationsInterceptDeploymentsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsInterceptDeploymentsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsInterceptDeploymentsServerHandlerClient(ctx, mux, NewProjectsLocationsInterceptDeploymentsServerClient(conn))
}

// RegisterProjectsLocationsInterceptDeploymentsServerHandlerClient registers the http handlers for service ProjectsLocationsInterceptDeploymentsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsInterceptDeploymentsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsInterceptDeploymentsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsInterceptDeploymentsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsInterceptDeploymentsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsInterceptDeploymentsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/CreateProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/DeleteProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/GetProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/ListProjectsLocationsInterceptDeployments", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptDeploymentsServer/PatchProjectsLocationsInterceptDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptDeployments"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeployments", "name"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeployments", "name"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptDeployments"}, ""))

	pattern_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptDeployments", "name"}, ""))
)

var (
	forward_ProjectsLocationsInterceptDeploymentsServer_CreateProjectsLocationsInterceptDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentsServer_DeleteProjectsLocationsInterceptDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentsServer_GetProjectsLocationsInterceptDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentsServer_ListProjectsLocationsInterceptDeployments_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptDeploymentsServer_PatchProjectsLocationsInterceptDeployment_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerFromEndpoint is same as RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandler registers the http handlers for service ProjectsLocationsInterceptEndpointGroupAssociationsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerClient(ctx, mux, NewProjectsLocationsInterceptEndpointGroupAssociationsServerClient(conn))
}

// RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerClient registers the http handlers for service ProjectsLocationsInterceptEndpointGroupAssociationsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsInterceptEndpointGroupAssociationsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsInterceptEndpointGroupAssociationsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsInterceptEndpointGroupAssociationsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsInterceptEndpointGroupAssociationsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsInterceptEndpointGroupAssociationsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/CreateProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/DeleteProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/GetProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/ListProjectsLocationsInterceptEndpointGroupAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupAssociationsServer/PatchProjectsLocationsInterceptEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptEndpointGroupAssociations"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroupAssociations", "name"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroupAssociations", "name"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptEndpointGroupAssociations"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroupAssociations", "name"}, ""))
)

var (
	forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_CreateProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_DeleteProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_GetProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_ListProjectsLocationsInterceptEndpointGroupAssociations_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupAssociationsServer_PatchProjectsLocationsInterceptEndpointGroupAssociation_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsInterceptEndpointGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsInterceptEndpointGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsInterceptEndpointGroupsServerHandler registers the http handlers for service ProjectsLocationsInterceptEndpointGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsInterceptEndpointGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsInterceptEndpointGroupsServerClient(conn))
}

// RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsInterceptEndpointGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsInterceptEndpointGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsInterceptEndpointGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsInterceptEndpointGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsInterceptEndpointGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsInterceptEndpointGroupsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/CreateProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/DeleteProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/GetProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/ListProjectsLocationsInterceptEndpointGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/interceptEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsInterceptEndpointGroupsServer/PatchProjectsLocationsInterceptEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/interceptEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptEndpointGroups"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroups", "name"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroups", "name"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "interceptEndpointGroups"}, ""))

	pattern_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "interceptEndpointGroups", "name"}, ""))
)

var (
	forward_ProjectsLocationsInterceptEndpointGroupsServer_CreateProjectsLocationsInterceptEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupsServer_DeleteProjectsLocationsInterceptEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupsServer_GetProjectsLocationsInterceptEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupsServer_ListProjectsLocationsInterceptEndpointGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInterceptEndpointGroupsServer_PatchProjectsLocationsInterceptEndpointGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsMirroringDeploymentGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsMirroringDeploymentGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsMirroringDeploymentGroupsServerHandler registers the http handlers for service ProjectsLocationsMirroringDeploymentGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsMirroringDeploymentGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsMirroringDeploymentGroupsServerClient(conn))
}

// RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsMirroringDeploymentGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsMirroringDeploymentGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsMirroringDeploymentGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsMirroringDeploymentGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsMirroringDeploymentGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsMirroringDeploymentGroupsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/CreateProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/DeleteProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/GetProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/ListProjectsLocationsMirroringDeploymentGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeploymentGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentGroupsServer/PatchProjectsLocationsMirroringDeploymentGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeploymentGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringDeploymentGroups"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeploymentGroups", "name"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeploymentGroups", "name"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringDeploymentGroups"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeploymentGroups", "name"}, ""))
)

var (
	forward_ProjectsLocationsMirroringDeploymentGroupsServer_CreateProjectsLocationsMirroringDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentGroupsServer_DeleteProjectsLocationsMirroringDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentGroupsServer_GetProjectsLocationsMirroringDeploymentGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentGroupsServer_ListProjectsLocationsMirroringDeploymentGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentGroupsServer_PatchProjectsLocationsMirroringDeploymentGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsMirroringDeploymentsServerHandlerFromEndpoint is same as RegisterProjectsLocationsMirroringDeploymentsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsMirroringDeploymentsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsMirroringDeploymentsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsMirroringDeploymentsServerHandler registers the http handlers for service ProjectsLocationsMirroringDeploymentsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsMirroringDeploymentsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsMirroringDeploymentsServerHandlerClient(ctx, mux, NewProjectsLocationsMirroringDeploymentsServerClient(conn))
}

// RegisterProjectsLocationsMirroringDeploymentsServerHandlerClient registers the http handlers for service ProjectsLocationsMirroringDeploymentsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsMirroringDeploymentsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsMirroringDeploymentsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsMirroringDeploymentsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsMirroringDeploymentsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsMirroringDeploymentsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/CreateProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/DeleteProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/GetProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/ListProjectsLocationsMirroringDeployments", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringDeployments"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringDeploymentsServer/PatchProjectsLocationsMirroringDeployment", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringDeployments/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringDeployments"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeployments", "name"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeployments", "name"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringDeployments"}, ""))

	pattern_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringDeployments", "name"}, ""))
)

var (
	forward_ProjectsLocationsMirroringDeploymentsServer_CreateProjectsLocationsMirroringDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentsServer_DeleteProjectsLocationsMirroringDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentsServer_GetProjectsLocationsMirroringDeployment_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentsServer_ListProjectsLocationsMirroringDeployments_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringDeploymentsServer_PatchProjectsLocationsMirroringDeployment_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerFromEndpoint is same as RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandler registers the http handlers for service ProjectsLocationsMirroringEndpointGroupAssociationsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerClient(ctx, mux, NewProjectsLocationsMirroringEndpointGroupAssociationsServerClient(conn))
}

// RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerClient registers the http handlers for service ProjectsLocationsMirroringEndpointGroupAssociationsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsMirroringEndpointGroupAssociationsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsMirroringEndpointGroupAssociationsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsMirroringEndpointGroupAssociationsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsMirroringEndpointGroupAssociationsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsMirroringEndpointGroupAssociationsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/CreateProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/DeleteProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/GetProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/ListProjectsLocationsMirroringEndpointGroupAssociations", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroupAssociations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupAssociationsServer/PatchProjectsLocationsMirroringEndpointGroupAssociation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroupAssociations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringEndpointGroupAssociations"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroupAssociations", "name"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroupAssociations", "name"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringEndpointGroupAssociations"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroupAssociations", "name"}, ""))
)

var (
	forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_CreateProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_DeleteProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_GetProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_ListProjectsLocationsMirroringEndpointGroupAssociations_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupAssociationsServer_PatchProjectsLocationsMirroringEndpointGroupAssociation_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsMirroringEndpointGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsMirroringEndpointGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsMirroringEndpointGroupsServerHandler registers the http handlers for service ProjectsLocationsMirroringEndpointGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsMirroringEndpointGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsMirroringEndpointGroupsServerClient(conn))
}

// RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsMirroringEndpointGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsMirroringEndpointGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsMirroringEndpointGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsMirroringEndpointGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsMirroringEndpointGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsMirroringEndpointGroupsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/CreateProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/DeleteProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/GetProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/ListProjectsLocationsMirroringEndpointGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/mirroringEndpointGroups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsMirroringEndpointGroupsServer/PatchProjectsLocationsMirroringEndpointGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/mirroringEndpointGroups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringEndpointGroups"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroups", "name"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroups", "name"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "mirroringEndpointGroups"}, ""))

	pattern_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "mirroringEndpointGroups", "name"}, ""))
)

var (
	forward_ProjectsLocationsMirroringEndpointGroupsServer_CreateProjectsLocationsMirroringEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupsServer_DeleteProjectsLocationsMirroringEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupsServer_GetProjectsLocationsMirroringEndpointGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupsServer_ListProjectsLocationsMirroringEndpointGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsMirroringEndpointGroupsServer_PatchProjectsLocationsMirroringEndpointGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServerTlsPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsServerTlsPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServerTlsPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServerTlsPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServerTlsPoliciesServerHandler registers the http handlers for service ProjectsLocationsServerTlsPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServerTlsPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServerTlsPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsServerTlsPoliciesServerClient(conn))
}

// RegisterProjectsLocationsServerTlsPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsServerTlsPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServerTlsPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServerTlsPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServerTlsPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServerTlsPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServerTlsPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/CreateProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serverTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/DeleteProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/GetProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/ListProjectsLocationsServerTlsPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serverTlsPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsServerTlsPoliciesServer/PatchProjectsLocationsServerTlsPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serverTlsPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serverTlsPolicies"}, ""))

	pattern_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serverTlsPolicies", "name"}, ""))

	pattern_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serverTlsPolicies", "name"}, ""))

	pattern_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serverTlsPolicies"}, ""))

	pattern_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serverTlsPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsServerTlsPoliciesServer_CreateProjectsLocationsServerTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServerTlsPoliciesServer_DeleteProjectsLocationsServerTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServerTlsPoliciesServer_GetProjectsLocationsServerTlsPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServerTlsPoliciesServer_ListProjectsLocationsServerTlsPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServerTlsPoliciesServer_PatchProjectsLocationsServerTlsPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsTlsInspectionPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsTlsInspectionPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsTlsInspectionPoliciesServerHandler registers the http handlers for service ProjectsLocationsTlsInspectionPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsTlsInspectionPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsTlsInspectionPoliciesServerClient(conn))
}

// RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsTlsInspectionPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsTlsInspectionPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsTlsInspectionPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsTlsInspectionPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsTlsInspectionPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsTlsInspectionPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/CreateProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/tlsInspectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/DeleteProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/GetProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/ListProjectsLocationsTlsInspectionPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/tlsInspectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsTlsInspectionPoliciesServer/PatchProjectsLocationsTlsInspectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/tlsInspectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "tlsInspectionPolicies"}, ""))

	pattern_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "tlsInspectionPolicies", "name"}, ""))

	pattern_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "tlsInspectionPolicies", "name"}, ""))

	pattern_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "tlsInspectionPolicies"}, ""))

	pattern_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "tlsInspectionPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsTlsInspectionPoliciesServer_CreateProjectsLocationsTlsInspectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsTlsInspectionPoliciesServer_DeleteProjectsLocationsTlsInspectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsTlsInspectionPoliciesServer_GetProjectsLocationsTlsInspectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsTlsInspectionPoliciesServer_ListProjectsLocationsTlsInspectionPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsTlsInspectionPoliciesServer_PatchProjectsLocationsTlsInspectionPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsUrlListsServerHandlerFromEndpoint is same as RegisterProjectsLocationsUrlListsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsUrlListsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsUrlListsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsUrlListsServerHandler registers the http handlers for service ProjectsLocationsUrlListsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsUrlListsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsUrlListsServerHandlerClient(ctx, mux, NewProjectsLocationsUrlListsServerClient(conn))
}

// RegisterProjectsLocationsUrlListsServerHandlerClient registers the http handlers for service ProjectsLocationsUrlListsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsUrlListsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsUrlListsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsUrlListsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsUrlListsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsUrlListsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/CreateProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/urlLists"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/DeleteProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/GetProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/ListProjectsLocationsUrlLists", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/urlLists"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/google.cloud.networksecurity.v1.ProjectsLocationsUrlListsServer/PatchProjectsLocationsUrlList", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/urlLists/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "urlLists"}, ""))

	pattern_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "urlLists", "name"}, ""))

	pattern_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "urlLists", "name"}, ""))

	pattern_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "urlLists"}, ""))

	pattern_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "urlLists", "name"}, ""))
)

var (
	forward_ProjectsLocationsUrlListsServer_CreateProjectsLocationsUrlList_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsUrlListsServer_DeleteProjectsLocationsUrlList_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsUrlListsServer_GetProjectsLocationsUrlList_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsUrlListsServer_ListProjectsLocationsUrlLists_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsUrlListsServer_PatchProjectsLocationsUrlList_0 = runtime.ForwardResponseMessage
)
