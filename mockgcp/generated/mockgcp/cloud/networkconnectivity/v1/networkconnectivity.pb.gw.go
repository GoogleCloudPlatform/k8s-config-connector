// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: mockgcp/cloud/networkconnectivity/v1/networkconnectivity.proto

/*
Package networkconnectivitypb is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package networkconnectivitypb

import (
	"context"
	"io"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_ProjectsLocationsServer_GetProjectsLocation_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocation(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServer_GetProjectsLocation_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocation(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServer_ListProjectsLocations_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServer_ListProjectsLocations_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServer_ListProjectsLocations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocations(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServer_ListProjectsLocations_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServer_ListProjectsLocations_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocations(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AcceptSpokeProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.AcceptSpokeProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AcceptSpokeProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.AcceptSpokeProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AcceptSpokeUpdateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.AcceptSpokeUpdateProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq AcceptSpokeUpdateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.AcceptSpokeUpdateProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_global_hub": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGlobalHubs(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGlobalHubs(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListSpokesProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListSpokesProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListSpokesProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListSpokesProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_global_hub": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq QueryStatusProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.QueryStatusProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq QueryStatusProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.QueryStatusProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RejectSpokeProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.RejectSpokeProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RejectSpokeProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.RejectSpokeProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RejectSpokeUpdateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.RejectSpokeUpdateProjectsLocationsGlobalHub(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq RejectSpokeUpdateProjectsLocationsGlobalHubRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHub); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.RejectSpokeUpdateProjectsLocationsGlobalHub(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGlobalHubsGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsGroupRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGlobalHubsGroup(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGlobalHubsGroups(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsGroupsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGlobalHubsGroups(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_global_hubs_group": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsGroupsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGlobalHubsGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHubsGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsGlobalHubsGroup(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsGroupsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsGlobalHubsGroupRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalHubsGroup); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsGlobalHubsGroup(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsRouteTablesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsRouteTableRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGlobalHubsRouteTable(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsRouteTablesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsRouteTableRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGlobalHubsRouteTable(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsRouteTablesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRouteTablesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGlobalHubsRouteTables(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsRouteTablesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRouteTablesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGlobalHubsRouteTables(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsRouteTablesRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGlobalHubsRouteTablesRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsRouteTablesRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalHubsRouteTablesRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGlobalHubsRouteTablesRoute(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRouteTablesRoutesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGlobalHubsRouteTablesRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalHubsRouteTablesRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalHubsRouteTablesRoutesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGlobalHubsRouteTablesRoutes(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_global_policy_based_route": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalPolicyBasedRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalPolicyBasedRoute); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalPolicyBasedRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsGlobalPolicyBasedRoute); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalPolicyBasedRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalPolicyBasedRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalPolicyBasedRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalPolicyBasedRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsGlobalPolicyBasedRouteRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsGlobalPolicyBasedRoute(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsGlobalPolicyBasedRoutesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalPolicyBasedRoutesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsGlobalPolicyBasedRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsGlobalPolicyBasedRoutesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsGlobalPolicyBasedRoutesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsGlobalPolicyBasedRoutes(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_internal_range": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInternalRangesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInternalRange); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsInternalRange(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInternalRangesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInternalRange); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsInternalRange(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInternalRangesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsInternalRange(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInternalRangesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsInternalRange(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInternalRangesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsInternalRange(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInternalRangesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsInternalRange(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInternalRangesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInternalRangesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsInternalRanges(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInternalRangesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsInternalRangesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsInternalRanges(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_internal_range": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsInternalRangesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInternalRange); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsInternalRange(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsInternalRangesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsInternalRangeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsInternalRange); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsInternalRange(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_regional_endpoint": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsRegionalEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsRegionalEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsRegionalEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsRegionalEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsRegionalEndpoint); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsRegionalEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsRegionalEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsRegionalEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsRegionalEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsRegionalEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsRegionalEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsRegionalEndpoint(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsRegionalEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsRegionalEndpointRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsRegionalEndpoint(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsRegionalEndpointsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRegionalEndpointsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsRegionalEndpoints(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsRegionalEndpointsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsRegionalEndpointsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsRegionalEndpoints(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceClassesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsServiceClasse(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceClassesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsServiceClasse(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceClassesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsServiceClasse(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceClassesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsServiceClasse(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceClassesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceClassesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsServiceClasses(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceClassesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceClassesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsServiceClasses(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_classe": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceClassesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceClasse); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsServiceClasse(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceClassesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceClasseRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceClasse); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsServiceClasse(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_connection_map": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionMapsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionMap); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsServiceConnectionMap(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionMapsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionMap); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsServiceConnectionMap(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionMapsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsServiceConnectionMap(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionMapsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsServiceConnectionMap(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionMapsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsServiceConnectionMap(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionMapsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsServiceConnectionMap(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionMapsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionMapsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsServiceConnectionMaps(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionMapsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionMapsRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsServiceConnectionMaps(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_connection_map": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionMapsServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionMap); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsServiceConnectionMap(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionMapsServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceConnectionMapRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionMap); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsServiceConnectionMap(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_connection_policy": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsServiceConnectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsServiceConnectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsServiceConnectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsServiceConnectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsServiceConnectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsServiceConnectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsServiceConnectionPolicies(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionPoliciesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsServiceConnectionPolicies(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_connection_policy": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionPoliciesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsServiceConnectionPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionPoliciesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsServiceConnectionPolicyRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionPolicy); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsServiceConnectionPolicy(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_service_connection_token": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionTokensServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionToken); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsServiceConnectionToken(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionTokensServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsServiceConnectionToken); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsServiceConnectionToken(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionTokensServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsServiceConnectionToken(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionTokensServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsServiceConnectionToken(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionTokensServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsServiceConnectionToken(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionTokensServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsServiceConnectionTokenRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsServiceConnectionToken(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsServiceConnectionTokensServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionTokensRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsServiceConnectionTokens(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsServiceConnectionTokensServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsServiceConnectionTokensRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsServiceConnectionTokens(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_spoke": 0, "parent": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsSpokesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsSpoke); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.CreateProjectsLocationsSpoke(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsSpokesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq CreateProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsSpoke); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.CreateProjectsLocationsSpoke(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0 = &utilities.DoubleArray{Encoding: map[string]int{"name": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsSpokesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.DeleteProjectsLocationsSpoke(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsSpokesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq DeleteProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.DeleteProjectsLocationsSpoke(ctx, &protoReq)
	return msg, metadata, err

}

func request_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsSpokesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := client.GetProjectsLocationsSpoke(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsSpokesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq GetProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	msg, err := server.GetProjectsLocationsSpoke(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0 = &utilities.DoubleArray{Encoding: map[string]int{"parent": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsSpokesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsSpokesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.ListProjectsLocationsSpokes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsSpokesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq ListProjectsLocationsSpokesRequest
	var metadata runtime.ServerMetadata

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["parent"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "parent")
	}

	protoReq.Parent, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "parent", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.ListProjectsLocationsSpokes(ctx, &protoReq)
	return msg, metadata, err

}

var (
	filter_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0 = &utilities.DoubleArray{Encoding: map[string]int{"projects_locations_spoke": 0, "name": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, client ProjectsLocationsSpokesServerClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsSpoke); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := client.PatchProjectsLocationsSpoke(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func local_request_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(ctx context.Context, marshaler runtime.Marshaler, server ProjectsLocationsSpokesServerServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq PatchProjectsLocationsSpokeRequest
	var metadata runtime.ServerMetadata

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq.ProjectsLocationsSpoke); err != nil && err != io.EOF {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["name"]
	if !ok {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
	}

	protoReq.Name, err = runtime.String(val)
	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	msg, err := server.PatchProjectsLocationsSpoke(ctx, &protoReq)
	return msg, metadata, err

}

// RegisterProjectsLocationsServerHandlerServer registers the http handlers for service ProjectsLocationsServer to "mux".
// UnaryRPC     :call ProjectsLocationsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServerServer) error {

	mux.Handle("GET", pattern_ProjectsLocationsServer_GetProjectsLocation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServer/GetProjectsLocation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServer_ListProjectsLocations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServer/ListProjectsLocations", runtime.WithHTTPPathPattern("/v1/{name=projects/*}/locations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGlobalHubsServerHandlerServer registers the http handlers for service ProjectsLocationsGlobalHubsServer to "mux".
// UnaryRPC     :call ProjectsLocationsGlobalHubsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGlobalHubsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGlobalHubsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGlobalHubsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/AcceptSpokeProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:acceptSpoke"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/AcceptSpokeUpdateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:acceptSpokeUpdate"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/CreateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/hubs"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/DeleteProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/GetProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/ListProjectsLocationsGlobalHubs", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/hubs"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/ListSpokesProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:listSpokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/PatchProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/QueryStatusProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:queryStatus"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/RejectSpokeProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:rejectSpoke"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/RejectSpokeUpdateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:rejectSpokeUpdate"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGlobalHubsGroupsServerHandlerServer registers the http handlers for service ProjectsLocationsGlobalHubsGroupsServer to "mux".
// UnaryRPC     :call ProjectsLocationsGlobalHubsGroupsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGlobalHubsGroupsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGlobalHubsGroupsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGlobalHubsGroupsServerServer) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/GetProjectsLocationsGlobalHubsGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/groups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/ListProjectsLocationsGlobalHubsGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*}/groups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/PatchProjectsLocationsGlobalHubsGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/groups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerServer registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesServer to "mux".
// UnaryRPC     :call ProjectsLocationsGlobalHubsRouteTablesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGlobalHubsRouteTablesServerServer) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesServer/GetProjectsLocationsGlobalHubsRouteTable", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/routeTables/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesServer/ListProjectsLocationsGlobalHubsRouteTables", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*}/routeTables"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerServer registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesRoutesServer to "mux".
// UnaryRPC     :call ProjectsLocationsGlobalHubsRouteTablesRoutesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGlobalHubsRouteTablesRoutesServerServer) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesRoutesServer/GetProjectsLocationsGlobalHubsRouteTablesRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/routeTables/*/routes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesRoutesServer/ListProjectsLocationsGlobalHubsRouteTablesRoutes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*/routeTables/*}/routes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerServer registers the http handlers for service ProjectsLocationsGlobalPolicyBasedRoutesServer to "mux".
// UnaryRPC     :call ProjectsLocationsGlobalPolicyBasedRoutesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsGlobalPolicyBasedRoutesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/CreateProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/policyBasedRoutes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/DeleteProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/policyBasedRoutes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/GetProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/policyBasedRoutes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/ListProjectsLocationsGlobalPolicyBasedRoutes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/policyBasedRoutes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsInternalRangesServerHandlerServer registers the http handlers for service ProjectsLocationsInternalRangesServer to "mux".
// UnaryRPC     :call ProjectsLocationsInternalRangesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsInternalRangesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsInternalRangesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsInternalRangesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/CreateProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/internalRanges"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/DeleteProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/GetProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/ListProjectsLocationsInternalRanges", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/internalRanges"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/PatchProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsRegionalEndpointsServerHandlerServer registers the http handlers for service ProjectsLocationsRegionalEndpointsServer to "mux".
// UnaryRPC     :call ProjectsLocationsRegionalEndpointsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsRegionalEndpointsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsRegionalEndpointsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsRegionalEndpointsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/CreateProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/regionalEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/DeleteProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/regionalEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/GetProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/regionalEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/ListProjectsLocationsRegionalEndpoints", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/regionalEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServiceClassesServerHandlerServer registers the http handlers for service ProjectsLocationsServiceClassesServer to "mux".
// UnaryRPC     :call ProjectsLocationsServiceClassesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServiceClassesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServiceClassesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServiceClassesServerServer) error {

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/DeleteProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/GetProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/ListProjectsLocationsServiceClasses", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceClasses"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/PatchProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServiceConnectionMapsServerHandlerServer registers the http handlers for service ProjectsLocationsServiceConnectionMapsServer to "mux".
// UnaryRPC     :call ProjectsLocationsServiceConnectionMapsServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServiceConnectionMapsServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServiceConnectionMapsServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServiceConnectionMapsServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/CreateProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionMaps"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/DeleteProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/GetProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/ListProjectsLocationsServiceConnectionMaps", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionMaps"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/PatchProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerServer registers the http handlers for service ProjectsLocationsServiceConnectionPoliciesServer to "mux".
// UnaryRPC     :call ProjectsLocationsServiceConnectionPoliciesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServiceConnectionPoliciesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/CreateProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/DeleteProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/GetProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/ListProjectsLocationsServiceConnectionPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/PatchProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServiceConnectionTokensServerHandlerServer registers the http handlers for service ProjectsLocationsServiceConnectionTokensServer to "mux".
// UnaryRPC     :call ProjectsLocationsServiceConnectionTokensServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsServiceConnectionTokensServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsServiceConnectionTokensServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsServiceConnectionTokensServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/CreateProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionTokens"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/DeleteProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionTokens/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/GetProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionTokens/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/ListProjectsLocationsServiceConnectionTokens", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionTokens"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsSpokesServerHandlerServer registers the http handlers for service ProjectsLocationsSpokesServer to "mux".
// UnaryRPC     :call ProjectsLocationsSpokesServerServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterProjectsLocationsSpokesServerHandlerFromEndpoint instead.
func RegisterProjectsLocationsSpokesServerHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ProjectsLocationsSpokesServerServer) error {

	mux.Handle("POST", pattern_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/CreateProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/spokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/DeleteProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/GetProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/ListProjectsLocationsSpokes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/spokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var stream runtime.ServerTransportStream
		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/PatchProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := local_request_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, server, req, pathParams)
		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

// RegisterProjectsLocationsServerHandlerFromEndpoint is same as RegisterProjectsLocationsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServerHandler registers the http handlers for service ProjectsLocationsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServerHandlerClient(ctx, mux, NewProjectsLocationsServerClient(conn))
}

// RegisterProjectsLocationsServerHandlerClient registers the http handlers for service ProjectsLocationsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServerClient) error {

	mux.Handle("GET", pattern_ProjectsLocationsServer_GetProjectsLocation_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServer/GetProjectsLocation", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_GetProjectsLocation_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServer_ListProjectsLocations_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServer/ListProjectsLocations", runtime.WithHTTPPathPattern("/v1/{name=projects/*}/locations"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServer_ListProjectsLocations_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServer_GetProjectsLocation_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3}, []string{"v1", "projects", "locations", "name"}, ""))

	pattern_ProjectsLocationsServer_ListProjectsLocations_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 2, 5, 2, 2, 3}, []string{"v1", "projects", "name", "locations"}, ""))
)

var (
	forward_ProjectsLocationsServer_GetProjectsLocation_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServer_ListProjectsLocations_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGlobalHubsServerHandlerFromEndpoint is same as RegisterProjectsLocationsGlobalHubsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGlobalHubsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGlobalHubsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGlobalHubsServerHandler registers the http handlers for service ProjectsLocationsGlobalHubsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGlobalHubsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGlobalHubsServerHandlerClient(ctx, mux, NewProjectsLocationsGlobalHubsServerClient(conn))
}

// RegisterProjectsLocationsGlobalHubsServerHandlerClient registers the http handlers for service ProjectsLocationsGlobalHubsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGlobalHubsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGlobalHubsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGlobalHubsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGlobalHubsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGlobalHubsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/AcceptSpokeProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:acceptSpoke"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/AcceptSpokeUpdateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:acceptSpokeUpdate"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/CreateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/hubs"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/DeleteProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/GetProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/ListProjectsLocationsGlobalHubs", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/hubs"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/ListSpokesProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:listSpokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/PatchProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/QueryStatusProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:queryStatus"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/RejectSpokeProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:rejectSpoke"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("POST", pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsServer/RejectSpokeUpdateProjectsLocationsGlobalHub", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*}:rejectSpokeUpdate"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "acceptSpoke"))

	pattern_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "acceptSpokeUpdate"))

	pattern_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 4, 4, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "global", "parent", "hubs"}, ""))

	pattern_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 4, 4, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "global", "parent", "hubs"}, ""))

	pattern_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "listSpokes"))

	pattern_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "queryStatus"))

	pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "rejectSpoke"))

	pattern_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "hubs", "name"}, "rejectSpokeUpdate"))
)

var (
	forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_AcceptSpokeUpdateProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_CreateProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_DeleteProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_GetProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_ListProjectsLocationsGlobalHubs_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_ListSpokesProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_PatchProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_QueryStatusProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_RejectSpokeProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsServer_RejectSpokeUpdateProjectsLocationsGlobalHub_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGlobalHubsGroupsServerHandlerFromEndpoint is same as RegisterProjectsLocationsGlobalHubsGroupsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGlobalHubsGroupsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGlobalHubsGroupsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGlobalHubsGroupsServerHandler registers the http handlers for service ProjectsLocationsGlobalHubsGroupsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGlobalHubsGroupsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGlobalHubsGroupsServerHandlerClient(ctx, mux, NewProjectsLocationsGlobalHubsGroupsServerClient(conn))
}

// RegisterProjectsLocationsGlobalHubsGroupsServerHandlerClient registers the http handlers for service ProjectsLocationsGlobalHubsGroupsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGlobalHubsGroupsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGlobalHubsGroupsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGlobalHubsGroupsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGlobalHubsGroupsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGlobalHubsGroupsServerClient) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/GetProjectsLocationsGlobalHubsGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/groups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/ListProjectsLocationsGlobalHubsGroups", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*}/groups"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsGroupsServer/PatchProjectsLocationsGlobalHubsGroup", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/groups/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 2, 5, 1, 0, 4, 8, 5, 6}, []string{"v1", "projects", "locations", "global", "hubs", "groups", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5, 2, 6}, []string{"v1", "projects", "locations", "global", "hubs", "parent", "groups"}, ""))

	pattern_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 2, 5, 1, 0, 4, 8, 5, 6}, []string{"v1", "projects", "locations", "global", "hubs", "groups", "name"}, ""))
)

var (
	forward_ProjectsLocationsGlobalHubsGroupsServer_GetProjectsLocationsGlobalHubsGroup_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsGroupsServer_ListProjectsLocationsGlobalHubsGroups_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsGroupsServer_PatchProjectsLocationsGlobalHubsGroup_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerFromEndpoint is same as RegisterProjectsLocationsGlobalHubsRouteTablesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGlobalHubsRouteTablesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGlobalHubsRouteTablesServerHandler registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGlobalHubsRouteTablesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerClient(ctx, mux, NewProjectsLocationsGlobalHubsRouteTablesServerClient(conn))
}

// RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerClient registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGlobalHubsRouteTablesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGlobalHubsRouteTablesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGlobalHubsRouteTablesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGlobalHubsRouteTablesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGlobalHubsRouteTablesServerClient) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesServer/GetProjectsLocationsGlobalHubsRouteTable", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/routeTables/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesServer/ListProjectsLocationsGlobalHubsRouteTables", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*}/routeTables"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 2, 5, 1, 0, 4, 8, 5, 6}, []string{"v1", "projects", "locations", "global", "hubs", "routeTables", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5, 2, 6}, []string{"v1", "projects", "locations", "global", "hubs", "parent", "routeTables"}, ""))
)

var (
	forward_ProjectsLocationsGlobalHubsRouteTablesServer_GetProjectsLocationsGlobalHubsRouteTable_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsRouteTablesServer_ListProjectsLocationsGlobalHubsRouteTables_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerFromEndpoint is same as RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandler registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesRoutesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerClient(ctx, mux, NewProjectsLocationsGlobalHubsRouteTablesRoutesServerClient(conn))
}

// RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerClient registers the http handlers for service ProjectsLocationsGlobalHubsRouteTablesRoutesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGlobalHubsRouteTablesRoutesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGlobalHubsRouteTablesRoutesServerClient) error {

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesRoutesServer/GetProjectsLocationsGlobalHubsRouteTablesRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/hubs/*/routeTables/*/routes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalHubsRouteTablesRoutesServer/ListProjectsLocationsGlobalHubsRouteTablesRoutes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global/hubs/*/routeTables/*}/routes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 2, 5, 1, 0, 2, 6, 1, 0, 4, 10, 5, 7}, []string{"v1", "projects", "locations", "global", "hubs", "routeTables", "routes", "name"}, ""))

	pattern_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 2, 5, 1, 0, 4, 8, 5, 6, 2, 7}, []string{"v1", "projects", "locations", "global", "hubs", "routeTables", "parent", "routes"}, ""))
)

var (
	forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_GetProjectsLocationsGlobalHubsRouteTablesRoute_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalHubsRouteTablesRoutesServer_ListProjectsLocationsGlobalHubsRouteTablesRoutes_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerFromEndpoint is same as RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandler registers the http handlers for service ProjectsLocationsGlobalPolicyBasedRoutesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerClient(ctx, mux, NewProjectsLocationsGlobalPolicyBasedRoutesServerClient(conn))
}

// RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerClient registers the http handlers for service ProjectsLocationsGlobalPolicyBasedRoutesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsGlobalPolicyBasedRoutesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsGlobalPolicyBasedRoutesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsGlobalPolicyBasedRoutesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsGlobalPolicyBasedRoutesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsGlobalPolicyBasedRoutesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/CreateProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/policyBasedRoutes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/DeleteProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/policyBasedRoutes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/GetProjectsLocationsGlobalPolicyBasedRoute", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/global/policyBasedRoutes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsGlobalPolicyBasedRoutesServer/ListProjectsLocationsGlobalPolicyBasedRoutes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/global}/policyBasedRoutes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 4, 4, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "global", "parent", "policyBasedRoutes"}, ""))

	pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "policyBasedRoutes", "name"}, ""))

	pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 2, 4, 1, 0, 4, 6, 5, 5}, []string{"v1", "projects", "locations", "global", "policyBasedRoutes", "name"}, ""))

	pattern_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 2, 3, 4, 4, 5, 4, 2, 5}, []string{"v1", "projects", "locations", "global", "parent", "policyBasedRoutes"}, ""))
)

var (
	forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_CreateProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_DeleteProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_GetProjectsLocationsGlobalPolicyBasedRoute_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsGlobalPolicyBasedRoutesServer_ListProjectsLocationsGlobalPolicyBasedRoutes_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsInternalRangesServerHandlerFromEndpoint is same as RegisterProjectsLocationsInternalRangesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsInternalRangesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsInternalRangesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsInternalRangesServerHandler registers the http handlers for service ProjectsLocationsInternalRangesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsInternalRangesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsInternalRangesServerHandlerClient(ctx, mux, NewProjectsLocationsInternalRangesServerClient(conn))
}

// RegisterProjectsLocationsInternalRangesServerHandlerClient registers the http handlers for service ProjectsLocationsInternalRangesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsInternalRangesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsInternalRangesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsInternalRangesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsInternalRangesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsInternalRangesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/CreateProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/internalRanges"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/DeleteProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/GetProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/ListProjectsLocationsInternalRanges", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/internalRanges"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsInternalRangesServer/PatchProjectsLocationsInternalRange", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/internalRanges/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "internalRanges"}, ""))

	pattern_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "internalRanges", "name"}, ""))

	pattern_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "internalRanges", "name"}, ""))

	pattern_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "internalRanges"}, ""))

	pattern_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "internalRanges", "name"}, ""))
)

var (
	forward_ProjectsLocationsInternalRangesServer_CreateProjectsLocationsInternalRange_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInternalRangesServer_DeleteProjectsLocationsInternalRange_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInternalRangesServer_GetProjectsLocationsInternalRange_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInternalRangesServer_ListProjectsLocationsInternalRanges_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsInternalRangesServer_PatchProjectsLocationsInternalRange_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsRegionalEndpointsServerHandlerFromEndpoint is same as RegisterProjectsLocationsRegionalEndpointsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsRegionalEndpointsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsRegionalEndpointsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsRegionalEndpointsServerHandler registers the http handlers for service ProjectsLocationsRegionalEndpointsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsRegionalEndpointsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsRegionalEndpointsServerHandlerClient(ctx, mux, NewProjectsLocationsRegionalEndpointsServerClient(conn))
}

// RegisterProjectsLocationsRegionalEndpointsServerHandlerClient registers the http handlers for service ProjectsLocationsRegionalEndpointsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsRegionalEndpointsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsRegionalEndpointsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsRegionalEndpointsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsRegionalEndpointsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsRegionalEndpointsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/CreateProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/regionalEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/DeleteProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/regionalEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/GetProjectsLocationsRegionalEndpoint", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/regionalEndpoints/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsRegionalEndpointsServer/ListProjectsLocationsRegionalEndpoints", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/regionalEndpoints"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "regionalEndpoints"}, ""))

	pattern_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "regionalEndpoints", "name"}, ""))

	pattern_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "regionalEndpoints", "name"}, ""))

	pattern_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "regionalEndpoints"}, ""))
)

var (
	forward_ProjectsLocationsRegionalEndpointsServer_CreateProjectsLocationsRegionalEndpoint_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsRegionalEndpointsServer_DeleteProjectsLocationsRegionalEndpoint_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsRegionalEndpointsServer_GetProjectsLocationsRegionalEndpoint_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsRegionalEndpointsServer_ListProjectsLocationsRegionalEndpoints_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServiceClassesServerHandlerFromEndpoint is same as RegisterProjectsLocationsServiceClassesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServiceClassesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServiceClassesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServiceClassesServerHandler registers the http handlers for service ProjectsLocationsServiceClassesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServiceClassesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServiceClassesServerHandlerClient(ctx, mux, NewProjectsLocationsServiceClassesServerClient(conn))
}

// RegisterProjectsLocationsServiceClassesServerHandlerClient registers the http handlers for service ProjectsLocationsServiceClassesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServiceClassesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServiceClassesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServiceClassesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServiceClassesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServiceClassesServerClient) error {

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/DeleteProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/GetProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/ListProjectsLocationsServiceClasses", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceClasses"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceClassesServer/PatchProjectsLocationsServiceClasse", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceClasses/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceClasses", "name"}, ""))

	pattern_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceClasses", "name"}, ""))

	pattern_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceClasses"}, ""))

	pattern_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceClasses", "name"}, ""))
)

var (
	forward_ProjectsLocationsServiceClassesServer_DeleteProjectsLocationsServiceClasse_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceClassesServer_GetProjectsLocationsServiceClasse_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceClassesServer_ListProjectsLocationsServiceClasses_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceClassesServer_PatchProjectsLocationsServiceClasse_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServiceConnectionMapsServerHandlerFromEndpoint is same as RegisterProjectsLocationsServiceConnectionMapsServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServiceConnectionMapsServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServiceConnectionMapsServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServiceConnectionMapsServerHandler registers the http handlers for service ProjectsLocationsServiceConnectionMapsServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServiceConnectionMapsServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServiceConnectionMapsServerHandlerClient(ctx, mux, NewProjectsLocationsServiceConnectionMapsServerClient(conn))
}

// RegisterProjectsLocationsServiceConnectionMapsServerHandlerClient registers the http handlers for service ProjectsLocationsServiceConnectionMapsServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServiceConnectionMapsServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServiceConnectionMapsServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServiceConnectionMapsServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServiceConnectionMapsServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServiceConnectionMapsServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/CreateProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionMaps"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/DeleteProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/GetProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/ListProjectsLocationsServiceConnectionMaps", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionMaps"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionMapsServer/PatchProjectsLocationsServiceConnectionMap", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionMaps/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionMaps"}, ""))

	pattern_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionMaps", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionMaps", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionMaps"}, ""))

	pattern_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionMaps", "name"}, ""))
)

var (
	forward_ProjectsLocationsServiceConnectionMapsServer_CreateProjectsLocationsServiceConnectionMap_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionMapsServer_DeleteProjectsLocationsServiceConnectionMap_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionMapsServer_GetProjectsLocationsServiceConnectionMap_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionMapsServer_ListProjectsLocationsServiceConnectionMaps_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionMapsServer_PatchProjectsLocationsServiceConnectionMap_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerFromEndpoint is same as RegisterProjectsLocationsServiceConnectionPoliciesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServiceConnectionPoliciesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServiceConnectionPoliciesServerHandler registers the http handlers for service ProjectsLocationsServiceConnectionPoliciesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServiceConnectionPoliciesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerClient(ctx, mux, NewProjectsLocationsServiceConnectionPoliciesServerClient(conn))
}

// RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerClient registers the http handlers for service ProjectsLocationsServiceConnectionPoliciesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServiceConnectionPoliciesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServiceConnectionPoliciesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServiceConnectionPoliciesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServiceConnectionPoliciesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServiceConnectionPoliciesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/CreateProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/DeleteProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/GetProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/ListProjectsLocationsServiceConnectionPolicies", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionPolicies"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionPoliciesServer/PatchProjectsLocationsServiceConnectionPolicy", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionPolicies/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionPolicies"}, ""))

	pattern_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionPolicies", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionPolicies", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionPolicies"}, ""))

	pattern_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionPolicies", "name"}, ""))
)

var (
	forward_ProjectsLocationsServiceConnectionPoliciesServer_CreateProjectsLocationsServiceConnectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionPoliciesServer_DeleteProjectsLocationsServiceConnectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionPoliciesServer_GetProjectsLocationsServiceConnectionPolicy_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionPoliciesServer_ListProjectsLocationsServiceConnectionPolicies_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionPoliciesServer_PatchProjectsLocationsServiceConnectionPolicy_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsServiceConnectionTokensServerHandlerFromEndpoint is same as RegisterProjectsLocationsServiceConnectionTokensServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsServiceConnectionTokensServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsServiceConnectionTokensServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsServiceConnectionTokensServerHandler registers the http handlers for service ProjectsLocationsServiceConnectionTokensServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsServiceConnectionTokensServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsServiceConnectionTokensServerHandlerClient(ctx, mux, NewProjectsLocationsServiceConnectionTokensServerClient(conn))
}

// RegisterProjectsLocationsServiceConnectionTokensServerHandlerClient registers the http handlers for service ProjectsLocationsServiceConnectionTokensServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsServiceConnectionTokensServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsServiceConnectionTokensServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsServiceConnectionTokensServerClient" to call the correct interceptors.
func RegisterProjectsLocationsServiceConnectionTokensServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsServiceConnectionTokensServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/CreateProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionTokens"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/DeleteProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionTokens/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/GetProjectsLocationsServiceConnectionToken", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/serviceConnectionTokens/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsServiceConnectionTokensServer/ListProjectsLocationsServiceConnectionTokens", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/serviceConnectionTokens"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionTokens"}, ""))

	pattern_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionTokens", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "serviceConnectionTokens", "name"}, ""))

	pattern_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "serviceConnectionTokens"}, ""))
)

var (
	forward_ProjectsLocationsServiceConnectionTokensServer_CreateProjectsLocationsServiceConnectionToken_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionTokensServer_DeleteProjectsLocationsServiceConnectionToken_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionTokensServer_GetProjectsLocationsServiceConnectionToken_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsServiceConnectionTokensServer_ListProjectsLocationsServiceConnectionTokens_0 = runtime.ForwardResponseMessage
)

// RegisterProjectsLocationsSpokesServerHandlerFromEndpoint is same as RegisterProjectsLocationsSpokesServerHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterProjectsLocationsSpokesServerHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return RegisterProjectsLocationsSpokesServerHandler(ctx, mux, conn)
}

// RegisterProjectsLocationsSpokesServerHandler registers the http handlers for service ProjectsLocationsSpokesServer to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterProjectsLocationsSpokesServerHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterProjectsLocationsSpokesServerHandlerClient(ctx, mux, NewProjectsLocationsSpokesServerClient(conn))
}

// RegisterProjectsLocationsSpokesServerHandlerClient registers the http handlers for service ProjectsLocationsSpokesServer
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ProjectsLocationsSpokesServerClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ProjectsLocationsSpokesServerClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ProjectsLocationsSpokesServerClient" to call the correct interceptors.
func RegisterProjectsLocationsSpokesServerHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ProjectsLocationsSpokesServerClient) error {

	mux.Handle("POST", pattern_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/CreateProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/spokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("DELETE", pattern_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/DeleteProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/GetProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("GET", pattern_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/ListProjectsLocationsSpokes", runtime.WithHTTPPathPattern("/v1/{parent=projects/*/locations/*}/spokes"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	mux.Handle("PATCH", pattern_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/mockgcp.cloud.networkconnectivity.v1.ProjectsLocationsSpokesServer/PatchProjectsLocationsSpoke", runtime.WithHTTPPathPattern("/v1/{name=projects/*/locations/*/spokes/*}"))
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(annotatedContext, inboundMarshaler, client, req, pathParams)
		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

var (
	pattern_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "spokes"}, ""))

	pattern_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "spokes", "name"}, ""))

	pattern_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "spokes", "name"}, ""))

	pattern_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 4, 4, 5, 3, 2, 4}, []string{"v1", "projects", "locations", "parent", "spokes"}, ""))

	pattern_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 2, 2, 1, 0, 2, 3, 1, 0, 4, 6, 5, 4}, []string{"v1", "projects", "locations", "spokes", "name"}, ""))
)

var (
	forward_ProjectsLocationsSpokesServer_CreateProjectsLocationsSpoke_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsSpokesServer_DeleteProjectsLocationsSpoke_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsSpokesServer_GetProjectsLocationsSpoke_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsSpokesServer_ListProjectsLocationsSpokes_0 = runtime.ForwardResponseMessage

	forward_ProjectsLocationsSpokesServer_PatchProjectsLocationsSpoke_0 = runtime.ForwardResponseMessage
)
